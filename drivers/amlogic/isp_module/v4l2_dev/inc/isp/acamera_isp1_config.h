/*
*
* SPDX-License-Identifier: GPL-2.0
*
* Copyright (C) 2011-2018 ARM or its affiliates
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; version 2.
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
* You should have received a copy of the GNU General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
*
*/

#ifndef __ACAMERA_ISP1_CONFIG_H__
#define __ACAMERA_ISP1_CONFIG_H__


#include "system_sw_io.h"

#include "system_hw_io.h"

// ------------------------------------------------------------------------------ //
// Instance 'isp1' of module 'single_context_config'
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP1_BASE_ADDR (0x18e88L)
#define ACAMERA_ISP1_SIZE (0x4000)

// ------------------------------------------------------------------------------ //
// Group: top
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Miscellaneous top-level ISP controls
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Active Width
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Active video width in pixels
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_ACTIVE_WIDTH_DEFAULT (0x780)
#define ACAMERA_ISP_TOP_ACTIVE_WIDTH_DATASIZE (16)
#define ACAMERA_ISP_TOP_ACTIVE_WIDTH_OFFSET (0x0)
#define ACAMERA_ISP_TOP_ACTIVE_WIDTH_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_top_active_width_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18e88L);
    system_sw_write_32(base + 0x18e88L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_top_active_width_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18e88L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Active Height
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Active video height in lines
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_ACTIVE_HEIGHT_DEFAULT (0x438)
#define ACAMERA_ISP_TOP_ACTIVE_HEIGHT_DATASIZE (16)
#define ACAMERA_ISP_TOP_ACTIVE_HEIGHT_OFFSET (0x0)
#define ACAMERA_ISP_TOP_ACTIVE_HEIGHT_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_top_active_height_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18e88L);
    system_sw_write_32(base + 0x18e88L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_top_active_height_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18e88L) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: RGGB start pre mirror
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Starting color of the rggb pattern for all the modules before mirror
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_RGGB_START_PRE_MIRROR_DEFAULT (0x0)
#define ACAMERA_ISP_TOP_RGGB_START_PRE_MIRROR_DATASIZE (2)
#define ACAMERA_ISP_TOP_RGGB_START_PRE_MIRROR_OFFSET (0x4)
#define ACAMERA_ISP_TOP_RGGB_START_PRE_MIRROR_MASK (0x3)
#define ACAMERA_ISP_TOP_RGGB_START_PRE_MIRROR_R_GR_GB_B (0)
#define ACAMERA_ISP_TOP_RGGB_START_PRE_MIRROR_GR_R_B_GB (1)
#define ACAMERA_ISP_TOP_RGGB_START_PRE_MIRROR_GB_B_R_GR (2)
#define ACAMERA_ISP_TOP_RGGB_START_PRE_MIRROR_B_GB_GR_R (3)

// args: data (2-bit)
static __inline void acamera_isp_top_rggb_start_pre_mirror_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18e8cL);
    system_sw_write_32(base + 0x18e8cL, (((uint32_t) (data & 0x3)) << 0) | (curr & 0xfffffffc));
}
static __inline uint8_t acamera_isp_top_rggb_start_pre_mirror_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18e8cL) & 0x3) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: RGGB start post mirror
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Starting color of the rggb pattern for all the modules after mirror
//        this must be same as RGGB start pre mirror if mirror is bypassed
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_RGGB_START_POST_MIRROR_DEFAULT (0x0)
#define ACAMERA_ISP_TOP_RGGB_START_POST_MIRROR_DATASIZE (2)
#define ACAMERA_ISP_TOP_RGGB_START_POST_MIRROR_OFFSET (0x4)
#define ACAMERA_ISP_TOP_RGGB_START_POST_MIRROR_MASK (0x300)

// args: data (2-bit)
static __inline void acamera_isp_top_rggb_start_post_mirror_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18e8cL);
    system_sw_write_32(base + 0x18e8cL, (((uint32_t) (data & 0x3)) << 8) | (curr & 0xfffffcff));
}
static __inline uint8_t acamera_isp_top_rggb_start_post_mirror_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18e8cL) & 0x300) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: Cfa pattern
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// The pixel arrangement of the CFA array on the sensor. Set in the Top register group and used by several blocks in the pipeline:
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_CFA_PATTERN_DEFAULT (0x0)
#define ACAMERA_ISP_TOP_CFA_PATTERN_DATASIZE (2)
#define ACAMERA_ISP_TOP_CFA_PATTERN_OFFSET (0x4)
#define ACAMERA_ISP_TOP_CFA_PATTERN_MASK (0x30000)
#define ACAMERA_ISP_TOP_CFA_PATTERN_RGGB (0)
#define ACAMERA_ISP_TOP_CFA_PATTERN_RESERVED (1)
#define ACAMERA_ISP_TOP_CFA_PATTERN_RIRGB (2)
#define ACAMERA_ISP_TOP_CFA_PATTERN_RGIRB (3)

// args: data (2-bit)
static __inline void acamera_isp_top_cfa_pattern_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18e8cL);
    system_sw_write_32(base + 0x18e8cL, (((uint32_t) (data & 0x3)) << 16) | (curr & 0xfffcffff));
}
static __inline uint8_t acamera_isp_top_cfa_pattern_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18e8cL) & 0x30000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Linear data src
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Linear data src
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_LINEAR_DATA_SRC_DEFAULT (0x0)
#define ACAMERA_ISP_TOP_LINEAR_DATA_SRC_DATASIZE (2)
#define ACAMERA_ISP_TOP_LINEAR_DATA_SRC_OFFSET (0x4)
#define ACAMERA_ISP_TOP_LINEAR_DATA_SRC_MASK (0x3000000)
#define ACAMERA_ISP_TOP_LINEAR_DATA_SRC_SENSOR_STITCHED_AND_LINEAR_DATA_DIRECTLY_COMING_FROM_SENSOR (0)
#define ACAMERA_ISP_TOP_LINEAR_DATA_SRC_LINEAR_DATA_FROM_FRAME_STITCH (1)
#define ACAMERA_ISP_TOP_LINEAR_DATA_SRC_SENSOR_COMPANDED_DATA_LINEARISED_THROUGH_DECOMPANDER (2)
#define ACAMERA_ISP_TOP_LINEAR_DATA_SRC_RESERVED (3)

// args: data (2-bit)
static __inline void acamera_isp_top_linear_data_src_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18e8cL);
    system_sw_write_32(base + 0x18e8cL, (((uint32_t) (data & 0x3)) << 24) | (curr & 0xfcffffff));
}
static __inline uint8_t acamera_isp_top_linear_data_src_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18e8cL) & 0x3000000) >> 24);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass video test gen
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass video test generator
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_VIDEO_TEST_GEN_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_VIDEO_TEST_GEN_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_VIDEO_TEST_GEN_OFFSET (0x24)
#define ACAMERA_ISP_TOP_BYPASS_VIDEO_TEST_GEN_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_video_test_gen_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18eacL);
    system_sw_write_32(base + 0x18eacL, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_top_bypass_video_test_gen_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18eacL) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass input formatter
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass input formatter module.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_INPUT_FORMATTER_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_INPUT_FORMATTER_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_INPUT_FORMATTER_OFFSET (0x24)
#define ACAMERA_ISP_TOP_BYPASS_INPUT_FORMATTER_MASK (0x2)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_input_formatter_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18eacL);
    system_sw_write_32(base + 0x18eacL, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
}
static __inline uint8_t acamera_isp_top_bypass_input_formatter_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18eacL) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass decompander
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass front end decompander
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_DECOMPANDER_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_DECOMPANDER_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_DECOMPANDER_OFFSET (0x24)
#define ACAMERA_ISP_TOP_BYPASS_DECOMPANDER_MASK (0x4)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_decompander_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18eacL);
    system_sw_write_32(base + 0x18eacL, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
}
static __inline uint8_t acamera_isp_top_bypass_decompander_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18eacL) & 0x4) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass sensor offset wdr
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass sensor offset wdr
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_SENSOR_OFFSET_WDR_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_SENSOR_OFFSET_WDR_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_SENSOR_OFFSET_WDR_OFFSET (0x24)
#define ACAMERA_ISP_TOP_BYPASS_SENSOR_OFFSET_WDR_MASK (0x8)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_sensor_offset_wdr_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18eacL);
    system_sw_write_32(base + 0x18eacL, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
}
static __inline uint8_t acamera_isp_top_bypass_sensor_offset_wdr_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18eacL) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass gain wdr
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass gain wdr
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_GAIN_WDR_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_GAIN_WDR_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_GAIN_WDR_OFFSET (0x24)
#define ACAMERA_ISP_TOP_BYPASS_GAIN_WDR_MASK (0x10)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_gain_wdr_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18eacL);
    system_sw_write_32(base + 0x18eacL, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
}
static __inline uint8_t acamera_isp_top_bypass_gain_wdr_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18eacL) & 0x10) >> 4);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass frame stitch
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass frame stitching logic
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_FRAME_STITCH_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_FRAME_STITCH_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_FRAME_STITCH_OFFSET (0x24)
#define ACAMERA_ISP_TOP_BYPASS_FRAME_STITCH_MASK (0x20)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_frame_stitch_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18eacL);
    system_sw_write_32(base + 0x18eacL, (((uint32_t) (data & 0x1)) << 5) | (curr & 0xffffffdf));
}
static __inline uint8_t acamera_isp_top_bypass_frame_stitch_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18eacL) & 0x20) >> 5);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass digital gain
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass digital gain module
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_DIGITAL_GAIN_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_DIGITAL_GAIN_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_DIGITAL_GAIN_OFFSET (0x28)
#define ACAMERA_ISP_TOP_BYPASS_DIGITAL_GAIN_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_digital_gain_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18eb0L);
    system_sw_write_32(base + 0x18eb0L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_top_bypass_digital_gain_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18eb0L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass frontend sensor offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass digital gain module
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_FRONTEND_SENSOR_OFFSET_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_FRONTEND_SENSOR_OFFSET_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_FRONTEND_SENSOR_OFFSET_OFFSET (0x28)
#define ACAMERA_ISP_TOP_BYPASS_FRONTEND_SENSOR_OFFSET_MASK (0x2)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_frontend_sensor_offset_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18eb0L);
    system_sw_write_32(base + 0x18eb0L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
}
static __inline uint8_t acamera_isp_top_bypass_frontend_sensor_offset_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18eb0L) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass fe sqrt
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass square root function before raw frontend 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_FE_SQRT_DEFAULT (1)
#define ACAMERA_ISP_TOP_BYPASS_FE_SQRT_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_FE_SQRT_OFFSET (0x28)
#define ACAMERA_ISP_TOP_BYPASS_FE_SQRT_MASK (0x4)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_fe_sqrt_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18eb0L);
    system_sw_write_32(base + 0x18eb0L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
}
static __inline uint8_t acamera_isp_top_bypass_fe_sqrt_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18eb0L) & 0x4) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass RAW frontend
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass RAW frontend (green equalization and dynamic defect pixel)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_RAW_FRONTEND_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_RAW_FRONTEND_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_RAW_FRONTEND_OFFSET (0x28)
#define ACAMERA_ISP_TOP_BYPASS_RAW_FRONTEND_MASK (0x8)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_raw_frontend_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18eb0L);
    system_sw_write_32(base + 0x18eb0L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
}
static __inline uint8_t acamera_isp_top_bypass_raw_frontend_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18eb0L) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass defect pixel
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass static defect pixel
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_DEFECT_PIXEL_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_DEFECT_PIXEL_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_DEFECT_PIXEL_OFFSET (0x28)
#define ACAMERA_ISP_TOP_BYPASS_DEFECT_PIXEL_MASK (0x10)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_defect_pixel_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18eb0L);
    system_sw_write_32(base + 0x18eb0L, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
}
static __inline uint8_t acamera_isp_top_bypass_defect_pixel_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18eb0L) & 0x10) >> 4);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass sinter
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass sinter 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_SINTER_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_SINTER_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_SINTER_OFFSET (0x30)
#define ACAMERA_ISP_TOP_BYPASS_SINTER_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_sinter_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18eb8L);
    system_sw_write_32(base + 0x18eb8L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_top_bypass_sinter_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18eb8L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass temper
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass temper 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_TEMPER_DEFAULT (1)
#define ACAMERA_ISP_TOP_BYPASS_TEMPER_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_TEMPER_OFFSET (0x30)
#define ACAMERA_ISP_TOP_BYPASS_TEMPER_MASK (0x2)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_temper_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18eb8L);
    system_sw_write_32(base + 0x18eb8L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
}
static __inline uint8_t acamera_isp_top_bypass_temper_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18eb8L) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass ca correction
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass chromatic abberation correction 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_CA_CORRECTION_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_CA_CORRECTION_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_CA_CORRECTION_OFFSET (0x30)
#define ACAMERA_ISP_TOP_BYPASS_CA_CORRECTION_MASK (0x4)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_ca_correction_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18eb8L);
    system_sw_write_32(base + 0x18eb8L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
}
static __inline uint8_t acamera_isp_top_bypass_ca_correction_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18eb8L) & 0x4) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass square_be
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass backend square
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_SQUARE_BE_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_SQUARE_BE_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_SQUARE_BE_OFFSET (0x34)
#define ACAMERA_ISP_TOP_BYPASS_SQUARE_BE_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_square_be_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ebcL);
    system_sw_write_32(base + 0x18ebcL, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_top_bypass_square_be_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ebcL) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass sensor_offset_pre_shading
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass sensor offset pre shading
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_SENSOR_OFFSET_PRE_SHADING_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_SENSOR_OFFSET_PRE_SHADING_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_SENSOR_OFFSET_PRE_SHADING_OFFSET (0x34)
#define ACAMERA_ISP_TOP_BYPASS_SENSOR_OFFSET_PRE_SHADING_MASK (0x2)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_sensor_offset_pre_shading_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ebcL);
    system_sw_write_32(base + 0x18ebcL, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
}
static __inline uint8_t acamera_isp_top_bypass_sensor_offset_pre_shading_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ebcL) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass radial shading
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass radial shading
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_RADIAL_SHADING_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_RADIAL_SHADING_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_RADIAL_SHADING_OFFSET (0x34)
#define ACAMERA_ISP_TOP_BYPASS_RADIAL_SHADING_MASK (0x4)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_radial_shading_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ebcL);
    system_sw_write_32(base + 0x18ebcL, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
}
static __inline uint8_t acamera_isp_top_bypass_radial_shading_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ebcL) & 0x4) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass mesh shading
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass mesh ashading
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_MESH_SHADING_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_MESH_SHADING_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_MESH_SHADING_OFFSET (0x34)
#define ACAMERA_ISP_TOP_BYPASS_MESH_SHADING_MASK (0x8)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_mesh_shading_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ebcL);
    system_sw_write_32(base + 0x18ebcL, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
}
static __inline uint8_t acamera_isp_top_bypass_mesh_shading_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ebcL) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass white balance
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass white balance 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_WHITE_BALANCE_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_WHITE_BALANCE_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_WHITE_BALANCE_OFFSET (0x34)
#define ACAMERA_ISP_TOP_BYPASS_WHITE_BALANCE_MASK (0x10)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_white_balance_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ebcL);
    system_sw_write_32(base + 0x18ebcL, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
}
static __inline uint8_t acamera_isp_top_bypass_white_balance_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ebcL) & 0x10) >> 4);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass iridix gain
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_IRIDIX_GAIN_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_IRIDIX_GAIN_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_IRIDIX_GAIN_OFFSET (0x34)
#define ACAMERA_ISP_TOP_BYPASS_IRIDIX_GAIN_MASK (0x20)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_iridix_gain_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ebcL);
    system_sw_write_32(base + 0x18ebcL, (((uint32_t) (data & 0x1)) << 5) | (curr & 0xffffffdf));
}
static __inline uint8_t acamera_isp_top_bypass_iridix_gain_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ebcL) & 0x20) >> 5);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass iridix
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_IRIDIX_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_IRIDIX_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_IRIDIX_OFFSET (0x34)
#define ACAMERA_ISP_TOP_BYPASS_IRIDIX_MASK (0x40)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_iridix_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ebcL);
    system_sw_write_32(base + 0x18ebcL, (((uint32_t) (data & 0x1)) << 6) | (curr & 0xffffffbf));
}
static __inline uint8_t acamera_isp_top_bypass_iridix_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ebcL) & 0x40) >> 6);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass mirror
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass EW mirror
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_MIRROR_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_MIRROR_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_MIRROR_OFFSET (0x38)
#define ACAMERA_ISP_TOP_BYPASS_MIRROR_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_mirror_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ec0L);
    system_sw_write_32(base + 0x18ec0L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_top_bypass_mirror_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ec0L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass demosaic rgb
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass demosaic rgb
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_DEMOSAIC_RGB_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_DEMOSAIC_RGB_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_DEMOSAIC_RGB_OFFSET (0x38)
#define ACAMERA_ISP_TOP_BYPASS_DEMOSAIC_RGB_MASK (0x2)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_demosaic_rgb_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ec0L);
    system_sw_write_32(base + 0x18ec0L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
}
static __inline uint8_t acamera_isp_top_bypass_demosaic_rgb_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ec0L) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass demosaic rgbir
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass demosaic rgbir
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_DEMOSAIC_RGBIR_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_DEMOSAIC_RGBIR_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_DEMOSAIC_RGBIR_OFFSET (0x38)
#define ACAMERA_ISP_TOP_BYPASS_DEMOSAIC_RGBIR_MASK (0x4)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_demosaic_rgbir_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ec0L);
    system_sw_write_32(base + 0x18ec0L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
}
static __inline uint8_t acamera_isp_top_bypass_demosaic_rgbir_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ec0L) & 0x4) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass pf correction
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass pf correction
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_PF_CORRECTION_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_PF_CORRECTION_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_PF_CORRECTION_OFFSET (0x38)
#define ACAMERA_ISP_TOP_BYPASS_PF_CORRECTION_MASK (0x8)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_pf_correction_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ec0L);
    system_sw_write_32(base + 0x18ec0L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
}
static __inline uint8_t acamera_isp_top_bypass_pf_correction_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ec0L) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass CCM
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass CCM
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_CCM_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_CCM_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_CCM_OFFSET (0x38)
#define ACAMERA_ISP_TOP_BYPASS_CCM_MASK (0x10)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_ccm_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ec0L);
    system_sw_write_32(base + 0x18ec0L, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
}
static __inline uint8_t acamera_isp_top_bypass_ccm_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ec0L) & 0x10) >> 4);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass CNR
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass CNR
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_CNR_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_CNR_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_CNR_OFFSET (0x38)
#define ACAMERA_ISP_TOP_BYPASS_CNR_MASK (0x20)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_cnr_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ec0L);
    system_sw_write_32(base + 0x18ec0L, (((uint32_t) (data & 0x1)) << 5) | (curr & 0xffffffdf));
}
static __inline uint8_t acamera_isp_top_bypass_cnr_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ec0L) & 0x20) >> 5);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass 3D lut
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass 3d lut
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_3D_LUT_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_3D_LUT_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_3D_LUT_OFFSET (0x38)
#define ACAMERA_ISP_TOP_BYPASS_3D_LUT_MASK (0x40)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_3d_lut_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ec0L);
    system_sw_write_32(base + 0x18ec0L, (((uint32_t) (data & 0x1)) << 6) | (curr & 0xffffffbf));
}
static __inline uint8_t acamera_isp_top_bypass_3d_lut_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ec0L) & 0x40) >> 6);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass nonequ gamma
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass nonequ gamma
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_NONEQU_GAMMA_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_NONEQU_GAMMA_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_NONEQU_GAMMA_OFFSET (0x38)
#define ACAMERA_ISP_TOP_BYPASS_NONEQU_GAMMA_MASK (0x80)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_nonequ_gamma_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ec0L);
    system_sw_write_32(base + 0x18ec0L, (((uint32_t) (data & 0x1)) << 7) | (curr & 0xffffff7f));
}
static __inline uint8_t acamera_isp_top_bypass_nonequ_gamma_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ec0L) & 0x80) >> 7);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass fr crop
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass fr crop 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_FR_CROP_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_FR_CROP_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_FR_CROP_OFFSET (0x3c)
#define ACAMERA_ISP_TOP_BYPASS_FR_CROP_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_fr_crop_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ec4L);
    system_sw_write_32(base + 0x18ec4L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_top_bypass_fr_crop_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ec4L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass fr gamma rgb
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass fr gamma rgb 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_FR_GAMMA_RGB_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_FR_GAMMA_RGB_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_FR_GAMMA_RGB_OFFSET (0x3c)
#define ACAMERA_ISP_TOP_BYPASS_FR_GAMMA_RGB_MASK (0x2)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_fr_gamma_rgb_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ec4L);
    system_sw_write_32(base + 0x18ec4L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
}
static __inline uint8_t acamera_isp_top_bypass_fr_gamma_rgb_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ec4L) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass fr sharpen
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass fr sharpen
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_FR_SHARPEN_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_FR_SHARPEN_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_FR_SHARPEN_OFFSET (0x3c)
#define ACAMERA_ISP_TOP_BYPASS_FR_SHARPEN_MASK (0x4)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_fr_sharpen_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ec4L);
    system_sw_write_32(base + 0x18ec4L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
}
static __inline uint8_t acamera_isp_top_bypass_fr_sharpen_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ec4L) & 0x4) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass fr cs conv
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass fr cs conv
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_FR_CS_CONV_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_FR_CS_CONV_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_FR_CS_CONV_OFFSET (0x3c)
#define ACAMERA_ISP_TOP_BYPASS_FR_CS_CONV_MASK (0x8)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_fr_cs_conv_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ec4L);
    system_sw_write_32(base + 0x18ec4L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
}
static __inline uint8_t acamera_isp_top_bypass_fr_cs_conv_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ec4L) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass ds crop
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass ds crop 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_DS1_CROP_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_DS1_CROP_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_DS1_CROP_OFFSET (0x40)
#define ACAMERA_ISP_TOP_BYPASS_DS1_CROP_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_ds1_crop_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ec8L);
    system_sw_write_32(base + 0x18ec8L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_top_bypass_ds1_crop_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ec8L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass ds scaler
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass ds scaler 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_DS1_SCALER_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_DS1_SCALER_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_DS1_SCALER_OFFSET (0x40)
#define ACAMERA_ISP_TOP_BYPASS_DS1_SCALER_MASK (0x2)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_ds1_scaler_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ec8L);
    system_sw_write_32(base + 0x18ec8L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
}
static __inline uint8_t acamera_isp_top_bypass_ds1_scaler_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ec8L) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass ds gamma rgb
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass ds gamma rgb 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_DS1_GAMMA_RGB_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_DS1_GAMMA_RGB_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_DS1_GAMMA_RGB_OFFSET (0x40)
#define ACAMERA_ISP_TOP_BYPASS_DS1_GAMMA_RGB_MASK (0x4)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_ds1_gamma_rgb_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ec8L);
    system_sw_write_32(base + 0x18ec8L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
}
static __inline uint8_t acamera_isp_top_bypass_ds1_gamma_rgb_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ec8L) & 0x4) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass ds sharpen
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass ds sharpen
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_DS1_SHARPEN_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_DS1_SHARPEN_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_DS1_SHARPEN_OFFSET (0x40)
#define ACAMERA_ISP_TOP_BYPASS_DS1_SHARPEN_MASK (0x8)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_ds1_sharpen_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ec8L);
    system_sw_write_32(base + 0x18ec8L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
}
static __inline uint8_t acamera_isp_top_bypass_ds1_sharpen_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ec8L) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: Bypass ds cs conv
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bypass ds cs conv
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_BYPASS_DS1_CS_CONV_DEFAULT (0)
#define ACAMERA_ISP_TOP_BYPASS_DS1_CS_CONV_DATASIZE (1)
#define ACAMERA_ISP_TOP_BYPASS_DS1_CS_CONV_OFFSET (0x40)
#define ACAMERA_ISP_TOP_BYPASS_DS1_CS_CONV_MASK (0x10)

// args: data (1-bit)
static __inline void acamera_isp_top_bypass_ds1_cs_conv_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ec8L);
    system_sw_write_32(base + 0x18ec8L, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
}
static __inline uint8_t acamera_isp_top_bypass_ds1_cs_conv_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ec8L) & 0x10) >> 4);
}
// ------------------------------------------------------------------------------ //
// Register: ISP RAW bypass
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//   Used to select between normal ISP processing with image sensor data and up to 12 bit RGB input.
//                         In the latler case data is reinserted into pipeline after purple fringing correction block.
//          
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_ISP_RAW_BYPASS_DEFAULT (0)
#define ACAMERA_ISP_TOP_ISP_RAW_BYPASS_DATASIZE (1)
#define ACAMERA_ISP_TOP_ISP_RAW_BYPASS_OFFSET (0x44)
#define ACAMERA_ISP_TOP_ISP_RAW_BYPASS_MASK (0x1)
#define ACAMERA_ISP_TOP_ISP_RAW_BYPASS_SELECT_PROCESSED (0)
#define ACAMERA_ISP_TOP_ISP_RAW_BYPASS_BYPASS_ISP_RAW_PROCESSING (1)

// args: data (1-bit)
static __inline void acamera_isp_top_isp_raw_bypass_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18eccL);
    system_sw_write_32(base + 0x18eccL, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_top_isp_raw_bypass_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18eccL) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: ISP downscale pipe disable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            0: Downscale pipeline is enabled
//            1: Downscale pipeline is disabled. No data is sent out in DMA and streaming channel
//          
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_ISP_DOWNSCALE_PIPE_DISABLE_DEFAULT (0)
#define ACAMERA_ISP_TOP_ISP_DOWNSCALE_PIPE_DISABLE_DATASIZE (1)
#define ACAMERA_ISP_TOP_ISP_DOWNSCALE_PIPE_DISABLE_OFFSET (0x44)
#define ACAMERA_ISP_TOP_ISP_DOWNSCALE_PIPE_DISABLE_MASK (0x2)
#define ACAMERA_ISP_TOP_ISP_DOWNSCALE_PIPE_DISABLE_SELECT_PROCESSED (0)
#define ACAMERA_ISP_TOP_ISP_DOWNSCALE_PIPE_DISABLE_BYPASS_ISP_RAW_PROCESSING (1)

// args: data (1-bit)
static __inline void acamera_isp_top_isp_downscale_pipe_disable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18eccL);
    system_sw_write_32(base + 0x18eccL, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
}
static __inline uint8_t acamera_isp_top_isp_downscale_pipe_disable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18eccL) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: ISP processing fr bypass mode
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  
//              ISP FR bypass modes.  For debug purposes only. Should be set to 0 during normal operation. 
//              Used to bypass entire ISP after input port or to pass the stitched image directly to the output.
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_ISP_PROCESSING_FR_BYPASS_MODE_DEFAULT (0)
#define ACAMERA_ISP_TOP_ISP_PROCESSING_FR_BYPASS_MODE_DATASIZE (2)
#define ACAMERA_ISP_TOP_ISP_PROCESSING_FR_BYPASS_MODE_OFFSET (0x44)
#define ACAMERA_ISP_TOP_ISP_PROCESSING_FR_BYPASS_MODE_MASK (0x300)
#define ACAMERA_ISP_TOP_ISP_PROCESSING_FR_BYPASS_MODE_FULL_PROCESSING (0)
#define ACAMERA_ISP_TOP_ISP_PROCESSING_FR_BYPASS_MODE_BYPASS_ENTIRE_ISP_PROCESSING_AND_OUTPUT_194_OF_RAW_SENSOR_DATA_AFTER_VIDEO_TEST_GEN (1)
#define ACAMERA_ISP_TOP_ISP_PROCESSING_FR_BYPASS_MODE_BYPASS_ENTIRE_ISP_PROCESSING_AND_OUTPUT_LSB_10BITS_BITS_OF_RAW_SENSOR_DATA_AFTER_VIDEO_TEST_GEN_DATA_MUST_BE_MSB_ALIGNED (2)

// args: data (2-bit)
static __inline void acamera_isp_top_isp_processing_fr_bypass_mode_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18eccL);
    system_sw_write_32(base + 0x18eccL, (((uint32_t) (data & 0x3)) << 8) | (curr & 0xfffffcff));
}
static __inline uint8_t acamera_isp_top_isp_processing_fr_bypass_mode_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18eccL) & 0x300) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: AE 5bin hist disable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        0: AEXP 5-bin histogram enabled
//        1: AEXP 5-bin histogram disabled
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_AE_5BIN_HIST_DISABLE_DEFAULT (0)
#define ACAMERA_ISP_TOP_AE_5BIN_HIST_DISABLE_DATASIZE (1)
#define ACAMERA_ISP_TOP_AE_5BIN_HIST_DISABLE_OFFSET (0x48)
#define ACAMERA_ISP_TOP_AE_5BIN_HIST_DISABLE_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_top_ae_5bin_hist_disable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ed0L);
    system_sw_write_32(base + 0x18ed0L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_top_ae_5bin_hist_disable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ed0L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: AE switch
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// AE 5bin histogram tap in the pipeline.  Location of AE statistic collection.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_AE_SWITCH_DEFAULT (0)
#define ACAMERA_ISP_TOP_AE_SWITCH_DATASIZE (2)
#define ACAMERA_ISP_TOP_AE_SWITCH_OFFSET (0x48)
#define ACAMERA_ISP_TOP_AE_SWITCH_MASK (0x6)
#define ACAMERA_ISP_TOP_AE_SWITCH_AFTER_STATIC_WHITE_BALANCE_WHOSE_POSITION_IS_SELECTED_BY_AEXP_SRC_SIGNAL (0)
#define ACAMERA_ISP_TOP_AE_SWITCH_AFTER_WDR_FRAME_STITCH_IF_ITS_SENSOR_COMPANDED_DATA_THEN_USE_DECOMPANDED_OUTPUT_IF_ITS_SENSOR_LINEARISED_DATA_THEN_USE_IT_DIRECTLY (1)
#define ACAMERA_ISP_TOP_AE_SWITCH_AFTER_VTPG (2)
#define ACAMERA_ISP_TOP_AE_SWITCH_RESERVED (3)

// args: data (2-bit)
static __inline void acamera_isp_top_ae_switch_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ed0L);
    system_sw_write_32(base + 0x18ed0L, (((uint32_t) (data & 0x3)) << 1) | (curr & 0xfffffff9));
}
static __inline uint8_t acamera_isp_top_ae_switch_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ed0L) & 0x6) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: AF disable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        0: AF enabled
//        1: AF disabled
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_AF_DISABLE_DEFAULT (0)
#define ACAMERA_ISP_TOP_AF_DISABLE_DATASIZE (1)
#define ACAMERA_ISP_TOP_AF_DISABLE_OFFSET (0x48)
#define ACAMERA_ISP_TOP_AF_DISABLE_MASK (0x10)

// args: data (1-bit)
static __inline void acamera_isp_top_af_disable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ed0L);
    system_sw_write_32(base + 0x18ed0L, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
}
static __inline uint8_t acamera_isp_top_af_disable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ed0L) & 0x10) >> 4);
}
// ------------------------------------------------------------------------------ //
// Register: AF switch
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// AF tap in the pipeline.  .
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_AF_SWITCH_DEFAULT (0)
#define ACAMERA_ISP_TOP_AF_SWITCH_DATASIZE (1)
#define ACAMERA_ISP_TOP_AF_SWITCH_OFFSET (0x48)
#define ACAMERA_ISP_TOP_AF_SWITCH_MASK (0x20)
#define ACAMERA_ISP_TOP_AF_SWITCH_AFTER_SINTER (0)
#define ACAMERA_ISP_TOP_AF_SWITCH_BEFORE_SINTER (1)

// args: data (1-bit)
static __inline void acamera_isp_top_af_switch_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ed0L);
    system_sw_write_32(base + 0x18ed0L, (((uint32_t) (data & 0x1)) << 5) | (curr & 0xffffffdf));
}
static __inline uint8_t acamera_isp_top_af_switch_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ed0L) & 0x20) >> 5);
}
// ------------------------------------------------------------------------------ //
// Register: AWB disable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        0: AWB enabled
//        1: AWB disabled
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_AWB_DISABLE_DEFAULT (0)
#define ACAMERA_ISP_TOP_AWB_DISABLE_DATASIZE (1)
#define ACAMERA_ISP_TOP_AWB_DISABLE_OFFSET (0x48)
#define ACAMERA_ISP_TOP_AWB_DISABLE_MASK (0x100)

// args: data (1-bit)
static __inline void acamera_isp_top_awb_disable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ed0L);
    system_sw_write_32(base + 0x18ed0L, (((uint32_t) (data & 0x1)) << 8) | (curr & 0xfffffeff));
}
static __inline uint8_t acamera_isp_top_awb_disable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ed0L) & 0x100) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: AWB switch
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// AWB tap in the pipeline.  Location of AWB statistics collection.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_AWB_SWITCH_DEFAULT (0)
#define ACAMERA_ISP_TOP_AWB_SWITCH_DATASIZE (1)
#define ACAMERA_ISP_TOP_AWB_SWITCH_OFFSET (0x48)
#define ACAMERA_ISP_TOP_AWB_SWITCH_MASK (0x200)
#define ACAMERA_ISP_TOP_AWB_SWITCH_IMMEDIATELY_AFTER_DEMOSAIC (0)
#define ACAMERA_ISP_TOP_AWB_SWITCH_IMMEDIATELY_AFTER_CNR (1)

// args: data (1-bit)
static __inline void acamera_isp_top_awb_switch_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ed0L);
    system_sw_write_32(base + 0x18ed0L, (((uint32_t) (data & 0x1)) << 9) | (curr & 0xfffffdff));
}
static __inline uint8_t acamera_isp_top_awb_switch_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ed0L) & 0x200) >> 9);
}
// ------------------------------------------------------------------------------ //
// Register: AEXP hist disable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        0: AEXP 1024-bin histogram enabled
//        1: AEXP 1024-bin histogram disabled
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_AEXP_HIST_DISABLE_DEFAULT (0)
#define ACAMERA_ISP_TOP_AEXP_HIST_DISABLE_DATASIZE (1)
#define ACAMERA_ISP_TOP_AEXP_HIST_DISABLE_OFFSET (0x48)
#define ACAMERA_ISP_TOP_AEXP_HIST_DISABLE_MASK (0x1000)

// args: data (1-bit)
static __inline void acamera_isp_top_aexp_hist_disable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ed0L);
    system_sw_write_32(base + 0x18ed0L, (((uint32_t) (data & 0x1)) << 12) | (curr & 0xffffefff));
}
static __inline uint8_t acamera_isp_top_aexp_hist_disable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ed0L) & 0x1000) >> 12);
}
// ------------------------------------------------------------------------------ //
// Register: AEXP Histogram switch
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// AE global histogram tap in the pipeline.  Location of statistics gathering for 1024 bin global histogram
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_AEXP_HISTOGRAM_SWITCH_DEFAULT (0)
#define ACAMERA_ISP_TOP_AEXP_HISTOGRAM_SWITCH_DATASIZE (2)
#define ACAMERA_ISP_TOP_AEXP_HISTOGRAM_SWITCH_OFFSET (0x48)
#define ACAMERA_ISP_TOP_AEXP_HISTOGRAM_SWITCH_MASK (0x6000)
#define ACAMERA_ISP_TOP_AEXP_HISTOGRAM_SWITCH_AFTER_STATIC_WHITE_BALANCE_WHOSE_POSITION_IS_SELECTED_BY_AEXP_SRC_SIGNAL (0)
#define ACAMERA_ISP_TOP_AEXP_HISTOGRAM_SWITCH_AFTER_WDR_FRAME_STITCH_IF_ITS_SENSOR_COMPANDED_DATA_THEN_USE_DECOMPANDED_OUTPUT_IF_ITS_SENSOR_LINEARISED_DATA_THEN_USE_IT_DIRECTLY (1)
#define ACAMERA_ISP_TOP_AEXP_HISTOGRAM_SWITCH_AFTER_VTPG (2)
#define ACAMERA_ISP_TOP_AEXP_HISTOGRAM_SWITCH_RESERVED (3)

// args: data (2-bit)
static __inline void acamera_isp_top_aexp_histogram_switch_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ed0L);
    system_sw_write_32(base + 0x18ed0L, (((uint32_t) (data & 0x3)) << 13) | (curr & 0xffff9fff));
}
static __inline uint8_t acamera_isp_top_aexp_histogram_switch_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ed0L) & 0x6000) >> 13);
}
// ------------------------------------------------------------------------------ //
// Register: iHist disable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Post iridix histogram enable.  Enables statistics gathering for global histogram
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_IHIST_DISABLE_DEFAULT (1)
#define ACAMERA_ISP_TOP_IHIST_DISABLE_DATASIZE (1)
#define ACAMERA_ISP_TOP_IHIST_DISABLE_OFFSET (0x48)
#define ACAMERA_ISP_TOP_IHIST_DISABLE_MASK (0x10000)
#define ACAMERA_ISP_TOP_IHIST_DISABLE_ENABLED (0)
#define ACAMERA_ISP_TOP_IHIST_DISABLE_DISABLED (1)

// args: data (1-bit)
static __inline void acamera_isp_top_ihist_disable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ed0L);
    system_sw_write_32(base + 0x18ed0L, (((uint32_t) (data & 0x1)) << 16) | (curr & 0xfffeffff));
}
static __inline uint8_t acamera_isp_top_ihist_disable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ed0L) & 0x10000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Lumavar Disable
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_LUMAVAR_DISABLE_DEFAULT (0)
#define ACAMERA_ISP_TOP_LUMAVAR_DISABLE_DATASIZE (1)
#define ACAMERA_ISP_TOP_LUMAVAR_DISABLE_OFFSET (0x48)
#define ACAMERA_ISP_TOP_LUMAVAR_DISABLE_MASK (0x40000)
#define ACAMERA_ISP_TOP_LUMAVAR_DISABLE_ENABLED (0)
#define ACAMERA_ISP_TOP_LUMAVAR_DISABLE_DISABLED (1)

// args: data (1-bit)
static __inline void acamera_isp_top_lumavar_disable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ed0L);
    system_sw_write_32(base + 0x18ed0L, (((uint32_t) (data & 0x1)) << 18) | (curr & 0xfffbffff));
}
static __inline uint8_t acamera_isp_top_lumavar_disable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ed0L) & 0x40000) >> 18);
}
// ------------------------------------------------------------------------------ //
// Register: Lumavar switch
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Luma variance tap in the pipeline. 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_LUMAVAR_SWITCH_DEFAULT (0)
#define ACAMERA_ISP_TOP_LUMAVAR_SWITCH_DATASIZE (1)
#define ACAMERA_ISP_TOP_LUMAVAR_SWITCH_OFFSET (0x48)
#define ACAMERA_ISP_TOP_LUMAVAR_SWITCH_MASK (0x80000)
#define ACAMERA_ISP_TOP_LUMAVAR_SWITCH_FULL_RESOLUTION_PIPELINE (0)
#define ACAMERA_ISP_TOP_LUMAVAR_SWITCH_DOWNSCALED_PIPELINE (1)

// args: data (1-bit)
static __inline void acamera_isp_top_lumavar_switch_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ed0L);
    system_sw_write_32(base + 0x18ed0L, (((uint32_t) (data & 0x1)) << 19) | (curr & 0xfff7ffff));
}
static __inline uint8_t acamera_isp_top_lumavar_switch_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ed0L) & 0x80000) >> 19);
}
// ------------------------------------------------------------------------------ //
// Register: aexp_src
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TOP_AEXP_SRC_DEFAULT (0)
#define ACAMERA_ISP_TOP_AEXP_SRC_DATASIZE (1)
#define ACAMERA_ISP_TOP_AEXP_SRC_OFFSET (0x48)
#define ACAMERA_ISP_TOP_AEXP_SRC_MASK (0x1000000)
#define ACAMERA_ISP_TOP_AEXP_SRC_AFTER_STATIC_WHITE_BALANCE_WHEN_APPLIED_BEFORE_SHADING (0)
#define ACAMERA_ISP_TOP_AEXP_SRC_AFTER_STATIC_WHITE_BALANCE_WHEN_APPLIED_AFTER_SHADING (1)

// args: data (1-bit)
static __inline void acamera_isp_top_aexp_src_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ed0L);
    system_sw_write_32(base + 0x18ed0L, (((uint32_t) (data & 0x1)) << 24) | (curr & 0xfeffffff));
}
static __inline uint8_t acamera_isp_top_aexp_src_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ed0L) & 0x1000000) >> 24);
}
// ------------------------------------------------------------------------------ //
// Group: crossbar
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: channel1_select
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// channel0 selection from the input 4 channels
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CROSSBAR_CHANNEL1_SELECT_DEFAULT (0x0)
#define ACAMERA_ISP_CROSSBAR_CHANNEL1_SELECT_DATASIZE (2)
#define ACAMERA_ISP_CROSSBAR_CHANNEL1_SELECT_OFFSET (0x4c)
#define ACAMERA_ISP_CROSSBAR_CHANNEL1_SELECT_MASK (0x3)

// args: data (2-bit)
static __inline void acamera_isp_crossbar_channel1_select_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ed4L);
    system_sw_write_32(base + 0x18ed4L, (((uint32_t) (data & 0x3)) << 0) | (curr & 0xfffffffc));
}
static __inline uint8_t acamera_isp_crossbar_channel1_select_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ed4L) & 0x3) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: channel2_select
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// channel1 selection from the input 4 channels
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CROSSBAR_CHANNEL2_SELECT_DEFAULT (0x1)
#define ACAMERA_ISP_CROSSBAR_CHANNEL2_SELECT_DATASIZE (2)
#define ACAMERA_ISP_CROSSBAR_CHANNEL2_SELECT_OFFSET (0x4c)
#define ACAMERA_ISP_CROSSBAR_CHANNEL2_SELECT_MASK (0x300)

// args: data (2-bit)
static __inline void acamera_isp_crossbar_channel2_select_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ed4L);
    system_sw_write_32(base + 0x18ed4L, (((uint32_t) (data & 0x3)) << 8) | (curr & 0xfffffcff));
}
static __inline uint8_t acamera_isp_crossbar_channel2_select_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ed4L) & 0x300) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: channel3_select
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// channel2 selection from the input 4 channels
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CROSSBAR_CHANNEL3_SELECT_DEFAULT (0x2)
#define ACAMERA_ISP_CROSSBAR_CHANNEL3_SELECT_DATASIZE (2)
#define ACAMERA_ISP_CROSSBAR_CHANNEL3_SELECT_OFFSET (0x4c)
#define ACAMERA_ISP_CROSSBAR_CHANNEL3_SELECT_MASK (0x30000)

// args: data (2-bit)
static __inline void acamera_isp_crossbar_channel3_select_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ed4L);
    system_sw_write_32(base + 0x18ed4L, (((uint32_t) (data & 0x3)) << 16) | (curr & 0xfffcffff));
}
static __inline uint8_t acamera_isp_crossbar_channel3_select_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ed4L) & 0x30000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: channel4_select
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// channel4 selection from the input 4 channels
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CROSSBAR_CHANNEL4_SELECT_DEFAULT (0x3)
#define ACAMERA_ISP_CROSSBAR_CHANNEL4_SELECT_DATASIZE (2)
#define ACAMERA_ISP_CROSSBAR_CHANNEL4_SELECT_OFFSET (0x4c)
#define ACAMERA_ISP_CROSSBAR_CHANNEL4_SELECT_MASK (0x3000000)

// args: data (2-bit)
static __inline void acamera_isp_crossbar_channel4_select_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ed4L);
    system_sw_write_32(base + 0x18ed4L, (((uint32_t) (data & 0x3)) << 24) | (curr & 0xfcffffff));
}
static __inline uint8_t acamera_isp_crossbar_channel4_select_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ed4L) & 0x3000000) >> 24);
}
// ------------------------------------------------------------------------------ //
// Group: video test gen ch0
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Video test generator controls.  See ISP Guide for further details
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: test_pattern_off on
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Test pattern off-on: 0=off, 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_TEST_PATTERN_OFF_ON_DEFAULT (0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_TEST_PATTERN_OFF_ON_DATASIZE (1)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_TEST_PATTERN_OFF_ON_OFFSET (0x50)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_TEST_PATTERN_OFF_ON_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_video_test_gen_ch0_test_pattern_off_on_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ed8L);
    system_sw_write_32(base + 0x18ed8L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_video_test_gen_ch0_test_pattern_off_on_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ed8L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: bayer_rgb_i sel
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bayer or rgb select for input video: 0=bayer, 1=rgb
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_BAYER_RGB_I_SEL_DEFAULT (0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_BAYER_RGB_I_SEL_DATASIZE (1)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_BAYER_RGB_I_SEL_OFFSET (0x50)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_BAYER_RGB_I_SEL_MASK (0x2)

// args: data (1-bit)
static __inline void acamera_isp_video_test_gen_ch0_bayer_rgb_i_sel_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ed8L);
    system_sw_write_32(base + 0x18ed8L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
}
static __inline uint8_t acamera_isp_video_test_gen_ch0_bayer_rgb_i_sel_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ed8L) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: bayer_rgb_o sel
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bayer or rgb select for output video: 0=bayer, 1=rgb
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_BAYER_RGB_O_SEL_DEFAULT (0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_BAYER_RGB_O_SEL_DATASIZE (1)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_BAYER_RGB_O_SEL_OFFSET (0x50)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_BAYER_RGB_O_SEL_MASK (0x4)

// args: data (1-bit)
static __inline void acamera_isp_video_test_gen_ch0_bayer_rgb_o_sel_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ed8L);
    system_sw_write_32(base + 0x18ed8L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
}
static __inline uint8_t acamera_isp_video_test_gen_ch0_bayer_rgb_o_sel_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ed8L) & 0x4) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: Generate mode
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0 = One Shot (on request) generation. 1 = free run (continuous) generation
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_GENERATE_MODE_DEFAULT (0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_GENERATE_MODE_DATASIZE (1)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_GENERATE_MODE_OFFSET (0x50)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_GENERATE_MODE_MASK (0x8)

// args: data (1-bit)
static __inline void acamera_isp_video_test_gen_ch0_generate_mode_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ed8L);
    system_sw_write_32(base + 0x18ed8L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
}
static __inline uint8_t acamera_isp_video_test_gen_ch0_generate_mode_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ed8L) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: Video source
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0 = Video in interface 1 = Internal Video generation
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_VIDEO_SOURCE_DEFAULT (0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_VIDEO_SOURCE_DATASIZE (1)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_VIDEO_SOURCE_OFFSET (0x50)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_VIDEO_SOURCE_MASK (0x10)

// args: data (1-bit)
static __inline void acamera_isp_video_test_gen_ch0_video_source_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ed8L);
    system_sw_write_32(base + 0x18ed8L, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
}
static __inline uint8_t acamera_isp_video_test_gen_ch0_video_source_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18ed8L) & 0x10) >> 4);
}
// ------------------------------------------------------------------------------ //
// Register: pattern type
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Pattern type select: 0=Flat field,1=Horizontal gradient,2=Vertical Gradient,3=Vertical Bars,4=Rectangle,5-255=Default white frame on black
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_PATTERN_TYPE_DEFAULT (0x03)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_PATTERN_TYPE_DATASIZE (8)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_PATTERN_TYPE_OFFSET (0x54)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_PATTERN_TYPE_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_video_test_gen_ch0_pattern_type_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18edcL);
    system_sw_write_32(base + 0x18edcL, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_video_test_gen_ch0_pattern_type_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18edcL) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: r backgnd
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Red background  value 16bit, MSB aligned to used width 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_R_BACKGND_DEFAULT (0xFFFF)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_R_BACKGND_DATASIZE (20)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_R_BACKGND_OFFSET (0x58)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_R_BACKGND_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_video_test_gen_ch0_r_backgnd_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ee0L);
    system_sw_write_32(base + 0x18ee0L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_video_test_gen_ch0_r_backgnd_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18ee0L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: g backgnd
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Green background value 16bit, MSB aligned to used width
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_G_BACKGND_DEFAULT (0xFFFF)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_G_BACKGND_DATASIZE (20)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_G_BACKGND_OFFSET (0x5c)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_G_BACKGND_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_video_test_gen_ch0_g_backgnd_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ee4L);
    system_sw_write_32(base + 0x18ee4L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_video_test_gen_ch0_g_backgnd_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18ee4L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: b backgnd
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Blue background value 16bit, MSB aligned to used width
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_B_BACKGND_DEFAULT (0xFFFF)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_B_BACKGND_DATASIZE (20)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_B_BACKGND_OFFSET (0x60)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_B_BACKGND_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_video_test_gen_ch0_b_backgnd_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ee8L);
    system_sw_write_32(base + 0x18ee8L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_video_test_gen_ch0_b_backgnd_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18ee8L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: r foregnd
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Red foreground  value 16bit, MSB aligned to used width 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_R_FOREGND_DEFAULT (0x8FFF)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_R_FOREGND_DATASIZE (20)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_R_FOREGND_OFFSET (0x64)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_R_FOREGND_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_video_test_gen_ch0_r_foregnd_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18eecL);
    system_sw_write_32(base + 0x18eecL, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_video_test_gen_ch0_r_foregnd_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18eecL) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: g foregnd
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Green foreground value 16bit, MSB aligned to used width
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_G_FOREGND_DEFAULT (0x8FFF)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_G_FOREGND_DATASIZE (20)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_G_FOREGND_OFFSET (0x68)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_G_FOREGND_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_video_test_gen_ch0_g_foregnd_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ef0L);
    system_sw_write_32(base + 0x18ef0L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_video_test_gen_ch0_g_foregnd_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18ef0L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: b foregnd
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Blue foreground value 16bit, MSB aligned to used width
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_B_FOREGND_DEFAULT (0x8FFF)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_B_FOREGND_DATASIZE (20)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_B_FOREGND_OFFSET (0x6c)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_B_FOREGND_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_video_test_gen_ch0_b_foregnd_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ef4L);
    system_sw_write_32(base + 0x18ef4L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_video_test_gen_ch0_b_foregnd_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18ef4L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: rgb gradient
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// RGB gradient increment per pixel (0-15) for first channel
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_RGB_GRADIENT_DEFAULT (0x3CAA)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_RGB_GRADIENT_DATASIZE (16)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_RGB_GRADIENT_OFFSET (0x70)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_RGB_GRADIENT_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_video_test_gen_ch0_rgb_gradient_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ef8L);
    system_sw_write_32(base + 0x18ef8L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_video_test_gen_ch0_rgb_gradient_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18ef8L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: rgb_gradient start
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// RGB gradient start value for first channel 16bit, MSB aligned to used width
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_RGB_GRADIENT_START_DEFAULT (0x0000)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_RGB_GRADIENT_START_DATASIZE (20)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_RGB_GRADIENT_START_OFFSET (0x74)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_RGB_GRADIENT_START_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_video_test_gen_ch0_rgb_gradient_start_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18efcL);
    system_sw_write_32(base + 0x18efcL, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_video_test_gen_ch0_rgb_gradient_start_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18efcL) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: rect top
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Rectangle top line number 1-n
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_RECT_TOP_DEFAULT (0x0001)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_RECT_TOP_DATASIZE (14)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_RECT_TOP_OFFSET (0x78)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_RECT_TOP_MASK (0x3fff)

// args: data (14-bit)
static __inline void acamera_isp_video_test_gen_ch0_rect_top_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f00L);
    system_sw_write_32(base + 0x18f00L, (((uint32_t) (data & 0x3fff)) << 0) | (curr & 0xffffc000));
}
static __inline uint16_t acamera_isp_video_test_gen_ch0_rect_top_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18f00L) & 0x3fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: rect bot
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Rectangle bottom line number 1-n
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_RECT_BOT_DEFAULT (0x0100)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_RECT_BOT_DATASIZE (14)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_RECT_BOT_OFFSET (0x78)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_RECT_BOT_MASK (0x3fff0000)

// args: data (14-bit)
static __inline void acamera_isp_video_test_gen_ch0_rect_bot_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f00L);
    system_sw_write_32(base + 0x18f00L, (((uint32_t) (data & 0x3fff)) << 16) | (curr & 0xc000ffff));
}
static __inline uint16_t acamera_isp_video_test_gen_ch0_rect_bot_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18f00L) & 0x3fff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: rect left
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Rectangle left pixel number 1-n
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_RECT_LEFT_DEFAULT (0x0001)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_RECT_LEFT_DATASIZE (14)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_RECT_LEFT_OFFSET (0x7c)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_RECT_LEFT_MASK (0x3fff)

// args: data (14-bit)
static __inline void acamera_isp_video_test_gen_ch0_rect_left_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f04L);
    system_sw_write_32(base + 0x18f04L, (((uint32_t) (data & 0x3fff)) << 0) | (curr & 0xffffc000));
}
static __inline uint16_t acamera_isp_video_test_gen_ch0_rect_left_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18f04L) & 0x3fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: rect right
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Rectangle right pixel number 1-n
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_RECT_RIGHT_DEFAULT (0x0100)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_RECT_RIGHT_DATASIZE (14)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_RECT_RIGHT_OFFSET (0x7c)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH0_RECT_RIGHT_MASK (0x3fff0000)

// args: data (14-bit)
static __inline void acamera_isp_video_test_gen_ch0_rect_right_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f04L);
    system_sw_write_32(base + 0x18f04L, (((uint32_t) (data & 0x3fff)) << 16) | (curr & 0xc000ffff));
}
static __inline uint16_t acamera_isp_video_test_gen_ch0_rect_right_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18f04L) & 0x3fff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Group: video test gen ch1
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Video test generator controls.  See ISP Guide for further details
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: test_pattern_off on
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Test pattern off-on: 0=off, 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_TEST_PATTERN_OFF_ON_DEFAULT (0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_TEST_PATTERN_OFF_ON_DATASIZE (1)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_TEST_PATTERN_OFF_ON_OFFSET (0x80)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_TEST_PATTERN_OFF_ON_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_video_test_gen_ch1_test_pattern_off_on_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f08L);
    system_sw_write_32(base + 0x18f08L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_video_test_gen_ch1_test_pattern_off_on_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18f08L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: bayer_rgb_i sel
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bayer or rgb select for input video: 0=bayer, 1=rgb
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_BAYER_RGB_I_SEL_DEFAULT (0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_BAYER_RGB_I_SEL_DATASIZE (1)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_BAYER_RGB_I_SEL_OFFSET (0x80)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_BAYER_RGB_I_SEL_MASK (0x2)

// args: data (1-bit)
static __inline void acamera_isp_video_test_gen_ch1_bayer_rgb_i_sel_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f08L);
    system_sw_write_32(base + 0x18f08L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
}
static __inline uint8_t acamera_isp_video_test_gen_ch1_bayer_rgb_i_sel_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18f08L) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: bayer_rgb_o sel
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bayer or rgb select for output video: 0=bayer, 1=rgb
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_BAYER_RGB_O_SEL_DEFAULT (0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_BAYER_RGB_O_SEL_DATASIZE (1)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_BAYER_RGB_O_SEL_OFFSET (0x80)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_BAYER_RGB_O_SEL_MASK (0x4)

// args: data (1-bit)
static __inline void acamera_isp_video_test_gen_ch1_bayer_rgb_o_sel_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f08L);
    system_sw_write_32(base + 0x18f08L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
}
static __inline uint8_t acamera_isp_video_test_gen_ch1_bayer_rgb_o_sel_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18f08L) & 0x4) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: Generate mode
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0 = One Shot (on request) generation. 1 = free run (continuous) generation
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_GENERATE_MODE_DEFAULT (0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_GENERATE_MODE_DATASIZE (1)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_GENERATE_MODE_OFFSET (0x80)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_GENERATE_MODE_MASK (0x8)

// args: data (1-bit)
static __inline void acamera_isp_video_test_gen_ch1_generate_mode_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f08L);
    system_sw_write_32(base + 0x18f08L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
}
static __inline uint8_t acamera_isp_video_test_gen_ch1_generate_mode_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18f08L) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: Video source
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0 = Video in interface 1 = Internal Video generation
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_VIDEO_SOURCE_DEFAULT (0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_VIDEO_SOURCE_DATASIZE (1)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_VIDEO_SOURCE_OFFSET (0x80)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_VIDEO_SOURCE_MASK (0x10)

// args: data (1-bit)
static __inline void acamera_isp_video_test_gen_ch1_video_source_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f08L);
    system_sw_write_32(base + 0x18f08L, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
}
static __inline uint8_t acamera_isp_video_test_gen_ch1_video_source_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18f08L) & 0x10) >> 4);
}
// ------------------------------------------------------------------------------ //
// Register: pattern type
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Pattern type select: 0=Flat field,1=Horizontal gradient,2=Vertical Gradient,3=Vertical Bars,4=Rectangle,5-255=Default white frame on black
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_PATTERN_TYPE_DEFAULT (0x03)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_PATTERN_TYPE_DATASIZE (8)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_PATTERN_TYPE_OFFSET (0x84)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_PATTERN_TYPE_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_video_test_gen_ch1_pattern_type_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f0cL);
    system_sw_write_32(base + 0x18f0cL, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_video_test_gen_ch1_pattern_type_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18f0cL) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: r backgnd
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Red background  value 16bit, MSB aligned to used width 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_R_BACKGND_DEFAULT (0xFFFF)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_R_BACKGND_DATASIZE (20)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_R_BACKGND_OFFSET (0x88)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_R_BACKGND_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_video_test_gen_ch1_r_backgnd_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f10L);
    system_sw_write_32(base + 0x18f10L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_video_test_gen_ch1_r_backgnd_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18f10L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: g backgnd
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Green background value 16bit, MSB aligned to used width
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_G_BACKGND_DEFAULT (0xFFFF)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_G_BACKGND_DATASIZE (20)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_G_BACKGND_OFFSET (0x8c)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_G_BACKGND_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_video_test_gen_ch1_g_backgnd_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f14L);
    system_sw_write_32(base + 0x18f14L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_video_test_gen_ch1_g_backgnd_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18f14L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: b backgnd
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Blue background value 16bit, MSB aligned to used width
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_B_BACKGND_DEFAULT (0xFFFF)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_B_BACKGND_DATASIZE (20)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_B_BACKGND_OFFSET (0x90)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_B_BACKGND_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_video_test_gen_ch1_b_backgnd_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f18L);
    system_sw_write_32(base + 0x18f18L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_video_test_gen_ch1_b_backgnd_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18f18L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: r foregnd
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Red foreground  value 16bit, MSB aligned to used width 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_R_FOREGND_DEFAULT (0x8FFF)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_R_FOREGND_DATASIZE (20)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_R_FOREGND_OFFSET (0x94)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_R_FOREGND_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_video_test_gen_ch1_r_foregnd_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f1cL);
    system_sw_write_32(base + 0x18f1cL, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_video_test_gen_ch1_r_foregnd_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18f1cL) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: g foregnd
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Green foreground value 16bit, MSB aligned to used width
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_G_FOREGND_DEFAULT (0x8FFF)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_G_FOREGND_DATASIZE (20)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_G_FOREGND_OFFSET (0x98)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_G_FOREGND_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_video_test_gen_ch1_g_foregnd_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f20L);
    system_sw_write_32(base + 0x18f20L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_video_test_gen_ch1_g_foregnd_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18f20L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: b foregnd
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Blue foreground value 16bit, MSB aligned to used width
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_B_FOREGND_DEFAULT (0x8FFF)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_B_FOREGND_DATASIZE (20)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_B_FOREGND_OFFSET (0x9c)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_B_FOREGND_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_video_test_gen_ch1_b_foregnd_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f24L);
    system_sw_write_32(base + 0x18f24L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_video_test_gen_ch1_b_foregnd_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18f24L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: rgb gradient
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// RGB gradient increment per pixel (0-15) for first channel
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_RGB_GRADIENT_DEFAULT (0x3CAA)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_RGB_GRADIENT_DATASIZE (16)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_RGB_GRADIENT_OFFSET (0xa0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_RGB_GRADIENT_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_video_test_gen_ch1_rgb_gradient_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f28L);
    system_sw_write_32(base + 0x18f28L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_video_test_gen_ch1_rgb_gradient_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18f28L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: rgb_gradient start
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// RGB gradient start value for first channel 16bit, MSB aligned to used width
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_RGB_GRADIENT_START_DEFAULT (0x0000)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_RGB_GRADIENT_START_DATASIZE (20)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_RGB_GRADIENT_START_OFFSET (0xa4)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_RGB_GRADIENT_START_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_video_test_gen_ch1_rgb_gradient_start_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f2cL);
    system_sw_write_32(base + 0x18f2cL, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_video_test_gen_ch1_rgb_gradient_start_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18f2cL) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: rect top
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Rectangle top line number 1-n
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_RECT_TOP_DEFAULT (0x0001)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_RECT_TOP_DATASIZE (14)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_RECT_TOP_OFFSET (0xa8)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_RECT_TOP_MASK (0x3fff)

// args: data (14-bit)
static __inline void acamera_isp_video_test_gen_ch1_rect_top_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f30L);
    system_sw_write_32(base + 0x18f30L, (((uint32_t) (data & 0x3fff)) << 0) | (curr & 0xffffc000));
}
static __inline uint16_t acamera_isp_video_test_gen_ch1_rect_top_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18f30L) & 0x3fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: rect bot
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Rectangle bottom line number 1-n
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_RECT_BOT_DEFAULT (0x0100)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_RECT_BOT_DATASIZE (14)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_RECT_BOT_OFFSET (0xa8)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_RECT_BOT_MASK (0x3fff0000)

// args: data (14-bit)
static __inline void acamera_isp_video_test_gen_ch1_rect_bot_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f30L);
    system_sw_write_32(base + 0x18f30L, (((uint32_t) (data & 0x3fff)) << 16) | (curr & 0xc000ffff));
}
static __inline uint16_t acamera_isp_video_test_gen_ch1_rect_bot_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18f30L) & 0x3fff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: rect left
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Rectangle left pixel number 1-n
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_RECT_LEFT_DEFAULT (0x0001)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_RECT_LEFT_DATASIZE (14)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_RECT_LEFT_OFFSET (0xac)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_RECT_LEFT_MASK (0x3fff)

// args: data (14-bit)
static __inline void acamera_isp_video_test_gen_ch1_rect_left_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f34L);
    system_sw_write_32(base + 0x18f34L, (((uint32_t) (data & 0x3fff)) << 0) | (curr & 0xffffc000));
}
static __inline uint16_t acamera_isp_video_test_gen_ch1_rect_left_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18f34L) & 0x3fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: rect right
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Rectangle right pixel number 1-n
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_RECT_RIGHT_DEFAULT (0x0100)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_RECT_RIGHT_DATASIZE (14)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_RECT_RIGHT_OFFSET (0xac)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH1_RECT_RIGHT_MASK (0x3fff0000)

// args: data (14-bit)
static __inline void acamera_isp_video_test_gen_ch1_rect_right_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f34L);
    system_sw_write_32(base + 0x18f34L, (((uint32_t) (data & 0x3fff)) << 16) | (curr & 0xc000ffff));
}
static __inline uint16_t acamera_isp_video_test_gen_ch1_rect_right_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18f34L) & 0x3fff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Group: video test gen ch2
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Video test generator controls.  See ISP Guide for further details
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: test_pattern_off on
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Test pattern off-on: 0=off, 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_TEST_PATTERN_OFF_ON_DEFAULT (0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_TEST_PATTERN_OFF_ON_DATASIZE (1)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_TEST_PATTERN_OFF_ON_OFFSET (0xb0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_TEST_PATTERN_OFF_ON_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_video_test_gen_ch2_test_pattern_off_on_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f38L);
    system_sw_write_32(base + 0x18f38L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_video_test_gen_ch2_test_pattern_off_on_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18f38L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: bayer_rgb_i sel
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bayer or rgb select for input video: 0=bayer, 1=rgb
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_BAYER_RGB_I_SEL_DEFAULT (0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_BAYER_RGB_I_SEL_DATASIZE (1)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_BAYER_RGB_I_SEL_OFFSET (0xb0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_BAYER_RGB_I_SEL_MASK (0x2)

// args: data (1-bit)
static __inline void acamera_isp_video_test_gen_ch2_bayer_rgb_i_sel_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f38L);
    system_sw_write_32(base + 0x18f38L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
}
static __inline uint8_t acamera_isp_video_test_gen_ch2_bayer_rgb_i_sel_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18f38L) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: bayer_rgb_o sel
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bayer or rgb select for output video: 0=bayer, 1=rgb
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_BAYER_RGB_O_SEL_DEFAULT (0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_BAYER_RGB_O_SEL_DATASIZE (1)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_BAYER_RGB_O_SEL_OFFSET (0xb0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_BAYER_RGB_O_SEL_MASK (0x4)

// args: data (1-bit)
static __inline void acamera_isp_video_test_gen_ch2_bayer_rgb_o_sel_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f38L);
    system_sw_write_32(base + 0x18f38L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
}
static __inline uint8_t acamera_isp_video_test_gen_ch2_bayer_rgb_o_sel_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18f38L) & 0x4) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: Generate mode
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0 = One Shot (on request) generation. 1 = free run (continuous) generation
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_GENERATE_MODE_DEFAULT (0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_GENERATE_MODE_DATASIZE (1)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_GENERATE_MODE_OFFSET (0xb0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_GENERATE_MODE_MASK (0x8)

// args: data (1-bit)
static __inline void acamera_isp_video_test_gen_ch2_generate_mode_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f38L);
    system_sw_write_32(base + 0x18f38L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
}
static __inline uint8_t acamera_isp_video_test_gen_ch2_generate_mode_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18f38L) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: Video source
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0 = Video in interface 1 = Internal Video generation
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_VIDEO_SOURCE_DEFAULT (0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_VIDEO_SOURCE_DATASIZE (1)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_VIDEO_SOURCE_OFFSET (0xb0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_VIDEO_SOURCE_MASK (0x10)

// args: data (1-bit)
static __inline void acamera_isp_video_test_gen_ch2_video_source_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f38L);
    system_sw_write_32(base + 0x18f38L, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
}
static __inline uint8_t acamera_isp_video_test_gen_ch2_video_source_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18f38L) & 0x10) >> 4);
}
// ------------------------------------------------------------------------------ //
// Register: pattern type
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Pattern type select: 0=Flat field,1=Horizontal gradient,2=Vertical Gradient,3=Vertical Bars,4=Rectangle,5-255=Default white frame on black
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_PATTERN_TYPE_DEFAULT (0x03)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_PATTERN_TYPE_DATASIZE (8)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_PATTERN_TYPE_OFFSET (0xb4)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_PATTERN_TYPE_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_video_test_gen_ch2_pattern_type_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f3cL);
    system_sw_write_32(base + 0x18f3cL, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_video_test_gen_ch2_pattern_type_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18f3cL) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: r backgnd
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Red background  value 16bit, MSB aligned to used width 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_R_BACKGND_DEFAULT (0xFFFF)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_R_BACKGND_DATASIZE (20)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_R_BACKGND_OFFSET (0xb8)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_R_BACKGND_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_video_test_gen_ch2_r_backgnd_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f40L);
    system_sw_write_32(base + 0x18f40L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_video_test_gen_ch2_r_backgnd_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18f40L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: g backgnd
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Green background value 16bit, MSB aligned to used width
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_G_BACKGND_DEFAULT (0xFFFF)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_G_BACKGND_DATASIZE (20)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_G_BACKGND_OFFSET (0xbc)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_G_BACKGND_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_video_test_gen_ch2_g_backgnd_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f44L);
    system_sw_write_32(base + 0x18f44L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_video_test_gen_ch2_g_backgnd_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18f44L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: b backgnd
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Blue background value 16bit, MSB aligned to used width
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_B_BACKGND_DEFAULT (0xFFFF)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_B_BACKGND_DATASIZE (20)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_B_BACKGND_OFFSET (0xc0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_B_BACKGND_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_video_test_gen_ch2_b_backgnd_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f48L);
    system_sw_write_32(base + 0x18f48L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_video_test_gen_ch2_b_backgnd_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18f48L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: r foregnd
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Red foreground  value 16bit, MSB aligned to used width 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_R_FOREGND_DEFAULT (0x8FFF)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_R_FOREGND_DATASIZE (20)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_R_FOREGND_OFFSET (0xc4)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_R_FOREGND_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_video_test_gen_ch2_r_foregnd_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f4cL);
    system_sw_write_32(base + 0x18f4cL, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_video_test_gen_ch2_r_foregnd_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18f4cL) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: g foregnd
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Green foreground value 16bit, MSB aligned to used width
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_G_FOREGND_DEFAULT (0x8FFF)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_G_FOREGND_DATASIZE (20)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_G_FOREGND_OFFSET (0xc8)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_G_FOREGND_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_video_test_gen_ch2_g_foregnd_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f50L);
    system_sw_write_32(base + 0x18f50L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_video_test_gen_ch2_g_foregnd_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18f50L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: b foregnd
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Blue foreground value 16bit, MSB aligned to used width
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_B_FOREGND_DEFAULT (0x8FFF)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_B_FOREGND_DATASIZE (20)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_B_FOREGND_OFFSET (0xcc)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_B_FOREGND_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_video_test_gen_ch2_b_foregnd_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f54L);
    system_sw_write_32(base + 0x18f54L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_video_test_gen_ch2_b_foregnd_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18f54L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: rgb gradient
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// RGB gradient increment per pixel (0-15) for first channel
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_RGB_GRADIENT_DEFAULT (0x3CAA)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_RGB_GRADIENT_DATASIZE (16)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_RGB_GRADIENT_OFFSET (0xd0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_RGB_GRADIENT_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_video_test_gen_ch2_rgb_gradient_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f58L);
    system_sw_write_32(base + 0x18f58L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_video_test_gen_ch2_rgb_gradient_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18f58L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: rgb_gradient start
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// RGB gradient start value for first channel 16bit, MSB aligned to used width
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_RGB_GRADIENT_START_DEFAULT (0x0000)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_RGB_GRADIENT_START_DATASIZE (20)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_RGB_GRADIENT_START_OFFSET (0xd4)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_RGB_GRADIENT_START_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_video_test_gen_ch2_rgb_gradient_start_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f5cL);
    system_sw_write_32(base + 0x18f5cL, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_video_test_gen_ch2_rgb_gradient_start_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18f5cL) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: rect top
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Rectangle top line number 1-n
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_RECT_TOP_DEFAULT (0x0001)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_RECT_TOP_DATASIZE (14)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_RECT_TOP_OFFSET (0xd8)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_RECT_TOP_MASK (0x3fff)

// args: data (14-bit)
static __inline void acamera_isp_video_test_gen_ch2_rect_top_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f60L);
    system_sw_write_32(base + 0x18f60L, (((uint32_t) (data & 0x3fff)) << 0) | (curr & 0xffffc000));
}
static __inline uint16_t acamera_isp_video_test_gen_ch2_rect_top_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18f60L) & 0x3fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: rect bot
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Rectangle bottom line number 1-n
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_RECT_BOT_DEFAULT (0x0100)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_RECT_BOT_DATASIZE (14)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_RECT_BOT_OFFSET (0xd8)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_RECT_BOT_MASK (0x3fff0000)

// args: data (14-bit)
static __inline void acamera_isp_video_test_gen_ch2_rect_bot_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f60L);
    system_sw_write_32(base + 0x18f60L, (((uint32_t) (data & 0x3fff)) << 16) | (curr & 0xc000ffff));
}
static __inline uint16_t acamera_isp_video_test_gen_ch2_rect_bot_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18f60L) & 0x3fff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: rect left
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Rectangle left pixel number 1-n
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_RECT_LEFT_DEFAULT (0x0001)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_RECT_LEFT_DATASIZE (14)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_RECT_LEFT_OFFSET (0xdc)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_RECT_LEFT_MASK (0x3fff)

// args: data (14-bit)
static __inline void acamera_isp_video_test_gen_ch2_rect_left_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f64L);
    system_sw_write_32(base + 0x18f64L, (((uint32_t) (data & 0x3fff)) << 0) | (curr & 0xffffc000));
}
static __inline uint16_t acamera_isp_video_test_gen_ch2_rect_left_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18f64L) & 0x3fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: rect right
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Rectangle right pixel number 1-n
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_RECT_RIGHT_DEFAULT (0x0100)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_RECT_RIGHT_DATASIZE (14)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_RECT_RIGHT_OFFSET (0xdc)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH2_RECT_RIGHT_MASK (0x3fff0000)

// args: data (14-bit)
static __inline void acamera_isp_video_test_gen_ch2_rect_right_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f64L);
    system_sw_write_32(base + 0x18f64L, (((uint32_t) (data & 0x3fff)) << 16) | (curr & 0xc000ffff));
}
static __inline uint16_t acamera_isp_video_test_gen_ch2_rect_right_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18f64L) & 0x3fff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Group: video test gen ch3
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Video test generator controls.  See ISP Guide for further details
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: test_pattern_off on
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Test pattern off-on: 0=off, 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_TEST_PATTERN_OFF_ON_DEFAULT (0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_TEST_PATTERN_OFF_ON_DATASIZE (1)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_TEST_PATTERN_OFF_ON_OFFSET (0xe0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_TEST_PATTERN_OFF_ON_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_video_test_gen_ch3_test_pattern_off_on_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f68L);
    system_sw_write_32(base + 0x18f68L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_video_test_gen_ch3_test_pattern_off_on_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18f68L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: bayer_rgb_i sel
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bayer or rgb select for input video: 0=bayer, 1=rgb
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_BAYER_RGB_I_SEL_DEFAULT (0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_BAYER_RGB_I_SEL_DATASIZE (1)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_BAYER_RGB_I_SEL_OFFSET (0xe0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_BAYER_RGB_I_SEL_MASK (0x2)

// args: data (1-bit)
static __inline void acamera_isp_video_test_gen_ch3_bayer_rgb_i_sel_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f68L);
    system_sw_write_32(base + 0x18f68L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
}
static __inline uint8_t acamera_isp_video_test_gen_ch3_bayer_rgb_i_sel_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18f68L) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: bayer_rgb_o sel
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bayer or rgb select for output video: 0=bayer, 1=rgb
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_BAYER_RGB_O_SEL_DEFAULT (0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_BAYER_RGB_O_SEL_DATASIZE (1)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_BAYER_RGB_O_SEL_OFFSET (0xe0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_BAYER_RGB_O_SEL_MASK (0x4)

// args: data (1-bit)
static __inline void acamera_isp_video_test_gen_ch3_bayer_rgb_o_sel_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f68L);
    system_sw_write_32(base + 0x18f68L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
}
static __inline uint8_t acamera_isp_video_test_gen_ch3_bayer_rgb_o_sel_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18f68L) & 0x4) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: Generate mode
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0 = One Shot (on request) generation. 1 = free run (continuous) generation
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_GENERATE_MODE_DEFAULT (0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_GENERATE_MODE_DATASIZE (1)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_GENERATE_MODE_OFFSET (0xe0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_GENERATE_MODE_MASK (0x8)

// args: data (1-bit)
static __inline void acamera_isp_video_test_gen_ch3_generate_mode_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f68L);
    system_sw_write_32(base + 0x18f68L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
}
static __inline uint8_t acamera_isp_video_test_gen_ch3_generate_mode_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18f68L) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: Video source
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0 = Video in interface 1 = Internal Video generation
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_VIDEO_SOURCE_DEFAULT (0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_VIDEO_SOURCE_DATASIZE (1)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_VIDEO_SOURCE_OFFSET (0xe0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_VIDEO_SOURCE_MASK (0x10)

// args: data (1-bit)
static __inline void acamera_isp_video_test_gen_ch3_video_source_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f68L);
    system_sw_write_32(base + 0x18f68L, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
}
static __inline uint8_t acamera_isp_video_test_gen_ch3_video_source_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18f68L) & 0x10) >> 4);
}
// ------------------------------------------------------------------------------ //
// Register: pattern type
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Pattern type select: 0=Flat field,1=Horizontal gradient,2=Vertical Gradient,3=Vertical Bars,4=Rectangle,5-255=Default white frame on black
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_PATTERN_TYPE_DEFAULT (0x03)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_PATTERN_TYPE_DATASIZE (8)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_PATTERN_TYPE_OFFSET (0xe4)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_PATTERN_TYPE_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_video_test_gen_ch3_pattern_type_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f6cL);
    system_sw_write_32(base + 0x18f6cL, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_video_test_gen_ch3_pattern_type_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18f6cL) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: r backgnd
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Red background  value 16bit, MSB aligned to used width 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_R_BACKGND_DEFAULT (0xFFFF)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_R_BACKGND_DATASIZE (20)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_R_BACKGND_OFFSET (0xe8)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_R_BACKGND_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_video_test_gen_ch3_r_backgnd_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f70L);
    system_sw_write_32(base + 0x18f70L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_video_test_gen_ch3_r_backgnd_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18f70L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: g backgnd
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Green background value 16bit, MSB aligned to used width
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_G_BACKGND_DEFAULT (0xFFFF)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_G_BACKGND_DATASIZE (20)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_G_BACKGND_OFFSET (0xec)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_G_BACKGND_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_video_test_gen_ch3_g_backgnd_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f74L);
    system_sw_write_32(base + 0x18f74L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_video_test_gen_ch3_g_backgnd_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18f74L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: b backgnd
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Blue background value 16bit, MSB aligned to used width
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_B_BACKGND_DEFAULT (0xFFFF)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_B_BACKGND_DATASIZE (20)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_B_BACKGND_OFFSET (0xf0)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_B_BACKGND_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_video_test_gen_ch3_b_backgnd_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f78L);
    system_sw_write_32(base + 0x18f78L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_video_test_gen_ch3_b_backgnd_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18f78L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: r foregnd
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Red foreground  value 16bit, MSB aligned to used width 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_R_FOREGND_DEFAULT (0x8FFF)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_R_FOREGND_DATASIZE (20)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_R_FOREGND_OFFSET (0xf4)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_R_FOREGND_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_video_test_gen_ch3_r_foregnd_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f7cL);
    system_sw_write_32(base + 0x18f7cL, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_video_test_gen_ch3_r_foregnd_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18f7cL) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: g foregnd
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Green foreground value 16bit, MSB aligned to used width
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_G_FOREGND_DEFAULT (0x8FFF)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_G_FOREGND_DATASIZE (20)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_G_FOREGND_OFFSET (0xf8)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_G_FOREGND_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_video_test_gen_ch3_g_foregnd_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f80L);
    system_sw_write_32(base + 0x18f80L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_video_test_gen_ch3_g_foregnd_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18f80L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: b foregnd
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Blue foreground value 16bit, MSB aligned to used width
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_B_FOREGND_DEFAULT (0x8FFF)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_B_FOREGND_DATASIZE (20)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_B_FOREGND_OFFSET (0xfc)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_B_FOREGND_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_video_test_gen_ch3_b_foregnd_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f84L);
    system_sw_write_32(base + 0x18f84L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_video_test_gen_ch3_b_foregnd_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18f84L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: rgb gradient
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// RGB gradient increment per pixel (0-15) for first channel
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_RGB_GRADIENT_DEFAULT (0x3CAA)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_RGB_GRADIENT_DATASIZE (16)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_RGB_GRADIENT_OFFSET (0x100)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_RGB_GRADIENT_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_video_test_gen_ch3_rgb_gradient_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f88L);
    system_sw_write_32(base + 0x18f88L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_video_test_gen_ch3_rgb_gradient_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18f88L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: rgb_gradient start
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// RGB gradient start value for first channel 16bit, MSB aligned to used width
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_RGB_GRADIENT_START_DEFAULT (0x0000)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_RGB_GRADIENT_START_DATASIZE (20)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_RGB_GRADIENT_START_OFFSET (0x104)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_RGB_GRADIENT_START_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_video_test_gen_ch3_rgb_gradient_start_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f8cL);
    system_sw_write_32(base + 0x18f8cL, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_video_test_gen_ch3_rgb_gradient_start_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18f8cL) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: rect top
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Rectangle top line number 1-n
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_RECT_TOP_DEFAULT (0x0001)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_RECT_TOP_DATASIZE (14)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_RECT_TOP_OFFSET (0x108)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_RECT_TOP_MASK (0x3fff)

// args: data (14-bit)
static __inline void acamera_isp_video_test_gen_ch3_rect_top_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f90L);
    system_sw_write_32(base + 0x18f90L, (((uint32_t) (data & 0x3fff)) << 0) | (curr & 0xffffc000));
}
static __inline uint16_t acamera_isp_video_test_gen_ch3_rect_top_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18f90L) & 0x3fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: rect bot
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Rectangle bottom line number 1-n
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_RECT_BOT_DEFAULT (0x0100)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_RECT_BOT_DATASIZE (14)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_RECT_BOT_OFFSET (0x108)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_RECT_BOT_MASK (0x3fff0000)

// args: data (14-bit)
static __inline void acamera_isp_video_test_gen_ch3_rect_bot_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f90L);
    system_sw_write_32(base + 0x18f90L, (((uint32_t) (data & 0x3fff)) << 16) | (curr & 0xc000ffff));
}
static __inline uint16_t acamera_isp_video_test_gen_ch3_rect_bot_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18f90L) & 0x3fff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: rect left
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Rectangle left pixel number 1-n
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_RECT_LEFT_DEFAULT (0x0001)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_RECT_LEFT_DATASIZE (14)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_RECT_LEFT_OFFSET (0x10c)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_RECT_LEFT_MASK (0x3fff)

// args: data (14-bit)
static __inline void acamera_isp_video_test_gen_ch3_rect_left_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f94L);
    system_sw_write_32(base + 0x18f94L, (((uint32_t) (data & 0x3fff)) << 0) | (curr & 0xffffc000));
}
static __inline uint16_t acamera_isp_video_test_gen_ch3_rect_left_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18f94L) & 0x3fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: rect right
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Rectangle right pixel number 1-n
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_RECT_RIGHT_DEFAULT (0x0100)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_RECT_RIGHT_DATASIZE (14)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_RECT_RIGHT_OFFSET (0x10c)
#define ACAMERA_ISP_VIDEO_TEST_GEN_CH3_RECT_RIGHT_MASK (0x3fff0000)

// args: data (14-bit)
static __inline void acamera_isp_video_test_gen_ch3_rect_right_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f94L);
    system_sw_write_32(base + 0x18f94L, (((uint32_t) (data & 0x3fff)) << 16) | (curr & 0xc000ffff));
}
static __inline uint16_t acamera_isp_video_test_gen_ch3_rect_right_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18f94L) & 0x3fff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Group: input formatter
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Adapts received data format to ISP format see ISP guide for a table of setting to be used for various sensors/modes.
//      
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: mode in
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Input mode 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_INPUT_FORMATTER_MODE_IN_DEFAULT (0)
#define ACAMERA_ISP_INPUT_FORMATTER_MODE_IN_DATASIZE (3)
#define ACAMERA_ISP_INPUT_FORMATTER_MODE_IN_OFFSET (0x110)
#define ACAMERA_ISP_INPUT_FORMATTER_MODE_IN_MASK (0x7)
#define ACAMERA_ISP_INPUT_FORMATTER_MODE_IN_LINEAR_DATA (0)
#define ACAMERA_ISP_INPUT_FORMATTER_MODE_IN_23_MULTIPLE_EXPOSURE_MULTIPLEXING (1)
#define ACAMERA_ISP_INPUT_FORMATTER_MODE_IN_LOGARITHMIC_ENCODING (2)
#define ACAMERA_ISP_INPUT_FORMATTER_MODE_IN_COMPANDING_CURVE_WITH_KNEE_POINTS (3)
#define ACAMERA_ISP_INPUT_FORMATTER_MODE_IN_16BIT_LINEAR_12BIT_VS (4)
#define ACAMERA_ISP_INPUT_FORMATTER_MODE_IN_12BIT_COMPANDED__12BIT_VS (5)
#define ACAMERA_ISP_INPUT_FORMATTER_MODE_IN_RESERVED (6)
#define ACAMERA_ISP_INPUT_FORMATTER_MODE_IN_PASS_THROUGH_MODE (7)

// args: data (3-bit)
static __inline void acamera_isp_input_formatter_mode_in_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f98L);
    system_sw_write_32(base + 0x18f98L, (((uint32_t) (data & 0x7)) << 0) | (curr & 0xfffffff8));
}
static __inline uint8_t acamera_isp_input_formatter_mode_in_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18f98L) & 0x7) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: input bitwidth select
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Input bitwidth select 
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_INPUT_FORMATTER_INPUT_BITWIDTH_SELECT_DEFAULT (2)
#define ACAMERA_ISP_INPUT_FORMATTER_INPUT_BITWIDTH_SELECT_DATASIZE (3)
#define ACAMERA_ISP_INPUT_FORMATTER_INPUT_BITWIDTH_SELECT_OFFSET (0x110)
#define ACAMERA_ISP_INPUT_FORMATTER_INPUT_BITWIDTH_SELECT_MASK (0x70000)
#define ACAMERA_ISP_INPUT_FORMATTER_INPUT_BITWIDTH_SELECT_8_BITS (0)
#define ACAMERA_ISP_INPUT_FORMATTER_INPUT_BITWIDTH_SELECT_10_BITS (1)
#define ACAMERA_ISP_INPUT_FORMATTER_INPUT_BITWIDTH_SELECT_12_BITS (2)
#define ACAMERA_ISP_INPUT_FORMATTER_INPUT_BITWIDTH_SELECT_14_BITS (3)
#define ACAMERA_ISP_INPUT_FORMATTER_INPUT_BITWIDTH_SELECT_16_BITS (4)
#define ACAMERA_ISP_INPUT_FORMATTER_INPUT_BITWIDTH_SELECT_20_BITS_NO_18_BITS (5)

// args: data (3-bit)
static __inline void acamera_isp_input_formatter_input_bitwidth_select_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f98L);
    system_sw_write_32(base + 0x18f98L, (((uint32_t) (data & 0x7)) << 16) | (curr & 0xfff8ffff));
}
static __inline uint8_t acamera_isp_input_formatter_input_bitwidth_select_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18f98L) & 0x70000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: factor ML
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  18 bit, 6.12 fix point - ratio between long and medium exposure for 2:3 multiplexed mode 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_INPUT_FORMATTER_FACTOR_ML_DEFAULT (0x1000)
#define ACAMERA_ISP_INPUT_FORMATTER_FACTOR_ML_DATASIZE (18)
#define ACAMERA_ISP_INPUT_FORMATTER_FACTOR_ML_OFFSET (0x114)
#define ACAMERA_ISP_INPUT_FORMATTER_FACTOR_ML_MASK (0x3ffff)

// args: data (18-bit)
static __inline void acamera_isp_input_formatter_factor_ml_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18f9cL);
    system_sw_write_32(base + 0x18f9cL, (((uint32_t) (data & 0x3ffff)) << 0) | (curr & 0xfffc0000));
}
static __inline uint32_t acamera_isp_input_formatter_factor_ml_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x18f9cL) & 0x3ffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: factor MS
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  13 bit, 1.12 fix point - ratio between short and medium exposure for 2:3 multiplexed mode 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_INPUT_FORMATTER_FACTOR_MS_DEFAULT (0x1000)
#define ACAMERA_ISP_INPUT_FORMATTER_FACTOR_MS_DATASIZE (13)
#define ACAMERA_ISP_INPUT_FORMATTER_FACTOR_MS_OFFSET (0x118)
#define ACAMERA_ISP_INPUT_FORMATTER_FACTOR_MS_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_input_formatter_factor_ms_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fa0L);
    system_sw_write_32(base + 0x18fa0L, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_input_formatter_factor_ms_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fa0L) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: black level
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Black level of sensor data for 2:3 multiplexed mode 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_INPUT_FORMATTER_BLACK_LEVEL_DEFAULT (0)
#define ACAMERA_ISP_INPUT_FORMATTER_BLACK_LEVEL_DATASIZE (12)
#define ACAMERA_ISP_INPUT_FORMATTER_BLACK_LEVEL_OFFSET (0x11c)
#define ACAMERA_ISP_INPUT_FORMATTER_BLACK_LEVEL_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_input_formatter_black_level_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fa4L);
    system_sw_write_32(base + 0x18fa4L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_input_formatter_black_level_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fa4L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: knee point0
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  First knee point
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_INPUT_FORMATTER_KNEE_POINT0_DEFAULT (512)
#define ACAMERA_ISP_INPUT_FORMATTER_KNEE_POINT0_DATASIZE (16)
#define ACAMERA_ISP_INPUT_FORMATTER_KNEE_POINT0_OFFSET (0x120)
#define ACAMERA_ISP_INPUT_FORMATTER_KNEE_POINT0_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_input_formatter_knee_point0_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fa8L);
    system_sw_write_32(base + 0x18fa8L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_input_formatter_knee_point0_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fa8L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: knee point1
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Second knee point
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_INPUT_FORMATTER_KNEE_POINT1_DEFAULT (1408)
#define ACAMERA_ISP_INPUT_FORMATTER_KNEE_POINT1_DATASIZE (16)
#define ACAMERA_ISP_INPUT_FORMATTER_KNEE_POINT1_OFFSET (0x120)
#define ACAMERA_ISP_INPUT_FORMATTER_KNEE_POINT1_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_input_formatter_knee_point1_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fa8L);
    system_sw_write_32(base + 0x18fa8L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_input_formatter_knee_point1_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fa8L) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: knee point2
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Third knee point
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_INPUT_FORMATTER_KNEE_POINT2_DEFAULT (2177)
#define ACAMERA_ISP_INPUT_FORMATTER_KNEE_POINT2_DATASIZE (16)
#define ACAMERA_ISP_INPUT_FORMATTER_KNEE_POINT2_OFFSET (0x124)
#define ACAMERA_ISP_INPUT_FORMATTER_KNEE_POINT2_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_input_formatter_knee_point2_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18facL);
    system_sw_write_32(base + 0x18facL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_input_formatter_knee_point2_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18facL) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: slope0 select
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  First slope for companding table segments
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE0_SELECT_DEFAULT (2)
#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE0_SELECT_DATASIZE (4)
#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE0_SELECT_OFFSET (0x128)
#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE0_SELECT_MASK (0xf)
#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE0_SELECT_1X (0)
#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE0_SELECT_2X (1)
#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE0_SELECT_4X (2)
#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE0_SELECT_8X (3)
#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE0_SELECT_16X (4)
#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE0_SELECT_32X (5)
#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE0_SELECT_64X (6)
#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE0_SELECT_128X (7)
#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE0_SELECT_256X (8)
#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE0_SELECT_512X (9)
#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE0_SELECT_1024X (10)
#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE0_SELECT_2048X (11)
#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE0_SELECT_4096X (12)
#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE0_SELECT_8192X (13)
#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE0_SELECT_16384X (14)
#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE0_SELECT_32768X (15)

// args: data (4-bit)
static __inline void acamera_isp_input_formatter_slope0_select_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fb0L);
    system_sw_write_32(base + 0x18fb0L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
}
static __inline uint8_t acamera_isp_input_formatter_slope0_select_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18fb0L) & 0xf) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: slope1 select
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Second slope for companding table segments (encoding is the same as slope0 select)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE1_SELECT_DEFAULT (4)
#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE1_SELECT_DATASIZE (4)
#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE1_SELECT_OFFSET (0x128)
#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE1_SELECT_MASK (0xf00)

// args: data (4-bit)
static __inline void acamera_isp_input_formatter_slope1_select_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fb0L);
    system_sw_write_32(base + 0x18fb0L, (((uint32_t) (data & 0xf)) << 8) | (curr & 0xfffff0ff));
}
static __inline uint8_t acamera_isp_input_formatter_slope1_select_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18fb0L) & 0xf00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: slope2 select
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Third slope for companding table segments (encoding is the same as slope0 select)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE2_SELECT_DEFAULT (6)
#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE2_SELECT_DATASIZE (4)
#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE2_SELECT_OFFSET (0x128)
#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE2_SELECT_MASK (0xf0000)

// args: data (4-bit)
static __inline void acamera_isp_input_formatter_slope2_select_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fb0L);
    system_sw_write_32(base + 0x18fb0L, (((uint32_t) (data & 0xf)) << 16) | (curr & 0xfff0ffff));
}
static __inline uint8_t acamera_isp_input_formatter_slope2_select_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18fb0L) & 0xf0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: slope3 select
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Last slope for companding table segments (encoding is the same as slope0 select)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE3_SELECT_DEFAULT (9)
#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE3_SELECT_DATASIZE (4)
#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE3_SELECT_OFFSET (0x128)
#define ACAMERA_ISP_INPUT_FORMATTER_SLOPE3_SELECT_MASK (0xf000000)

// args: data (4-bit)
static __inline void acamera_isp_input_formatter_slope3_select_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fb0L);
    system_sw_write_32(base + 0x18fb0L, (((uint32_t) (data & 0xf)) << 24) | (curr & 0xf0ffffff));
}
static __inline uint8_t acamera_isp_input_formatter_slope3_select_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18fb0L) & 0xf000000) >> 24);
}
// ------------------------------------------------------------------------------ //
// Group: sensor offset wdr l
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset subtraction for each color channel and exposure
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: offset 00
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset for color channel 00 (R)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SENSOR_OFFSET_WDR_L_OFFSET_00_DEFAULT (0x00)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_L_OFFSET_00_DATASIZE (12)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_L_OFFSET_00_OFFSET (0x12c)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_L_OFFSET_00_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_sensor_offset_wdr_l_offset_00_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fb4L);
    system_sw_write_32(base + 0x18fb4L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_sensor_offset_wdr_l_offset_00_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fb4L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: offset 01
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset for color channel 01 (Gr)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SENSOR_OFFSET_WDR_L_OFFSET_01_DEFAULT (0x00)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_L_OFFSET_01_DATASIZE (12)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_L_OFFSET_01_OFFSET (0x12c)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_L_OFFSET_01_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_sensor_offset_wdr_l_offset_01_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fb4L);
    system_sw_write_32(base + 0x18fb4L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_sensor_offset_wdr_l_offset_01_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fb4L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: offset 10
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset for color channel 10 (Gb)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SENSOR_OFFSET_WDR_L_OFFSET_10_DEFAULT (0x00)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_L_OFFSET_10_DATASIZE (12)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_L_OFFSET_10_OFFSET (0x130)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_L_OFFSET_10_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_sensor_offset_wdr_l_offset_10_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fb8L);
    system_sw_write_32(base + 0x18fb8L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_sensor_offset_wdr_l_offset_10_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fb8L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: offset 11
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset for color channel 11 (B)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SENSOR_OFFSET_WDR_L_OFFSET_11_DEFAULT (0x00)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_L_OFFSET_11_DATASIZE (12)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_L_OFFSET_11_OFFSET (0x130)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_L_OFFSET_11_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_sensor_offset_wdr_l_offset_11_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fb8L);
    system_sw_write_32(base + 0x18fb8L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_sensor_offset_wdr_l_offset_11_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fb8L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Group: sensor offset wdr m
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset subtraction for each color channel and exposure
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: offset 00
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset for color channel 00 (R)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SENSOR_OFFSET_WDR_M_OFFSET_00_DEFAULT (0x00)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_M_OFFSET_00_DATASIZE (12)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_M_OFFSET_00_OFFSET (0x134)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_M_OFFSET_00_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_sensor_offset_wdr_m_offset_00_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fbcL);
    system_sw_write_32(base + 0x18fbcL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_sensor_offset_wdr_m_offset_00_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fbcL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: offset 01
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset for color channel 01 (Gr)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SENSOR_OFFSET_WDR_M_OFFSET_01_DEFAULT (0x00)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_M_OFFSET_01_DATASIZE (12)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_M_OFFSET_01_OFFSET (0x134)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_M_OFFSET_01_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_sensor_offset_wdr_m_offset_01_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fbcL);
    system_sw_write_32(base + 0x18fbcL, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_sensor_offset_wdr_m_offset_01_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fbcL) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: offset 10
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset for color channel 10 (Gb)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SENSOR_OFFSET_WDR_M_OFFSET_10_DEFAULT (0x00)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_M_OFFSET_10_DATASIZE (12)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_M_OFFSET_10_OFFSET (0x138)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_M_OFFSET_10_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_sensor_offset_wdr_m_offset_10_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fc0L);
    system_sw_write_32(base + 0x18fc0L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_sensor_offset_wdr_m_offset_10_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fc0L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: offset 11
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset for color channel 11 (B)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SENSOR_OFFSET_WDR_M_OFFSET_11_DEFAULT (0x00)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_M_OFFSET_11_DATASIZE (12)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_M_OFFSET_11_OFFSET (0x138)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_M_OFFSET_11_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_sensor_offset_wdr_m_offset_11_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fc0L);
    system_sw_write_32(base + 0x18fc0L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_sensor_offset_wdr_m_offset_11_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fc0L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Group: sensor offset wdr s
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset subtraction for each color channel and exposure
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: offset 00
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset for color channel 00 (R)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SENSOR_OFFSET_WDR_S_OFFSET_00_DEFAULT (0x00)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_S_OFFSET_00_DATASIZE (12)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_S_OFFSET_00_OFFSET (0x13c)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_S_OFFSET_00_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_sensor_offset_wdr_s_offset_00_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fc4L);
    system_sw_write_32(base + 0x18fc4L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_sensor_offset_wdr_s_offset_00_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fc4L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: offset 01
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset for color channel 01 (Gr)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SENSOR_OFFSET_WDR_S_OFFSET_01_DEFAULT (0x00)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_S_OFFSET_01_DATASIZE (12)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_S_OFFSET_01_OFFSET (0x13c)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_S_OFFSET_01_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_sensor_offset_wdr_s_offset_01_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fc4L);
    system_sw_write_32(base + 0x18fc4L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_sensor_offset_wdr_s_offset_01_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fc4L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: offset 10
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset for color channel 10 (Gb)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SENSOR_OFFSET_WDR_S_OFFSET_10_DEFAULT (0x00)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_S_OFFSET_10_DATASIZE (12)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_S_OFFSET_10_OFFSET (0x140)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_S_OFFSET_10_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_sensor_offset_wdr_s_offset_10_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fc8L);
    system_sw_write_32(base + 0x18fc8L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_sensor_offset_wdr_s_offset_10_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fc8L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: offset 11
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset for color channel 11 (B)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SENSOR_OFFSET_WDR_S_OFFSET_11_DEFAULT (0x00)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_S_OFFSET_11_DATASIZE (12)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_S_OFFSET_11_OFFSET (0x140)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_S_OFFSET_11_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_sensor_offset_wdr_s_offset_11_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fc8L);
    system_sw_write_32(base + 0x18fc8L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_sensor_offset_wdr_s_offset_11_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fc8L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Group: sensor offset wdr vs
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset subtraction for each color channel and exposure
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: offset 00
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset for color channel 00 (R)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SENSOR_OFFSET_WDR_VS_OFFSET_00_DEFAULT (0x00)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_VS_OFFSET_00_DATASIZE (12)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_VS_OFFSET_00_OFFSET (0x144)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_VS_OFFSET_00_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_sensor_offset_wdr_vs_offset_00_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fccL);
    system_sw_write_32(base + 0x18fccL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_sensor_offset_wdr_vs_offset_00_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fccL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: offset 01
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset for color channel 01 (Gr)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SENSOR_OFFSET_WDR_VS_OFFSET_01_DEFAULT (0x00)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_VS_OFFSET_01_DATASIZE (12)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_VS_OFFSET_01_OFFSET (0x144)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_VS_OFFSET_01_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_sensor_offset_wdr_vs_offset_01_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fccL);
    system_sw_write_32(base + 0x18fccL, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_sensor_offset_wdr_vs_offset_01_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fccL) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: offset 10
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset for color channel 10 (Gb)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SENSOR_OFFSET_WDR_VS_OFFSET_10_DEFAULT (0x00)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_VS_OFFSET_10_DATASIZE (12)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_VS_OFFSET_10_OFFSET (0x148)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_VS_OFFSET_10_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_sensor_offset_wdr_vs_offset_10_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fd0L);
    system_sw_write_32(base + 0x18fd0L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_sensor_offset_wdr_vs_offset_10_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fd0L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: offset 11
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset for color channel 11 (B)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SENSOR_OFFSET_WDR_VS_OFFSET_11_DEFAULT (0x00)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_VS_OFFSET_11_DATASIZE (12)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_VS_OFFSET_11_OFFSET (0x148)
#define ACAMERA_ISP_SENSOR_OFFSET_WDR_VS_OFFSET_11_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_sensor_offset_wdr_vs_offset_11_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fd0L);
    system_sw_write_32(base + 0x18fd0L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_sensor_offset_wdr_vs_offset_11_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fd0L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Group: gain wdr
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Gain adjustment for the WDR stitching 
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Gain_l
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Gain applied to ch-long data in 5.8 format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_GAIN_WDR_GAIN_L_DEFAULT (0x100)
#define ACAMERA_ISP_GAIN_WDR_GAIN_L_DATASIZE (13)
#define ACAMERA_ISP_GAIN_WDR_GAIN_L_OFFSET (0x14c)
#define ACAMERA_ISP_GAIN_WDR_GAIN_L_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_gain_wdr_gain_l_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fd4L);
    system_sw_write_32(base + 0x18fd4L, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_gain_wdr_gain_l_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fd4L) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Gain_m
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Gain applied to ch-medium data in 5.8 format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_GAIN_WDR_GAIN_M_DEFAULT (0x100)
#define ACAMERA_ISP_GAIN_WDR_GAIN_M_DATASIZE (13)
#define ACAMERA_ISP_GAIN_WDR_GAIN_M_OFFSET (0x14c)
#define ACAMERA_ISP_GAIN_WDR_GAIN_M_MASK (0x1fff0000)

// args: data (13-bit)
static __inline void acamera_isp_gain_wdr_gain_m_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fd4L);
    system_sw_write_32(base + 0x18fd4L, (((uint32_t) (data & 0x1fff)) << 16) | (curr & 0xe000ffff));
}
static __inline uint16_t acamera_isp_gain_wdr_gain_m_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fd4L) & 0x1fff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Gain_s
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Gain applied to ch-short data in 5.8 format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_GAIN_WDR_GAIN_S_DEFAULT (0x100)
#define ACAMERA_ISP_GAIN_WDR_GAIN_S_DATASIZE (13)
#define ACAMERA_ISP_GAIN_WDR_GAIN_S_OFFSET (0x150)
#define ACAMERA_ISP_GAIN_WDR_GAIN_S_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_gain_wdr_gain_s_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fd8L);
    system_sw_write_32(base + 0x18fd8L, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_gain_wdr_gain_s_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fd8L) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Gain_vs
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Gain applied to ch-vs data in 5.8 format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_GAIN_WDR_GAIN_VS_DEFAULT (0x100)
#define ACAMERA_ISP_GAIN_WDR_GAIN_VS_DATASIZE (13)
#define ACAMERA_ISP_GAIN_WDR_GAIN_VS_OFFSET (0x150)
#define ACAMERA_ISP_GAIN_WDR_GAIN_VS_MASK (0x1fff0000)

// args: data (13-bit)
static __inline void acamera_isp_gain_wdr_gain_vs_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fd8L);
    system_sw_write_32(base + 0x18fd8L, (((uint32_t) (data & 0x1fff)) << 16) | (curr & 0xe000ffff));
}
static __inline uint16_t acamera_isp_gain_wdr_gain_vs_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fd8L) & 0x1fff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: black_level_l
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Sensor offset applied to ch-long data
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_GAIN_WDR_BLACK_LEVEL_L_DEFAULT (0x0000)
#define ACAMERA_ISP_GAIN_WDR_BLACK_LEVEL_L_DATASIZE (12)
#define ACAMERA_ISP_GAIN_WDR_BLACK_LEVEL_L_OFFSET (0x154)
#define ACAMERA_ISP_GAIN_WDR_BLACK_LEVEL_L_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_gain_wdr_black_level_l_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fdcL);
    system_sw_write_32(base + 0x18fdcL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_gain_wdr_black_level_l_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fdcL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: black_level_m
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Sensor offset applied to ch-medium data
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_GAIN_WDR_BLACK_LEVEL_M_DEFAULT (0x0000)
#define ACAMERA_ISP_GAIN_WDR_BLACK_LEVEL_M_DATASIZE (12)
#define ACAMERA_ISP_GAIN_WDR_BLACK_LEVEL_M_OFFSET (0x154)
#define ACAMERA_ISP_GAIN_WDR_BLACK_LEVEL_M_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_gain_wdr_black_level_m_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fdcL);
    system_sw_write_32(base + 0x18fdcL, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_gain_wdr_black_level_m_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fdcL) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: black_level_s
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Sensor offset applied to ch-short data
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_GAIN_WDR_BLACK_LEVEL_S_DEFAULT (0x0000)
#define ACAMERA_ISP_GAIN_WDR_BLACK_LEVEL_S_DATASIZE (12)
#define ACAMERA_ISP_GAIN_WDR_BLACK_LEVEL_S_OFFSET (0x158)
#define ACAMERA_ISP_GAIN_WDR_BLACK_LEVEL_S_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_gain_wdr_black_level_s_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fe0L);
    system_sw_write_32(base + 0x18fe0L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_gain_wdr_black_level_s_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fe0L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: black_level_vs
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Sensor offset applied to ch-veryshort data
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_GAIN_WDR_BLACK_LEVEL_VS_DEFAULT (0x0000)
#define ACAMERA_ISP_GAIN_WDR_BLACK_LEVEL_VS_DATASIZE (12)
#define ACAMERA_ISP_GAIN_WDR_BLACK_LEVEL_VS_OFFSET (0x158)
#define ACAMERA_ISP_GAIN_WDR_BLACK_LEVEL_VS_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_gain_wdr_black_level_vs_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fe0L);
    system_sw_write_32(base + 0x18fe0L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_gain_wdr_black_level_vs_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fe0L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Group: frame stitch
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//                4-exposure wide-dynamic-range blending
//
//                NOTE: 
//                    If the WDR is configured to stitch 2 exposures, then the configuration must be done through the LM_ pair
//                    the short exposures black level must be programmed through the med_black_level register so that the LM pair 
//                    can be used.
//
//
//          
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: mode_in
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  0 : 4-exposure
//                          1 : 2-exposure
//                          2 : 3-exposure
//                          3 : 4-exposure
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_MODE_IN_DEFAULT (0)
#define ACAMERA_ISP_FRAME_STITCH_MODE_IN_DATASIZE (2)
#define ACAMERA_ISP_FRAME_STITCH_MODE_IN_OFFSET (0x15c)
#define ACAMERA_ISP_FRAME_STITCH_MODE_IN_MASK (0x3)

// args: data (2-bit)
static __inline void acamera_isp_frame_stitch_mode_in_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fe4L);
    system_sw_write_32(base + 0x18fe4L, (((uint32_t) (data & 0x3)) << 0) | (curr & 0xfffffffc));
}
static __inline uint8_t acamera_isp_frame_stitch_mode_in_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18fe4L) & 0x3) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: output_select
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  
//            This register is only for debug purpose. for normal operation it must be kept in its default value (0)
//            0 : normal stitched output
//            1 : long data routed out
//            2 : medium data routed out
//            4 : short data routed out
//            8 : very short data routed out
//            16: LM stitched output taken out
//            32: MS stitched output taken out
//            64: SVS stitched output taken out
//            others: reserved
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_OUTPUT_SELECT_DEFAULT (0)
#define ACAMERA_ISP_FRAME_STITCH_OUTPUT_SELECT_DATASIZE (8)
#define ACAMERA_ISP_FRAME_STITCH_OUTPUT_SELECT_OFFSET (0x15c)
#define ACAMERA_ISP_FRAME_STITCH_OUTPUT_SELECT_MASK (0xff00)

// args: data (8-bit)
static __inline void acamera_isp_frame_stitch_output_select_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fe4L);
    system_sw_write_32(base + 0x18fe4L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
}
static __inline uint8_t acamera_isp_frame_stitch_output_select_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x18fe4L) & 0xff00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: LM_Exposure_Ratio
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Sets ratio between long and medium exposures - this must match the actual exposure ratio on the sensor
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_LM_EXPOSURE_RATIO_DEFAULT (0x100)
#define ACAMERA_ISP_FRAME_STITCH_LM_EXPOSURE_RATIO_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_LM_EXPOSURE_RATIO_OFFSET (0x160)
#define ACAMERA_ISP_FRAME_STITCH_LM_EXPOSURE_RATIO_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_lm_exposure_ratio_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fe8L);
    system_sw_write_32(base + 0x18fe8L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_frame_stitch_lm_exposure_ratio_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fe8L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: MS_Exposure_Ratio
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Sets ratio between medium and short exposures - this must match the actual exposure ratio on the sensor
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_MS_EXPOSURE_RATIO_DEFAULT (0x100)
#define ACAMERA_ISP_FRAME_STITCH_MS_EXPOSURE_RATIO_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_MS_EXPOSURE_RATIO_OFFSET (0x160)
#define ACAMERA_ISP_FRAME_STITCH_MS_EXPOSURE_RATIO_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_ms_exposure_ratio_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fe8L);
    system_sw_write_32(base + 0x18fe8L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_frame_stitch_ms_exposure_ratio_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fe8L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: SVS_Exposure_Ratio
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Sets ratio between short and very short exposures - this must match the actual exposure ratio on the sensor
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_SVS_EXPOSURE_RATIO_DEFAULT (0x100)
#define ACAMERA_ISP_FRAME_STITCH_SVS_EXPOSURE_RATIO_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_SVS_EXPOSURE_RATIO_OFFSET (0x164)
#define ACAMERA_ISP_FRAME_STITCH_SVS_EXPOSURE_RATIO_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_svs_exposure_ratio_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18fecL);
    system_sw_write_32(base + 0x18fecL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_frame_stitch_svs_exposure_ratio_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18fecL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: LM_Thresh_high
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            These two thresholds are for LM pairs. Both are with respect to the longer stitches.
//            Data above this threshold will be taken from short exposure only
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_LM_THRESH_HIGH_DEFAULT (0x0F00)
#define ACAMERA_ISP_FRAME_STITCH_LM_THRESH_HIGH_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_LM_THRESH_HIGH_OFFSET (0x168)
#define ACAMERA_ISP_FRAME_STITCH_LM_THRESH_HIGH_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_lm_thresh_high_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ff0L);
    system_sw_write_32(base + 0x18ff0L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_frame_stitch_lm_thresh_high_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18ff0L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: LM_Thresh_low
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            Data below this threshold will be taken from long exposure only
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_LM_THRESH_LOW_DEFAULT (0x0C00)
#define ACAMERA_ISP_FRAME_STITCH_LM_THRESH_LOW_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_LM_THRESH_LOW_OFFSET (0x168)
#define ACAMERA_ISP_FRAME_STITCH_LM_THRESH_LOW_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_lm_thresh_low_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ff0L);
    system_sw_write_32(base + 0x18ff0L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_frame_stitch_lm_thresh_low_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18ff0L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: MS_Thresh_high
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            These two thresholds are for MS pairs. Both are with respect to the longer stitches.
//            Data above this threshold will be taken from short exposure only
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_MS_THRESH_HIGH_DEFAULT (0x0F00)
#define ACAMERA_ISP_FRAME_STITCH_MS_THRESH_HIGH_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_MS_THRESH_HIGH_OFFSET (0x16c)
#define ACAMERA_ISP_FRAME_STITCH_MS_THRESH_HIGH_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_ms_thresh_high_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ff4L);
    system_sw_write_32(base + 0x18ff4L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_frame_stitch_ms_thresh_high_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18ff4L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: MS_Thresh_low
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            Data below this threshold will be taken from long exposure only
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_MS_THRESH_LOW_DEFAULT (0x0C00)
#define ACAMERA_ISP_FRAME_STITCH_MS_THRESH_LOW_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_MS_THRESH_LOW_OFFSET (0x16c)
#define ACAMERA_ISP_FRAME_STITCH_MS_THRESH_LOW_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_ms_thresh_low_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ff4L);
    system_sw_write_32(base + 0x18ff4L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_frame_stitch_ms_thresh_low_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18ff4L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: SVS_Thresh_high
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            These two thresholds are for SVS pairs. Both are with respect to the longer stitches.
//            Data above this threshold will be taken from short exposure only
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_SVS_THRESH_HIGH_DEFAULT (0x0F00)
#define ACAMERA_ISP_FRAME_STITCH_SVS_THRESH_HIGH_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_SVS_THRESH_HIGH_OFFSET (0x170)
#define ACAMERA_ISP_FRAME_STITCH_SVS_THRESH_HIGH_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_svs_thresh_high_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ff8L);
    system_sw_write_32(base + 0x18ff8L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_frame_stitch_svs_thresh_high_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18ff8L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: SVS_Thresh_low
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            Data below this threshold will be taken from long exposure only
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_SVS_THRESH_LOW_DEFAULT (0x0C00)
#define ACAMERA_ISP_FRAME_STITCH_SVS_THRESH_LOW_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_SVS_THRESH_LOW_OFFSET (0x170)
#define ACAMERA_ISP_FRAME_STITCH_SVS_THRESH_LOW_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_svs_thresh_low_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ff8L);
    system_sw_write_32(base + 0x18ff8L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_frame_stitch_svs_thresh_low_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18ff8L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Black_level_long
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            Black level for long exposure input
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_BLACK_LEVEL_LONG_DEFAULT (0x000)
#define ACAMERA_ISP_FRAME_STITCH_BLACK_LEVEL_LONG_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_BLACK_LEVEL_LONG_OFFSET (0x174)
#define ACAMERA_ISP_FRAME_STITCH_BLACK_LEVEL_LONG_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_black_level_long_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ffcL);
    system_sw_write_32(base + 0x18ffcL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_frame_stitch_black_level_long_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18ffcL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Black_level_Medium
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            Black level for medium exposure input
//            *** NOTE ***:
//            If the wdr unit is configured to use as 2-exposure, THIS REGISTER POSITION must contain the black level of
//            short exposure as the LM pair is used for all other configurations
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_BLACK_LEVEL_MEDIUM_DEFAULT (0x00)
#define ACAMERA_ISP_FRAME_STITCH_BLACK_LEVEL_MEDIUM_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_BLACK_LEVEL_MEDIUM_OFFSET (0x174)
#define ACAMERA_ISP_FRAME_STITCH_BLACK_LEVEL_MEDIUM_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_black_level_medium_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x18ffcL);
    system_sw_write_32(base + 0x18ffcL, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_frame_stitch_black_level_medium_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x18ffcL) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Black_level_Short
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            Black level for short exposure input
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_BLACK_LEVEL_SHORT_DEFAULT (0x00)
#define ACAMERA_ISP_FRAME_STITCH_BLACK_LEVEL_SHORT_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_BLACK_LEVEL_SHORT_OFFSET (0x178)
#define ACAMERA_ISP_FRAME_STITCH_BLACK_LEVEL_SHORT_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_black_level_short_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19000L);
    system_sw_write_32(base + 0x19000L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_frame_stitch_black_level_short_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19000L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Black_level_very_Short
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            Black level for very short exposure input
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_BLACK_LEVEL_VERY_SHORT_DEFAULT (0x00)
#define ACAMERA_ISP_FRAME_STITCH_BLACK_LEVEL_VERY_SHORT_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_BLACK_LEVEL_VERY_SHORT_OFFSET (0x178)
#define ACAMERA_ISP_FRAME_STITCH_BLACK_LEVEL_VERY_SHORT_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_black_level_very_short_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19000L);
    system_sw_write_32(base + 0x19000L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_frame_stitch_black_level_very_short_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19000L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Black_level_Out
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            Black level for module output
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_BLACK_LEVEL_OUT_DEFAULT (0x000)
#define ACAMERA_ISP_FRAME_STITCH_BLACK_LEVEL_OUT_DATASIZE (20)
#define ACAMERA_ISP_FRAME_STITCH_BLACK_LEVEL_OUT_OFFSET (0x17c)
#define ACAMERA_ISP_FRAME_STITCH_BLACK_LEVEL_OUT_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_frame_stitch_black_level_out_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19004L);
    system_sw_write_32(base + 0x19004L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_frame_stitch_black_level_out_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x19004L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: LM_NP_mult
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            The noise profile weights are multiplied by this value to give expected noise amplitude. 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_LM_NP_MULT_DEFAULT (0x180)
#define ACAMERA_ISP_FRAME_STITCH_LM_NP_MULT_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_LM_NP_MULT_OFFSET (0x180)
#define ACAMERA_ISP_FRAME_STITCH_LM_NP_MULT_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_lm_np_mult_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19008L);
    system_sw_write_32(base + 0x19008L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_frame_stitch_lm_np_mult_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19008L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: MS_NP_mult
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            The noise profile weights are multiplied by this value to give expected noise amplitude. 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_MS_NP_MULT_DEFAULT (0x600)
#define ACAMERA_ISP_FRAME_STITCH_MS_NP_MULT_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_MS_NP_MULT_OFFSET (0x180)
#define ACAMERA_ISP_FRAME_STITCH_MS_NP_MULT_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_ms_np_mult_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19008L);
    system_sw_write_32(base + 0x19008L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_frame_stitch_ms_np_mult_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19008L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: SVS_NP_mult
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            The noise profile weights are multiplied by this value to give expected noise amplitude. 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_SVS_NP_MULT_DEFAULT (0x600)
#define ACAMERA_ISP_FRAME_STITCH_SVS_NP_MULT_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_SVS_NP_MULT_OFFSET (0x184)
#define ACAMERA_ISP_FRAME_STITCH_SVS_NP_MULT_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_svs_np_mult_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1900cL);
    system_sw_write_32(base + 0x1900cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_frame_stitch_svs_np_mult_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1900cL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: LM_Alpha_MOV_slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            This defines the gradient of the motion alpha ramp. Higher values mean a steeper ramp and so a more rapid transition between 
//            non-motion-corrected and motion-corrected regions.
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_LM_ALPHA_MOV_SLOPE_DEFAULT (0xC00)
#define ACAMERA_ISP_FRAME_STITCH_LM_ALPHA_MOV_SLOPE_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_LM_ALPHA_MOV_SLOPE_OFFSET (0x184)
#define ACAMERA_ISP_FRAME_STITCH_LM_ALPHA_MOV_SLOPE_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_lm_alpha_mov_slope_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1900cL);
    system_sw_write_32(base + 0x1900cL, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_frame_stitch_lm_alpha_mov_slope_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1900cL) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: MS_Alpha_MOV_slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            his defines the gradient of the motion alpha ramp. Higher values mean a steeper ramp and so a more rapid transition between 
//            non-motion-corrected and motion-corrected regions.
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_MS_ALPHA_MOV_SLOPE_DEFAULT (0x180)
#define ACAMERA_ISP_FRAME_STITCH_MS_ALPHA_MOV_SLOPE_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_MS_ALPHA_MOV_SLOPE_OFFSET (0x188)
#define ACAMERA_ISP_FRAME_STITCH_MS_ALPHA_MOV_SLOPE_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_ms_alpha_mov_slope_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19010L);
    system_sw_write_32(base + 0x19010L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_frame_stitch_ms_alpha_mov_slope_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19010L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: SVS_Alpha_MOV_slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            his defines the gradient of the motion alpha ramp. Higher values mean a steeper ramp and so a more rapid transition between 
//            non-motion-corrected and motion-corrected regions.
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_SVS_ALPHA_MOV_SLOPE_DEFAULT (0x180)
#define ACAMERA_ISP_FRAME_STITCH_SVS_ALPHA_MOV_SLOPE_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_SVS_ALPHA_MOV_SLOPE_OFFSET (0x188)
#define ACAMERA_ISP_FRAME_STITCH_SVS_ALPHA_MOV_SLOPE_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_svs_alpha_mov_slope_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19010L);
    system_sw_write_32(base + 0x19010L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_frame_stitch_svs_alpha_mov_slope_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19010L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Gain_R
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            Multiplier for color channel R
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_GAIN_R_DEFAULT (0x100)
#define ACAMERA_ISP_FRAME_STITCH_GAIN_R_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_GAIN_R_OFFSET (0x18c)
#define ACAMERA_ISP_FRAME_STITCH_GAIN_R_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_gain_r_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19014L);
    system_sw_write_32(base + 0x19014L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_frame_stitch_gain_r_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19014L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Gain_B
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            Multiplier for color channel B
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_GAIN_B_DEFAULT (0x100)
#define ACAMERA_ISP_FRAME_STITCH_GAIN_B_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_GAIN_B_OFFSET (0x18c)
#define ACAMERA_ISP_FRAME_STITCH_GAIN_B_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_gain_b_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19014L);
    system_sw_write_32(base + 0x19014L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_frame_stitch_gain_b_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19014L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Consistency_thresh_mov
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            Pixel consistency reporting - motion threshold
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_CONSISTENCY_THRESH_MOV_DEFAULT (0x100)
#define ACAMERA_ISP_FRAME_STITCH_CONSISTENCY_THRESH_MOV_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_CONSISTENCY_THRESH_MOV_OFFSET (0x190)
#define ACAMERA_ISP_FRAME_STITCH_CONSISTENCY_THRESH_MOV_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_consistency_thresh_mov_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19018L);
    system_sw_write_32(base + 0x19018L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_frame_stitch_consistency_thresh_mov_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19018L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Consistency_thresh_lvl
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            Pixel consistency reporting - flicker threshold
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_CONSISTENCY_THRESH_LVL_DEFAULT (0x80000)
#define ACAMERA_ISP_FRAME_STITCH_CONSISTENCY_THRESH_LVL_DATASIZE (20)
#define ACAMERA_ISP_FRAME_STITCH_CONSISTENCY_THRESH_LVL_OFFSET (0x194)
#define ACAMERA_ISP_FRAME_STITCH_CONSISTENCY_THRESH_LVL_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_frame_stitch_consistency_thresh_lvl_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1901cL);
    system_sw_write_32(base + 0x1901cL, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_frame_stitch_consistency_thresh_lvl_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x1901cL) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: lm_noise_thresh
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//              Higher values make it more likely to interpret differences between the long and medium exposures as noise (and thus do no motion correction).
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_LM_NOISE_THRESH_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_LM_NOISE_THRESH_DATASIZE (6)
#define ACAMERA_ISP_FRAME_STITCH_LM_NOISE_THRESH_OFFSET (0x198)
#define ACAMERA_ISP_FRAME_STITCH_LM_NOISE_THRESH_MASK (0x3f)

// args: data (6-bit)
static __inline void acamera_isp_frame_stitch_lm_noise_thresh_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19020L);
    system_sw_write_32(base + 0x19020L, (((uint32_t) (data & 0x3f)) << 0) | (curr & 0xffffffc0));
}
static __inline uint8_t acamera_isp_frame_stitch_lm_noise_thresh_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19020L) & 0x3f) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: lm_pos_weight
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//              Lower values make it more likely to interpret  differences between the long and medium exposures as noise (and thus do no motion correction).
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_LM_POS_WEIGHT_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_LM_POS_WEIGHT_DATASIZE (6)
#define ACAMERA_ISP_FRAME_STITCH_LM_POS_WEIGHT_OFFSET (0x198)
#define ACAMERA_ISP_FRAME_STITCH_LM_POS_WEIGHT_MASK (0x3f00)

// args: data (6-bit)
static __inline void acamera_isp_frame_stitch_lm_pos_weight_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19020L);
    system_sw_write_32(base + 0x19020L, (((uint32_t) (data & 0x3f)) << 8) | (curr & 0xffffc0ff));
}
static __inline uint8_t acamera_isp_frame_stitch_lm_pos_weight_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19020L) & 0x3f00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: lm_neg_weight
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//              Higher values make it more likely to interpret differences between the long and medium exposures as noise (and thus do no motion correction).
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_LM_NEG_WEIGHT_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_LM_NEG_WEIGHT_DATASIZE (6)
#define ACAMERA_ISP_FRAME_STITCH_LM_NEG_WEIGHT_OFFSET (0x198)
#define ACAMERA_ISP_FRAME_STITCH_LM_NEG_WEIGHT_MASK (0x3f0000)

// args: data (6-bit)
static __inline void acamera_isp_frame_stitch_lm_neg_weight_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19020L);
    system_sw_write_32(base + 0x19020L, (((uint32_t) (data & 0x3f)) << 16) | (curr & 0xffc0ffff));
}
static __inline uint8_t acamera_isp_frame_stitch_lm_neg_weight_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19020L) & 0x3f0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: lm_med_noise_alpha_thresh
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_LM_MED_NOISE_ALPHA_THRESH_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_LM_MED_NOISE_ALPHA_THRESH_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_LM_MED_NOISE_ALPHA_THRESH_OFFSET (0x19c)
#define ACAMERA_ISP_FRAME_STITCH_LM_MED_NOISE_ALPHA_THRESH_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_lm_med_noise_alpha_thresh_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19024L);
    system_sw_write_32(base + 0x19024L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_frame_stitch_lm_med_noise_alpha_thresh_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19024L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: lm_med_noise_intensity_thresh
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_LM_MED_NOISE_INTENSITY_THRESH_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_LM_MED_NOISE_INTENSITY_THRESH_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_LM_MED_NOISE_INTENSITY_THRESH_OFFSET (0x19c)
#define ACAMERA_ISP_FRAME_STITCH_LM_MED_NOISE_INTENSITY_THRESH_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_lm_med_noise_intensity_thresh_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19024L);
    system_sw_write_32(base + 0x19024L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_frame_stitch_lm_med_noise_intensity_thresh_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19024L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: lm_mc_blend_slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_LM_MC_BLEND_SLOPE_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_BLEND_SLOPE_DATASIZE (22)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_BLEND_SLOPE_OFFSET (0x1a0)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_BLEND_SLOPE_MASK (0x3fffff)

// args: data (22-bit)
static __inline void acamera_isp_frame_stitch_lm_mc_blend_slope_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19028L);
    system_sw_write_32(base + 0x19028L, (((uint32_t) (data & 0x3fffff)) << 0) | (curr & 0xffc00000));
}
static __inline uint32_t acamera_isp_frame_stitch_lm_mc_blend_slope_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x19028L) & 0x3fffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: lm_mc_blend_thresh
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_LM_MC_BLEND_THRESH_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_BLEND_THRESH_DATASIZE (8)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_BLEND_THRESH_OFFSET (0x1a4)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_BLEND_THRESH_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_frame_stitch_lm_mc_blend_thresh_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1902cL);
    system_sw_write_32(base + 0x1902cL, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_frame_stitch_lm_mc_blend_thresh_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1902cL) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: lm_mc_blend_offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_LM_MC_BLEND_OFFSET_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_BLEND_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_BLEND_OFFSET_OFFSET (0x1a4)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_BLEND_OFFSET_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_lm_mc_blend_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1902cL);
    system_sw_write_32(base + 0x1902cL, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_frame_stitch_lm_mc_blend_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1902cL) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: lm_mc_thresh_slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_LM_MC_THRESH_SLOPE_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_THRESH_SLOPE_DATASIZE (22)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_THRESH_SLOPE_OFFSET (0x1a8)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_THRESH_SLOPE_MASK (0x3fffff)

// args: data (22-bit)
static __inline void acamera_isp_frame_stitch_lm_mc_thresh_slope_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19030L);
    system_sw_write_32(base + 0x19030L, (((uint32_t) (data & 0x3fffff)) << 0) | (curr & 0xffc00000));
}
static __inline uint32_t acamera_isp_frame_stitch_lm_mc_thresh_slope_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x19030L) & 0x3fffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: lm_mc_thresh_thresh
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_LM_MC_THRESH_THRESH_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_THRESH_THRESH_DATASIZE (20)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_THRESH_THRESH_OFFSET (0x1ac)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_THRESH_THRESH_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_frame_stitch_lm_mc_thresh_thresh_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19034L);
    system_sw_write_32(base + 0x19034L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_frame_stitch_lm_mc_thresh_thresh_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x19034L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: lm_mc_thresh_offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_LM_MC_THRESH_OFFSET_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_THRESH_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_THRESH_OFFSET_OFFSET (0x1b0)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_THRESH_OFFSET_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_lm_mc_thresh_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19038L);
    system_sw_write_32(base + 0x19038L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_frame_stitch_lm_mc_thresh_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19038L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: lm_mc_mag_thresh_slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_LM_MC_MAG_THRESH_SLOPE_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_MAG_THRESH_SLOPE_DATASIZE (22)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_MAG_THRESH_SLOPE_OFFSET (0x1b4)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_MAG_THRESH_SLOPE_MASK (0x3fffff)

// args: data (22-bit)
static __inline void acamera_isp_frame_stitch_lm_mc_mag_thresh_slope_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1903cL);
    system_sw_write_32(base + 0x1903cL, (((uint32_t) (data & 0x3fffff)) << 0) | (curr & 0xffc00000));
}
static __inline uint32_t acamera_isp_frame_stitch_lm_mc_mag_thresh_slope_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x1903cL) & 0x3fffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: lm_mc_mag_thresh_thresh
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_LM_MC_MAG_THRESH_THRESH_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_MAG_THRESH_THRESH_DATASIZE (20)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_MAG_THRESH_THRESH_OFFSET (0x1b8)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_MAG_THRESH_THRESH_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_frame_stitch_lm_mc_mag_thresh_thresh_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19040L);
    system_sw_write_32(base + 0x19040L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_frame_stitch_lm_mc_mag_thresh_thresh_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x19040L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: lm_mc_mag_thresh_offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_LM_MC_MAG_THRESH_OFFSET_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_MAG_THRESH_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_MAG_THRESH_OFFSET_OFFSET (0x1bc)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_MAG_THRESH_OFFSET_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_lm_mc_mag_thresh_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19044L);
    system_sw_write_32(base + 0x19044L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_frame_stitch_lm_mc_mag_thresh_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19044L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: lm_mc_mag_lblend_thresh
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_LM_MC_MAG_LBLEND_THRESH_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_MAG_LBLEND_THRESH_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_MAG_LBLEND_THRESH_OFFSET (0x1bc)
#define ACAMERA_ISP_FRAME_STITCH_LM_MC_MAG_LBLEND_THRESH_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_lm_mc_mag_lblend_thresh_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19044L);
    system_sw_write_32(base + 0x19044L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_frame_stitch_lm_mc_mag_lblend_thresh_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19044L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: MCoff WB offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_MCOFF_WB_OFFSET_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_WB_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_WB_OFFSET_OFFSET (0x1c0)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_WB_OFFSET_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_mcoff_wb_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19048L);
    system_sw_write_32(base + 0x19048L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_frame_stitch_mcoff_wb_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19048L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Exposure_mask_thresh
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//              Threshold for selection of exposure mask in blending regions.
//              Where the alpha value is above this value the shorter exposure will be indicated.
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_EXPOSURE_MASK_THRESH_DEFAULT (0x20)
#define ACAMERA_ISP_FRAME_STITCH_EXPOSURE_MASK_THRESH_DATASIZE (8)
#define ACAMERA_ISP_FRAME_STITCH_EXPOSURE_MASK_THRESH_OFFSET (0x1c0)
#define ACAMERA_ISP_FRAME_STITCH_EXPOSURE_MASK_THRESH_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_frame_stitch_exposure_mask_thresh_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19048L);
    system_sw_write_32(base + 0x19048L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_frame_stitch_exposure_mask_thresh_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19048L) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: bwb_select
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_BWB_SELECT_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_BWB_SELECT_DATASIZE (1)
#define ACAMERA_ISP_FRAME_STITCH_BWB_SELECT_OFFSET (0x1c4)
#define ACAMERA_ISP_FRAME_STITCH_BWB_SELECT_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_frame_stitch_bwb_select_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1904cL);
    system_sw_write_32(base + 0x1904cL, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_frame_stitch_bwb_select_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1904cL) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: use_3x3_max
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_USE_3X3_MAX_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_USE_3X3_MAX_DATASIZE (1)
#define ACAMERA_ISP_FRAME_STITCH_USE_3X3_MAX_OFFSET (0x1c4)
#define ACAMERA_ISP_FRAME_STITCH_USE_3X3_MAX_MASK (0x2)

// args: data (1-bit)
static __inline void acamera_isp_frame_stitch_use_3x3_max_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1904cL);
    system_sw_write_32(base + 0x1904cL, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
}
static __inline uint8_t acamera_isp_frame_stitch_use_3x3_max_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1904cL) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: mcoff mode enable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_MCOFF_MODE_ENABLE_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_MODE_ENABLE_DATASIZE (1)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_MODE_ENABLE_OFFSET (0x1c4)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_MODE_ENABLE_MASK (0x100)

// args: data (1-bit)
static __inline void acamera_isp_frame_stitch_mcoff_mode_enable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1904cL);
    system_sw_write_32(base + 0x1904cL, (((uint32_t) (data & 0x1)) << 8) | (curr & 0xfffffeff));
}
static __inline uint8_t acamera_isp_frame_stitch_mcoff_mode_enable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1904cL) & 0x100) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: lm_alg_select
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//              Select which L/M stitching algorithm to use.
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_LM_ALG_SELECT_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_LM_ALG_SELECT_DATASIZE (1)
#define ACAMERA_ISP_FRAME_STITCH_LM_ALG_SELECT_OFFSET (0x1c4)
#define ACAMERA_ISP_FRAME_STITCH_LM_ALG_SELECT_MASK (0x10000)

// args: data (1-bit)
static __inline void acamera_isp_frame_stitch_lm_alg_select_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1904cL);
    system_sw_write_32(base + 0x1904cL, (((uint32_t) (data & 0x1)) << 16) | (curr & 0xfffeffff));
}
static __inline uint8_t acamera_isp_frame_stitch_lm_alg_select_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1904cL) & 0x10000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: MCoff NC Enable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_MCOFF_NC_ENABLE_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_NC_ENABLE_DATASIZE (1)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_NC_ENABLE_OFFSET (0x1c4)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_NC_ENABLE_MASK (0x4)

// args: data (1-bit)
static __inline void acamera_isp_frame_stitch_mcoff_nc_enable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1904cL);
    system_sw_write_32(base + 0x1904cL, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
}
static __inline uint8_t acamera_isp_frame_stitch_mcoff_nc_enable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1904cL) & 0x4) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: MCoff L max
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_MCOFF_L_MAX_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_L_MAX_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_L_MAX_OFFSET (0x1c8)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_L_MAX_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_mcoff_l_max_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19050L);
    system_sw_write_32(base + 0x19050L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_frame_stitch_mcoff_l_max_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19050L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: MCoff M max
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_MCOFF_M_MAX_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_M_MAX_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_M_MAX_OFFSET (0x1c8)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_M_MAX_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_mcoff_m_max_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19050L);
    system_sw_write_32(base + 0x19050L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_frame_stitch_mcoff_m_max_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19050L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: MCoff S max
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_MCOFF_S_MAX_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_S_MAX_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_S_MAX_OFFSET (0x1cc)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_S_MAX_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_mcoff_s_max_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19054L);
    system_sw_write_32(base + 0x19054L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_frame_stitch_mcoff_s_max_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19054L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: MCoff vs max
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_MCOFF_VS_MAX_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_VS_MAX_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_VS_MAX_OFFSET (0x1cc)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_VS_MAX_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_mcoff_vs_max_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19054L);
    system_sw_write_32(base + 0x19054L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_frame_stitch_mcoff_vs_max_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19054L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: MCoff L scaler
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_MCOFF_L_SCALER_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_L_SCALER_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_L_SCALER_OFFSET (0x1d0)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_L_SCALER_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_mcoff_l_scaler_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19058L);
    system_sw_write_32(base + 0x19058L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_frame_stitch_mcoff_l_scaler_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19058L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: MCoff LM scaler
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_MCOFF_LM_SCALER_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_LM_SCALER_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_LM_SCALER_OFFSET (0x1d0)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_LM_SCALER_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_mcoff_lm_scaler_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19058L);
    system_sw_write_32(base + 0x19058L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_frame_stitch_mcoff_lm_scaler_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19058L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: MCoff LMS scaler
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_MCOFF_LMS_SCALER_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_LMS_SCALER_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_LMS_SCALER_OFFSET (0x1d4)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_LMS_SCALER_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_mcoff_lms_scaler_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1905cL);
    system_sw_write_32(base + 0x1905cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_frame_stitch_mcoff_lms_scaler_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1905cL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: MCoff NC thresh low
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_MCOFF_NC_THRESH_LOW_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_NC_THRESH_LOW_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_NC_THRESH_LOW_OFFSET (0x1d4)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_NC_THRESH_LOW_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_mcoff_nc_thresh_low_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1905cL);
    system_sw_write_32(base + 0x1905cL, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_frame_stitch_mcoff_nc_thresh_low_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1905cL) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: MCoff NC thresh high
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_MCOFF_NC_THRESH_HIGH_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_NC_THRESH_HIGH_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_NC_THRESH_HIGH_OFFSET (0x1d8)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_NC_THRESH_HIGH_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_mcoff_nc_thresh_high_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19060L);
    system_sw_write_32(base + 0x19060L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_frame_stitch_mcoff_nc_thresh_high_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19060L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: MCoff NC scale
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_MCOFF_NC_SCALE_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_NC_SCALE_DATASIZE (12)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_NC_SCALE_OFFSET (0x1d8)
#define ACAMERA_ISP_FRAME_STITCH_MCOFF_NC_SCALE_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_frame_stitch_mcoff_nc_scale_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19060L);
    system_sw_write_32(base + 0x19060L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_frame_stitch_mcoff_nc_scale_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19060L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Group: frame stitch NP LUT VS
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise profile for short exposure data at frame stitch
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Weight lut
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise profile LUT.  Calculated during calibration process.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_NP_LUT_VS_WEIGHT_LUT_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_NP_LUT_VS_WEIGHT_LUT_DATASIZE (8)
#define ACAMERA_ISP_FRAME_STITCH_NP_LUT_VS_WEIGHT_LUT_OFFSET (0x1dc)
#define ACAMERA_ISP_FRAME_STITCH_NP_LUT_VS_WEIGHT_LUT_MASK (0xff)

// index (0-127), args: data (8-bit)
static __inline void acamera_isp_frame_stitch_np_lut_vs_weight_lut_write( uintptr_t base, uint32_t index,uint8_t data) {
    uintptr_t addr = base + 0x19064L + (index & 0xFFFFFFFC);
    uint8_t offset = (index & 3) << 3;
    uint32_t curr = system_sw_read_32(addr);
    system_sw_write_32(addr, ((uint32_t)data << offset) | (curr & ~(0xFF << offset)));
}
static __inline uint8_t acamera_isp_frame_stitch_np_lut_vs_weight_lut_read( uintptr_t base, uint32_t index) {
    uintptr_t addr = base + 0x19064L + (index & 0xFFFFFFFC);
    uint8_t offset = (index & 3) << 3;
    return (uint8_t)(system_sw_read_32(addr) >> offset);
}
// ------------------------------------------------------------------------------ //
// Group: frame stitch NP LUT S
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise profile for med2 exposure data at frame stitch
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Weight lut
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise profile LUT.  Calculated during calibration process.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_NP_LUT_S_WEIGHT_LUT_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_NP_LUT_S_WEIGHT_LUT_DATASIZE (8)
#define ACAMERA_ISP_FRAME_STITCH_NP_LUT_S_WEIGHT_LUT_OFFSET (0x25c)
#define ACAMERA_ISP_FRAME_STITCH_NP_LUT_S_WEIGHT_LUT_MASK (0xff)

// index (0-127), args: data (8-bit)
static __inline void acamera_isp_frame_stitch_np_lut_s_weight_lut_write( uintptr_t base, uint32_t index,uint8_t data) {
    uintptr_t addr = base + 0x190e4L + (index & 0xFFFFFFFC);
    uint8_t offset = (index & 3) << 3;
    uint32_t curr = system_sw_read_32(addr);
    system_sw_write_32(addr, ((uint32_t)data << offset) | (curr & ~(0xFF << offset)));
}
static __inline uint8_t acamera_isp_frame_stitch_np_lut_s_weight_lut_read( uintptr_t base, uint32_t index) {
    uintptr_t addr = base + 0x190e4L + (index & 0xFFFFFFFC);
    uint8_t offset = (index & 3) << 3;
    return (uint8_t)(system_sw_read_32(addr) >> offset);
}
// ------------------------------------------------------------------------------ //
// Group: frame stitch NP LUT M
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise profile for med1 exposure data at frame stitch
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Weight lut
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise profile LUT.  Calculated during calibration process.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_NP_LUT_M_WEIGHT_LUT_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_NP_LUT_M_WEIGHT_LUT_DATASIZE (8)
#define ACAMERA_ISP_FRAME_STITCH_NP_LUT_M_WEIGHT_LUT_OFFSET (0x2dc)
#define ACAMERA_ISP_FRAME_STITCH_NP_LUT_M_WEIGHT_LUT_MASK (0xff)

// index (0-127), args: data (8-bit)
static __inline void acamera_isp_frame_stitch_np_lut_m_weight_lut_write( uintptr_t base, uint32_t index,uint8_t data) {
    uintptr_t addr = base + 0x19164L + (index & 0xFFFFFFFC);
    uint8_t offset = (index & 3) << 3;
    uint32_t curr = system_sw_read_32(addr);
    system_sw_write_32(addr, ((uint32_t)data << offset) | (curr & ~(0xFF << offset)));
}
static __inline uint8_t acamera_isp_frame_stitch_np_lut_m_weight_lut_read( uintptr_t base, uint32_t index) {
    uintptr_t addr = base + 0x19164L + (index & 0xFFFFFFFC);
    uint8_t offset = (index & 3) << 3;
    return (uint8_t)(system_sw_read_32(addr) >> offset);
}
// ------------------------------------------------------------------------------ //
// Group: frame stitch NP LUT L
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise profile for long exposure data at frame stitch
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Weight lut
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise profile LUT.  Calculated during calibration process.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FRAME_STITCH_NP_LUT_L_WEIGHT_LUT_DEFAULT (0x0)
#define ACAMERA_ISP_FRAME_STITCH_NP_LUT_L_WEIGHT_LUT_DATASIZE (8)
#define ACAMERA_ISP_FRAME_STITCH_NP_LUT_L_WEIGHT_LUT_OFFSET (0x35c)
#define ACAMERA_ISP_FRAME_STITCH_NP_LUT_L_WEIGHT_LUT_MASK (0xff)

// index (0-127), args: data (8-bit)
static __inline void acamera_isp_frame_stitch_np_lut_l_weight_lut_write( uintptr_t base, uint32_t index,uint8_t data) {
    uintptr_t addr = base + 0x191e4L + (index & 0xFFFFFFFC);
    uint8_t offset = (index & 3) << 3;
    uint32_t curr = system_sw_read_32(addr);
    system_sw_write_32(addr, ((uint32_t)data << offset) | (curr & ~(0xFF << offset)));
}
static __inline uint8_t acamera_isp_frame_stitch_np_lut_l_weight_lut_read( uintptr_t base, uint32_t index) {
    uintptr_t addr = base + 0x191e4L + (index & 0xFFFFFFFC);
    uint8_t offset = (index & 3) << 3;
    return (uint8_t)(system_sw_read_32(addr) >> offset);
}
// ------------------------------------------------------------------------------ //
// Group: decompander0
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Frontend lookup (for companded WDR sensor inputs)
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Enable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Frontend lookup0 enable: 0=off 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DECOMPANDER0_ENABLE_DEFAULT (0)
#define ACAMERA_ISP_DECOMPANDER0_ENABLE_DATASIZE (1)
#define ACAMERA_ISP_DECOMPANDER0_ENABLE_OFFSET (0x3dc)
#define ACAMERA_ISP_DECOMPANDER0_ENABLE_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_decompander0_enable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19264L);
    system_sw_write_32(base + 0x19264L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_decompander0_enable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19264L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Offset Mode
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//          Lookup0 reflection mode for black offset region
//          0 = Manual curve reflection
//          1 = Automatic curve reflection
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DECOMPANDER0_OFFSET_MODE_DEFAULT (0)
#define ACAMERA_ISP_DECOMPANDER0_OFFSET_MODE_DATASIZE (1)
#define ACAMERA_ISP_DECOMPANDER0_OFFSET_MODE_OFFSET (0x3dc)
#define ACAMERA_ISP_DECOMPANDER0_OFFSET_MODE_MASK (0x10)

// args: data (1-bit)
static __inline void acamera_isp_decompander0_offset_mode_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19264L);
    system_sw_write_32(base + 0x19264L, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
}
static __inline uint8_t acamera_isp_decompander0_offset_mode_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19264L) & 0x10) >> 4);
}
// ------------------------------------------------------------------------------ //
// Group: decompander1
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Frontend lookup (for companded WDR sensor inputs)
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Enable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Frontend lookup0 enable: 0=off 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DECOMPANDER1_ENABLE_DEFAULT (0)
#define ACAMERA_ISP_DECOMPANDER1_ENABLE_DATASIZE (1)
#define ACAMERA_ISP_DECOMPANDER1_ENABLE_OFFSET (0x3e0)
#define ACAMERA_ISP_DECOMPANDER1_ENABLE_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_decompander1_enable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19268L);
    system_sw_write_32(base + 0x19268L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_decompander1_enable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19268L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Offset Mode
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//          Lookup0 reflection mode for black offset region
//          0 = Manual curve reflection
//          1 = Automatic curve reflection
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DECOMPANDER1_OFFSET_MODE_DEFAULT (0)
#define ACAMERA_ISP_DECOMPANDER1_OFFSET_MODE_DATASIZE (1)
#define ACAMERA_ISP_DECOMPANDER1_OFFSET_MODE_OFFSET (0x3e0)
#define ACAMERA_ISP_DECOMPANDER1_OFFSET_MODE_MASK (0x10)

// args: data (1-bit)
static __inline void acamera_isp_decompander1_offset_mode_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19268L);
    system_sw_write_32(base + 0x19268L, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
}
static __inline uint8_t acamera_isp_decompander1_offset_mode_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19268L) & 0x10) >> 4);
}
// ------------------------------------------------------------------------------ //
// Group: digital gain
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Digital gain for RAW sensor data
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Gain
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Gain applied to data in 5.8 format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DIGITAL_GAIN_GAIN_DEFAULT (0x100)
#define ACAMERA_ISP_DIGITAL_GAIN_GAIN_DATASIZE (13)
#define ACAMERA_ISP_DIGITAL_GAIN_GAIN_OFFSET (0x3e4)
#define ACAMERA_ISP_DIGITAL_GAIN_GAIN_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_digital_gain_gain_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1926cL);
    system_sw_write_32(base + 0x1926cL, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_digital_gain_gain_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1926cL) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Data black level
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DIGITAL_GAIN_OFFSET_DEFAULT (0x000)
#define ACAMERA_ISP_DIGITAL_GAIN_OFFSET_DATASIZE (20)
#define ACAMERA_ISP_DIGITAL_GAIN_OFFSET_OFFSET (0x3e8)
#define ACAMERA_ISP_DIGITAL_GAIN_OFFSET_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_digital_gain_offset_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19270L);
    system_sw_write_32(base + 0x19270L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_digital_gain_offset_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x19270L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Group: sensor offset fe
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset subtraction for each color channel and exposure
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: offset 00
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset for color channel 00 (R)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SENSOR_OFFSET_FE_OFFSET_00_DEFAULT (0x00)
#define ACAMERA_ISP_SENSOR_OFFSET_FE_OFFSET_00_DATASIZE (20)
#define ACAMERA_ISP_SENSOR_OFFSET_FE_OFFSET_00_OFFSET (0x3ec)
#define ACAMERA_ISP_SENSOR_OFFSET_FE_OFFSET_00_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_sensor_offset_fe_offset_00_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19274L);
    system_sw_write_32(base + 0x19274L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_sensor_offset_fe_offset_00_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x19274L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: offset 01
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset for color channel 01 (Gr)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SENSOR_OFFSET_FE_OFFSET_01_DEFAULT (0x00)
#define ACAMERA_ISP_SENSOR_OFFSET_FE_OFFSET_01_DATASIZE (20)
#define ACAMERA_ISP_SENSOR_OFFSET_FE_OFFSET_01_OFFSET (0x3f0)
#define ACAMERA_ISP_SENSOR_OFFSET_FE_OFFSET_01_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_sensor_offset_fe_offset_01_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19278L);
    system_sw_write_32(base + 0x19278L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_sensor_offset_fe_offset_01_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x19278L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: offset 10
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset for color channel 10 (Gb)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SENSOR_OFFSET_FE_OFFSET_10_DEFAULT (0x00)
#define ACAMERA_ISP_SENSOR_OFFSET_FE_OFFSET_10_DATASIZE (20)
#define ACAMERA_ISP_SENSOR_OFFSET_FE_OFFSET_10_OFFSET (0x3f4)
#define ACAMERA_ISP_SENSOR_OFFSET_FE_OFFSET_10_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_sensor_offset_fe_offset_10_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1927cL);
    system_sw_write_32(base + 0x1927cL, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_sensor_offset_fe_offset_10_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x1927cL) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: offset 11
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset for color channel 11 (B)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SENSOR_OFFSET_FE_OFFSET_11_DEFAULT (0x00)
#define ACAMERA_ISP_SENSOR_OFFSET_FE_OFFSET_11_DATASIZE (20)
#define ACAMERA_ISP_SENSOR_OFFSET_FE_OFFSET_11_OFFSET (0x3f8)
#define ACAMERA_ISP_SENSOR_OFFSET_FE_OFFSET_11_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_sensor_offset_fe_offset_11_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19280L);
    system_sw_write_32(base + 0x19280L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_sensor_offset_fe_offset_11_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x19280L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Group: sqrt
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// sensor offset for the sqrt module
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: black_level_in
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// input Data black level
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SQRT_BLACK_LEVEL_IN_DEFAULT (0x000)
#define ACAMERA_ISP_SQRT_BLACK_LEVEL_IN_DATASIZE (20)
#define ACAMERA_ISP_SQRT_BLACK_LEVEL_IN_OFFSET (0x3fc)
#define ACAMERA_ISP_SQRT_BLACK_LEVEL_IN_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_sqrt_black_level_in_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19284L);
    system_sw_write_32(base + 0x19284L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_sqrt_black_level_in_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x19284L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: black_level_out
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// output Data black level
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SQRT_BLACK_LEVEL_OUT_DEFAULT (0x000)
#define ACAMERA_ISP_SQRT_BLACK_LEVEL_OUT_DATASIZE (16)
#define ACAMERA_ISP_SQRT_BLACK_LEVEL_OUT_OFFSET (0x400)
#define ACAMERA_ISP_SQRT_BLACK_LEVEL_OUT_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_sqrt_black_level_out_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19288L);
    system_sw_write_32(base + 0x19288L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_sqrt_black_level_out_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19288L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Group: raw frontend
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// RAW frontend processing
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: ge enable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Green equalization enable: 0=off, 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RAW_FRONTEND_GE_ENABLE_DEFAULT (1)
#define ACAMERA_ISP_RAW_FRONTEND_GE_ENABLE_DATASIZE (1)
#define ACAMERA_ISP_RAW_FRONTEND_GE_ENABLE_OFFSET (0x404)
#define ACAMERA_ISP_RAW_FRONTEND_GE_ENABLE_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_raw_frontend_ge_enable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1928cL);
    system_sw_write_32(base + 0x1928cL, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_raw_frontend_ge_enable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1928cL) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: dp enable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Dynamic Defect Pixel enable: 0=off, 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RAW_FRONTEND_DP_ENABLE_DEFAULT (1)
#define ACAMERA_ISP_RAW_FRONTEND_DP_ENABLE_DATASIZE (1)
#define ACAMERA_ISP_RAW_FRONTEND_DP_ENABLE_OFFSET (0x404)
#define ACAMERA_ISP_RAW_FRONTEND_DP_ENABLE_MASK (0x4)

// args: data (1-bit)
static __inline void acamera_isp_raw_frontend_dp_enable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1928cL);
    system_sw_write_32(base + 0x1928cL, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
}
static __inline uint8_t acamera_isp_raw_frontend_dp_enable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1928cL) & 0x4) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: show dynamic defect pixel
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Show Defect Pixel: 0=off, 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RAW_FRONTEND_SHOW_DYNAMIC_DEFECT_PIXEL_DEFAULT (0)
#define ACAMERA_ISP_RAW_FRONTEND_SHOW_DYNAMIC_DEFECT_PIXEL_DATASIZE (1)
#define ACAMERA_ISP_RAW_FRONTEND_SHOW_DYNAMIC_DEFECT_PIXEL_OFFSET (0x404)
#define ACAMERA_ISP_RAW_FRONTEND_SHOW_DYNAMIC_DEFECT_PIXEL_MASK (0x8)

// args: data (1-bit)
static __inline void acamera_isp_raw_frontend_show_dynamic_defect_pixel_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1928cL);
    system_sw_write_32(base + 0x1928cL, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
}
static __inline uint8_t acamera_isp_raw_frontend_show_dynamic_defect_pixel_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1928cL) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: dark disable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Disable detection of dark pixels
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RAW_FRONTEND_DARK_DISABLE_DEFAULT (0)
#define ACAMERA_ISP_RAW_FRONTEND_DARK_DISABLE_DATASIZE (1)
#define ACAMERA_ISP_RAW_FRONTEND_DARK_DISABLE_OFFSET (0x404)
#define ACAMERA_ISP_RAW_FRONTEND_DARK_DISABLE_MASK (0x40)

// args: data (1-bit)
static __inline void acamera_isp_raw_frontend_dark_disable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1928cL);
    system_sw_write_32(base + 0x1928cL, (((uint32_t) (data & 0x1)) << 6) | (curr & 0xffffffbf));
}
static __inline uint8_t acamera_isp_raw_frontend_dark_disable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1928cL) & 0x40) >> 6);
}
// ------------------------------------------------------------------------------ //
// Register: bright disable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Disable detection of bright pixels
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RAW_FRONTEND_BRIGHT_DISABLE_DEFAULT (0)
#define ACAMERA_ISP_RAW_FRONTEND_BRIGHT_DISABLE_DATASIZE (1)
#define ACAMERA_ISP_RAW_FRONTEND_BRIGHT_DISABLE_OFFSET (0x404)
#define ACAMERA_ISP_RAW_FRONTEND_BRIGHT_DISABLE_MASK (0x80)

// args: data (1-bit)
static __inline void acamera_isp_raw_frontend_bright_disable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1928cL);
    system_sw_write_32(base + 0x1928cL, (((uint32_t) (data & 0x1)) << 7) | (curr & 0xffffff7f));
}
static __inline uint8_t acamera_isp_raw_frontend_bright_disable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1928cL) & 0x80) >> 7);
}
// ------------------------------------------------------------------------------ //
// Register: debug sel
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Debug selection port
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RAW_FRONTEND_DEBUG_SEL_DEFAULT (0x0)
#define ACAMERA_ISP_RAW_FRONTEND_DEBUG_SEL_DATASIZE (16)
#define ACAMERA_ISP_RAW_FRONTEND_DEBUG_SEL_OFFSET (0x408)
#define ACAMERA_ISP_RAW_FRONTEND_DEBUG_SEL_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_raw_frontend_debug_sel_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19290L);
    system_sw_write_32(base + 0x19290L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_raw_frontend_debug_sel_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19290L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: dp slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Slope for HP Mask function
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RAW_FRONTEND_DP_SLOPE_DEFAULT (0x200)
#define ACAMERA_ISP_RAW_FRONTEND_DP_SLOPE_DATASIZE (12)
#define ACAMERA_ISP_RAW_FRONTEND_DP_SLOPE_OFFSET (0x40c)
#define ACAMERA_ISP_RAW_FRONTEND_DP_SLOPE_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_raw_frontend_dp_slope_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19294L);
    system_sw_write_32(base + 0x19294L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_raw_frontend_dp_slope_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19294L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: dp threshold
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Defect pixel threshold. 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RAW_FRONTEND_DP_THRESHOLD_DEFAULT (0x040)
#define ACAMERA_ISP_RAW_FRONTEND_DP_THRESHOLD_DATASIZE (12)
#define ACAMERA_ISP_RAW_FRONTEND_DP_THRESHOLD_OFFSET (0x40c)
#define ACAMERA_ISP_RAW_FRONTEND_DP_THRESHOLD_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_raw_frontend_dp_threshold_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19294L);
    system_sw_write_32(base + 0x19294L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_raw_frontend_dp_threshold_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19294L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: dpdev threshold
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Controls the aggressiveness of the dynamic defect pixel correction near edges. 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RAW_FRONTEND_HPDEV_THRESHOLD_DEFAULT (0x266)
#define ACAMERA_ISP_RAW_FRONTEND_HPDEV_THRESHOLD_DATASIZE (16)
#define ACAMERA_ISP_RAW_FRONTEND_HPDEV_THRESHOLD_OFFSET (0x410)
#define ACAMERA_ISP_RAW_FRONTEND_HPDEV_THRESHOLD_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_raw_frontend_hpdev_threshold_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19298L);
    system_sw_write_32(base + 0x19298L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_raw_frontend_hpdev_threshold_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19298L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: dp blend
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Controls blending between non-directional and directional replacement values in dynamic defect pixel correction.
//        0x00 Replace detected defects with non-directional replacement value
//        0xFF Replace detected defects with directional replacement value
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RAW_FRONTEND_HP_BLEND_DEFAULT (0x00)
#define ACAMERA_ISP_RAW_FRONTEND_HP_BLEND_DATASIZE (8)
#define ACAMERA_ISP_RAW_FRONTEND_HP_BLEND_OFFSET (0x410)
#define ACAMERA_ISP_RAW_FRONTEND_HP_BLEND_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_raw_frontend_hp_blend_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19298L);
    system_sw_write_32(base + 0x19298L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_raw_frontend_hp_blend_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19298L) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: ge strength
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Controls strength of Green equalization.  Set during calibration.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RAW_FRONTEND_GE_STRENGTH_DEFAULT (0x00)
#define ACAMERA_ISP_RAW_FRONTEND_GE_STRENGTH_DATASIZE (8)
#define ACAMERA_ISP_RAW_FRONTEND_GE_STRENGTH_OFFSET (0x414)
#define ACAMERA_ISP_RAW_FRONTEND_GE_STRENGTH_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_raw_frontend_ge_strength_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1929cL);
    system_sw_write_32(base + 0x1929cL, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_raw_frontend_ge_strength_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1929cL) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: ge threshold
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// green equalization threshold
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RAW_FRONTEND_GE_THRESHOLD_DEFAULT (0x400)
#define ACAMERA_ISP_RAW_FRONTEND_GE_THRESHOLD_DATASIZE (16)
#define ACAMERA_ISP_RAW_FRONTEND_GE_THRESHOLD_OFFSET (0x414)
#define ACAMERA_ISP_RAW_FRONTEND_GE_THRESHOLD_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_raw_frontend_ge_threshold_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1929cL);
    system_sw_write_32(base + 0x1929cL, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_raw_frontend_ge_threshold_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1929cL) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: ge slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Slope for GE Mask function
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RAW_FRONTEND_GE_SLOPE_DEFAULT (0x0AA)
#define ACAMERA_ISP_RAW_FRONTEND_GE_SLOPE_DATASIZE (12)
#define ACAMERA_ISP_RAW_FRONTEND_GE_SLOPE_OFFSET (0x418)
#define ACAMERA_ISP_RAW_FRONTEND_GE_SLOPE_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_raw_frontend_ge_slope_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x192a0L);
    system_sw_write_32(base + 0x192a0L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_raw_frontend_ge_slope_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x192a0L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: ge sens
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Controls the sensitivity of green equalization to edges.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RAW_FRONTEND_GE_SENS_DEFAULT (0x80)
#define ACAMERA_ISP_RAW_FRONTEND_GE_SENS_DATASIZE (8)
#define ACAMERA_ISP_RAW_FRONTEND_GE_SENS_OFFSET (0x418)
#define ACAMERA_ISP_RAW_FRONTEND_GE_SENS_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_raw_frontend_ge_sens_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x192a0L);
    system_sw_write_32(base + 0x192a0L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_raw_frontend_ge_sens_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x192a0L) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: line thresh
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Controls the directional nature of the dynamic defect pixel correction near edges..
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RAW_FRONTEND_LINE_THRESH_DEFAULT (0x150)
#define ACAMERA_ISP_RAW_FRONTEND_LINE_THRESH_DATASIZE (16)
#define ACAMERA_ISP_RAW_FRONTEND_LINE_THRESH_OFFSET (0x41c)
#define ACAMERA_ISP_RAW_FRONTEND_LINE_THRESH_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_raw_frontend_line_thresh_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x192a4L);
    system_sw_write_32(base + 0x192a4L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_raw_frontend_line_thresh_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x192a4L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Sigma In
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Manual override of noise estimation 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RAW_FRONTEND_SIGMA_IN_DEFAULT (0x00)
#define ACAMERA_ISP_RAW_FRONTEND_SIGMA_IN_DATASIZE (16)
#define ACAMERA_ISP_RAW_FRONTEND_SIGMA_IN_OFFSET (0x41c)
#define ACAMERA_ISP_RAW_FRONTEND_SIGMA_IN_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_raw_frontend_sigma_in_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x192a4L);
    system_sw_write_32(base + 0x192a4L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_raw_frontend_sigma_in_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x192a4L) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Thresh Short
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise threshold for short exposure data
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RAW_FRONTEND_THRESH_SHORT_DEFAULT (0x00)
#define ACAMERA_ISP_RAW_FRONTEND_THRESH_SHORT_DATASIZE (8)
#define ACAMERA_ISP_RAW_FRONTEND_THRESH_SHORT_OFFSET (0x420)
#define ACAMERA_ISP_RAW_FRONTEND_THRESH_SHORT_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_raw_frontend_thresh_short_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x192a8L);
    system_sw_write_32(base + 0x192a8L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_raw_frontend_thresh_short_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x192a8L) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Thresh Long
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise threshold for long exposure data
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RAW_FRONTEND_THRESH_LONG_DEFAULT (0x30)
#define ACAMERA_ISP_RAW_FRONTEND_THRESH_LONG_DATASIZE (8)
#define ACAMERA_ISP_RAW_FRONTEND_THRESH_LONG_OFFSET (0x420)
#define ACAMERA_ISP_RAW_FRONTEND_THRESH_LONG_MASK (0xff00)

// args: data (8-bit)
static __inline void acamera_isp_raw_frontend_thresh_long_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x192a8L);
    system_sw_write_32(base + 0x192a8L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
}
static __inline uint8_t acamera_isp_raw_frontend_thresh_long_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x192a8L) & 0xff00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Group: raw frontend np
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise profile controls for RAW frontend
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Exp Thresh
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Threshold for determining long/short exposure data
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RAW_FRONTEND_NP_EXP_THRESH_DEFAULT (0xffff)
#define ACAMERA_ISP_RAW_FRONTEND_NP_EXP_THRESH_DATASIZE (16)
#define ACAMERA_ISP_RAW_FRONTEND_NP_EXP_THRESH_OFFSET (0x424)
#define ACAMERA_ISP_RAW_FRONTEND_NP_EXP_THRESH_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_raw_frontend_np_exp_thresh_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x192acL);
    system_sw_write_32(base + 0x192acL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_raw_frontend_np_exp_thresh_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x192acL) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Short Ratio
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Multiplier applied to short exposure data for noise profile calculation
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RAW_FRONTEND_NP_SHORT_RATIO_DEFAULT (0x20)
#define ACAMERA_ISP_RAW_FRONTEND_NP_SHORT_RATIO_DATASIZE (8)
#define ACAMERA_ISP_RAW_FRONTEND_NP_SHORT_RATIO_OFFSET (0x428)
#define ACAMERA_ISP_RAW_FRONTEND_NP_SHORT_RATIO_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_raw_frontend_np_short_ratio_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x192b0L);
    system_sw_write_32(base + 0x192b0L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_raw_frontend_np_short_ratio_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x192b0L) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Long Ratio
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Multiplier applied to long exposure data for noise profile calculation
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RAW_FRONTEND_NP_LONG_RATIO_DEFAULT (0x04)
#define ACAMERA_ISP_RAW_FRONTEND_NP_LONG_RATIO_DATASIZE (8)
#define ACAMERA_ISP_RAW_FRONTEND_NP_LONG_RATIO_OFFSET (0x428)
#define ACAMERA_ISP_RAW_FRONTEND_NP_LONG_RATIO_MASK (0xff00)

// args: data (8-bit)
static __inline void acamera_isp_raw_frontend_np_long_ratio_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x192b0L);
    system_sw_write_32(base + 0x192b0L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
}
static __inline uint8_t acamera_isp_raw_frontend_np_long_ratio_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x192b0L) & 0xff00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: NP off
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise profile black level offset
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RAW_FRONTEND_NP_NP_OFF_DEFAULT (0)
#define ACAMERA_ISP_RAW_FRONTEND_NP_NP_OFF_DATASIZE (7)
#define ACAMERA_ISP_RAW_FRONTEND_NP_NP_OFF_OFFSET (0x42c)
#define ACAMERA_ISP_RAW_FRONTEND_NP_NP_OFF_MASK (0x7f)

// args: data (7-bit)
static __inline void acamera_isp_raw_frontend_np_np_off_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x192b4L);
    system_sw_write_32(base + 0x192b4L, (((uint32_t) (data & 0x7f)) << 0) | (curr & 0xffffff80));
}
static __inline uint8_t acamera_isp_raw_frontend_np_np_off_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x192b4L) & 0x7f) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: NP off reflect
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//          Defines how values below black level are obtained.
//          0: Repeat the first table entry.
//          1: Reflect the noise profile curve below black level.
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RAW_FRONTEND_NP_NP_OFF_REFLECT_DEFAULT (0)
#define ACAMERA_ISP_RAW_FRONTEND_NP_NP_OFF_REFLECT_DATASIZE (1)
#define ACAMERA_ISP_RAW_FRONTEND_NP_NP_OFF_REFLECT_OFFSET (0x42c)
#define ACAMERA_ISP_RAW_FRONTEND_NP_NP_OFF_REFLECT_MASK (0x100)

// args: data (1-bit)
static __inline void acamera_isp_raw_frontend_np_np_off_reflect_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x192b4L);
    system_sw_write_32(base + 0x192b4L, (((uint32_t) (data & 0x1)) << 8) | (curr & 0xfffffeff));
}
static __inline uint8_t acamera_isp_raw_frontend_np_np_off_reflect_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x192b4L) & 0x100) >> 8);
}
// ------------------------------------------------------------------------------ //
// Group: raw frontend np lut
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise profile controls for RAW frontend
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Weight lut
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise profile LUT.  Calculated during calibration process.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RAW_FRONTEND_NP_LUT_WEIGHT_LUT_DEFAULT (0x0)
#define ACAMERA_ISP_RAW_FRONTEND_NP_LUT_WEIGHT_LUT_DATASIZE (8)
#define ACAMERA_ISP_RAW_FRONTEND_NP_LUT_WEIGHT_LUT_OFFSET (0x430)
#define ACAMERA_ISP_RAW_FRONTEND_NP_LUT_WEIGHT_LUT_MASK (0xff)

// index (0-127), args: data (8-bit)
static __inline void acamera_isp_raw_frontend_np_lut_weight_lut_write( uintptr_t base, uint32_t index,uint8_t data) {
    uintptr_t addr = base + 0x192b8L + (index & 0xFFFFFFFC);
    uint8_t offset = (index & 3) << 3;
    uint32_t curr = system_sw_read_32(addr);
    system_sw_write_32(addr, ((uint32_t)data << offset) | (curr & ~(0xFF << offset)));
}
static __inline uint8_t acamera_isp_raw_frontend_np_lut_weight_lut_read( uintptr_t base, uint32_t index) {
    uintptr_t addr = base + 0x192b8L + (index & 0xFFFFFFFC);
    uint8_t offset = (index & 3) << 3;
    return (uint8_t)(system_sw_read_32(addr) >> offset);
}
// ------------------------------------------------------------------------------ //
// Group: defect pixel
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Detection and processing of static defect-pixels
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Pointer Reset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Reset static defect-pixel table pointer each frame - set this when defect-pixel table has been written from mcu
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEFECT_PIXEL_POINTER_RESET_DEFAULT (0)
#define ACAMERA_ISP_DEFECT_PIXEL_POINTER_RESET_DATASIZE (1)
#define ACAMERA_ISP_DEFECT_PIXEL_POINTER_RESET_OFFSET (0x4b0)
#define ACAMERA_ISP_DEFECT_PIXEL_POINTER_RESET_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_defect_pixel_pointer_reset_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19338L);
    system_sw_write_32(base + 0x19338L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_defect_pixel_pointer_reset_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19338L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Show Reference
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// For debug purposes.  Show reference values which are compared with actual values to detect bad pixels
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEFECT_PIXEL_SHOW_REFERENCE_DEFAULT (0)
#define ACAMERA_ISP_DEFECT_PIXEL_SHOW_REFERENCE_DATASIZE (1)
#define ACAMERA_ISP_DEFECT_PIXEL_SHOW_REFERENCE_OFFSET (0x4b4)
#define ACAMERA_ISP_DEFECT_PIXEL_SHOW_REFERENCE_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_defect_pixel_show_reference_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1933cL);
    system_sw_write_32(base + 0x1933cL, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_defect_pixel_show_reference_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1933cL) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Correction Enable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Correction enable: 0=off 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEFECT_PIXEL_CORRECTION_ENABLE_DEFAULT (0)
#define ACAMERA_ISP_DEFECT_PIXEL_CORRECTION_ENABLE_DATASIZE (1)
#define ACAMERA_ISP_DEFECT_PIXEL_CORRECTION_ENABLE_OFFSET (0x4b4)
#define ACAMERA_ISP_DEFECT_PIXEL_CORRECTION_ENABLE_MASK (0x2)

// args: data (1-bit)
static __inline void acamera_isp_defect_pixel_correction_enable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1933cL);
    system_sw_write_32(base + 0x1933cL, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
}
static __inline uint8_t acamera_isp_defect_pixel_correction_enable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1933cL) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: Show Static Defect Pixels
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Show which pixels have been detected as bad
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEFECT_PIXEL_SHOW_STATIC_DEFECT_PIXELS_DEFAULT (0)
#define ACAMERA_ISP_DEFECT_PIXEL_SHOW_STATIC_DEFECT_PIXELS_DATASIZE (1)
#define ACAMERA_ISP_DEFECT_PIXEL_SHOW_STATIC_DEFECT_PIXELS_OFFSET (0x4b4)
#define ACAMERA_ISP_DEFECT_PIXEL_SHOW_STATIC_DEFECT_PIXELS_MASK (0x4)

// args: data (1-bit)
static __inline void acamera_isp_defect_pixel_show_static_defect_pixels_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1933cL);
    system_sw_write_32(base + 0x1933cL, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
}
static __inline uint8_t acamera_isp_defect_pixel_show_static_defect_pixels_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1933cL) & 0x4) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: Detection enable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Starts detection 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEFECT_PIXEL_DETECTION_ENABLE_DEFAULT (0)
#define ACAMERA_ISP_DEFECT_PIXEL_DETECTION_ENABLE_DATASIZE (1)
#define ACAMERA_ISP_DEFECT_PIXEL_DETECTION_ENABLE_OFFSET (0x4b4)
#define ACAMERA_ISP_DEFECT_PIXEL_DETECTION_ENABLE_MASK (0x8)

// args: data (1-bit)
static __inline void acamera_isp_defect_pixel_detection_enable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1933cL);
    system_sw_write_32(base + 0x1933cL, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
}
static __inline uint8_t acamera_isp_defect_pixel_detection_enable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1933cL) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: Overflow
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Table overflow flag
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEFECT_PIXEL_OVERFLOW_DEFAULT (0x0)
#define ACAMERA_ISP_DEFECT_PIXEL_OVERFLOW_DATASIZE (1)
#define ACAMERA_ISP_DEFECT_PIXEL_OVERFLOW_OFFSET (0x4b8)
#define ACAMERA_ISP_DEFECT_PIXEL_OVERFLOW_MASK (0x1)

// args: data (1-bit)
static __inline uint8_t acamera_isp_defect_pixel_overflow_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19340L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Defect Pixel Count
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Number of defect-pixels detected
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEFECT_PIXEL_DEFECT_PIXEL_COUNT_DEFAULT (0x0)
#define ACAMERA_ISP_DEFECT_PIXEL_DEFECT_PIXEL_COUNT_DATASIZE (12)
#define ACAMERA_ISP_DEFECT_PIXEL_DEFECT_PIXEL_COUNT_OFFSET (0x4b8)
#define ACAMERA_ISP_DEFECT_PIXEL_DEFECT_PIXEL_COUNT_MASK (0x1ffe)

// args: data (12-bit)
static __inline uint16_t acamera_isp_defect_pixel_defect_pixel_count_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19340L) & 0x1ffe) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: Table Start
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Address of first defect-pixel in defect-pixel store
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEFECT_PIXEL_TABLE_START_DEFAULT (0x0)
#define ACAMERA_ISP_DEFECT_PIXEL_TABLE_START_DATASIZE (12)
#define ACAMERA_ISP_DEFECT_PIXEL_TABLE_START_OFFSET (0x4b8)
#define ACAMERA_ISP_DEFECT_PIXEL_TABLE_START_MASK (0xfff0000)

// args: data (12-bit)
static __inline uint16_t acamera_isp_defect_pixel_table_start_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19340L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Defect Pixel Count In
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Number of defect-pixels in the written table
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEFECT_PIXEL_DEFECT_PIXEL_COUNT_IN_DEFAULT (0x0)
#define ACAMERA_ISP_DEFECT_PIXEL_DEFECT_PIXEL_COUNT_IN_DATASIZE (12)
#define ACAMERA_ISP_DEFECT_PIXEL_DEFECT_PIXEL_COUNT_IN_OFFSET (0x4bc)
#define ACAMERA_ISP_DEFECT_PIXEL_DEFECT_PIXEL_COUNT_IN_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_defect_pixel_defect_pixel_count_in_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19344L);
    system_sw_write_32(base + 0x19344L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_defect_pixel_defect_pixel_count_in_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19344L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Group: sinter
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Spatial noise reduction
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Config1
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_CONFIG1_DEFAULT (0x0)
#define ACAMERA_ISP_SINTER_CONFIG1_DATASIZE (8)
#define ACAMERA_ISP_SINTER_CONFIG1_OFFSET (0x4c0)
#define ACAMERA_ISP_SINTER_CONFIG1_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_sinter_config1_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19348L);
    system_sw_write_32(base + 0x19348L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_sinter_config1_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19348L) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Enable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Sinter enable: 0=off 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_ENABLE_DEFAULT (1)
#define ACAMERA_ISP_SINTER_ENABLE_DATASIZE (1)
#define ACAMERA_ISP_SINTER_ENABLE_OFFSET (0x4c0)
#define ACAMERA_ISP_SINTER_ENABLE_MASK (0x10)

// args: data (1-bit)
static __inline void acamera_isp_sinter_enable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19348L);
    system_sw_write_32(base + 0x19348L, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
}
static __inline uint8_t acamera_isp_sinter_enable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19348L) & 0x10) >> 4);
}
// ------------------------------------------------------------------------------ //
// Register: View Filter
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// For debug purposes only. Set to zero for normal operation
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_VIEW_FILTER_DEFAULT (0)
#define ACAMERA_ISP_SINTER_VIEW_FILTER_DATASIZE (2)
#define ACAMERA_ISP_SINTER_VIEW_FILTER_OFFSET (0x4c0)
#define ACAMERA_ISP_SINTER_VIEW_FILTER_MASK (0x3)

// args: data (2-bit)
static __inline void acamera_isp_sinter_view_filter_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19348L);
    system_sw_write_32(base + 0x19348L, (((uint32_t) (data & 0x3)) << 0) | (curr & 0xfffffffc));
}
static __inline uint8_t acamera_isp_sinter_view_filter_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19348L) & 0x3) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Scale Mode
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// For debug purposes only. Set to 3 for normal operation
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_SCALE_MODE_DEFAULT (3)
#define ACAMERA_ISP_SINTER_SCALE_MODE_DATASIZE (2)
#define ACAMERA_ISP_SINTER_SCALE_MODE_OFFSET (0x4c0)
#define ACAMERA_ISP_SINTER_SCALE_MODE_MASK (0xc)
#define ACAMERA_ISP_SINTER_SCALE_MODE_USE_FILTER_0_ONLY (0)
#define ACAMERA_ISP_SINTER_SCALE_MODE_USE_FILTERS_0_AND_2_ONLY (1)
#define ACAMERA_ISP_SINTER_SCALE_MODE_USE_FILTERS_0_2_AND_4_ONLY (2)
#define ACAMERA_ISP_SINTER_SCALE_MODE_USE_ALL_FILTERS (3)

// args: data (2-bit)
static __inline void acamera_isp_sinter_scale_mode_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19348L);
    system_sw_write_32(base + 0x19348L, (((uint32_t) (data & 0x3)) << 2) | (curr & 0xfffffff3));
}
static __inline uint8_t acamera_isp_sinter_scale_mode_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19348L) & 0xc) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: Filter select
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Sinter filter fine tuning.  Should not be modified from suggested values.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_FILTER_SELECT_DEFAULT (0)
#define ACAMERA_ISP_SINTER_FILTER_SELECT_DATASIZE (1)
#define ACAMERA_ISP_SINTER_FILTER_SELECT_OFFSET (0x4c0)
#define ACAMERA_ISP_SINTER_FILTER_SELECT_MASK (0x20)

// args: data (1-bit)
static __inline void acamera_isp_sinter_filter_select_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19348L);
    system_sw_write_32(base + 0x19348L, (((uint32_t) (data & 0x1)) << 5) | (curr & 0xffffffdf));
}
static __inline uint8_t acamera_isp_sinter_filter_select_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19348L) & 0x20) >> 5);
}
// ------------------------------------------------------------------------------ //
// Register: Int select
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Select intensity filter.  Should not be modified from suggested values.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_INT_SELECT_DEFAULT (0)
#define ACAMERA_ISP_SINTER_INT_SELECT_DATASIZE (1)
#define ACAMERA_ISP_SINTER_INT_SELECT_OFFSET (0x4c0)
#define ACAMERA_ISP_SINTER_INT_SELECT_MASK (0x40)

// args: data (1-bit)
static __inline void acamera_isp_sinter_int_select_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19348L);
    system_sw_write_32(base + 0x19348L, (((uint32_t) (data & 0x1)) << 6) | (curr & 0xffffffbf));
}
static __inline uint8_t acamera_isp_sinter_int_select_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19348L) & 0x40) >> 6);
}
// ------------------------------------------------------------------------------ //
// Register: rm_enable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            Adjusts sinter strength radially from center to compensate for Lens shading correction.
//            enable: 0=off, 1=on
//          
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_RM_ENABLE_DEFAULT (0)
#define ACAMERA_ISP_SINTER_RM_ENABLE_DATASIZE (1)
#define ACAMERA_ISP_SINTER_RM_ENABLE_OFFSET (0x4c0)
#define ACAMERA_ISP_SINTER_RM_ENABLE_MASK (0x80)

// args: data (1-bit)
static __inline void acamera_isp_sinter_rm_enable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19348L);
    system_sw_write_32(base + 0x19348L, (((uint32_t) (data & 0x1)) << 7) | (curr & 0xffffff7f));
}
static __inline uint8_t acamera_isp_sinter_rm_enable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19348L) & 0x80) >> 7);
}
// ------------------------------------------------------------------------------ //
// Register: Config2
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_CONFIG2_DEFAULT (0x0)
#define ACAMERA_ISP_SINTER_CONFIG2_DATASIZE (8)
#define ACAMERA_ISP_SINTER_CONFIG2_OFFSET (0x4c4)
#define ACAMERA_ISP_SINTER_CONFIG2_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_sinter_config2_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1934cL);
    system_sw_write_32(base + 0x1934cL, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_sinter_config2_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1934cL) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: int_config
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Intensity blending with mosaic raw
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_INT_CONFIG_DEFAULT (0x4)
#define ACAMERA_ISP_SINTER_INT_CONFIG_DATASIZE (4)
#define ACAMERA_ISP_SINTER_INT_CONFIG_OFFSET (0x4c4)
#define ACAMERA_ISP_SINTER_INT_CONFIG_MASK (0xf)

// args: data (4-bit)
static __inline void acamera_isp_sinter_int_config_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1934cL);
    system_sw_write_32(base + 0x1934cL, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
}
static __inline uint8_t acamera_isp_sinter_int_config_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1934cL) & 0xf) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: nlm_en
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            This config is only valid fr sinter3
//            Enables (1) or disables (0) the NLM filter
//          
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_NLM_EN_DEFAULT (1)
#define ACAMERA_ISP_SINTER_NLM_EN_DATASIZE (1)
#define ACAMERA_ISP_SINTER_NLM_EN_OFFSET (0x4c4)
#define ACAMERA_ISP_SINTER_NLM_EN_MASK (0x10)

// args: data (1-bit)
static __inline void acamera_isp_sinter_nlm_en_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1934cL);
    system_sw_write_32(base + 0x1934cL, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
}
static __inline uint8_t acamera_isp_sinter_nlm_en_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1934cL) & 0x10) >> 4);
}
// ------------------------------------------------------------------------------ //
// Register: nonlinear_wkgen
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            This config is only valid fr sinter3
//            Enables (1) or disables (0) nonlinear weight generation
//          
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_NONLINEAR_WKGEN_DEFAULT (1)
#define ACAMERA_ISP_SINTER_NONLINEAR_WKGEN_DATASIZE (1)
#define ACAMERA_ISP_SINTER_NONLINEAR_WKGEN_OFFSET (0x4c4)
#define ACAMERA_ISP_SINTER_NONLINEAR_WKGEN_MASK (0x20)

// args: data (1-bit)
static __inline void acamera_isp_sinter_nonlinear_wkgen_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1934cL);
    system_sw_write_32(base + 0x1934cL, (((uint32_t) (data & 0x1)) << 5) | (curr & 0xffffffdf));
}
static __inline uint8_t acamera_isp_sinter_nonlinear_wkgen_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1934cL) & 0x20) >> 5);
}
// ------------------------------------------------------------------------------ //
// Register: sad_filt_thresh
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Block match difference filtering threshold
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_SAD_FILT_THRESH_DEFAULT (0x09)
#define ACAMERA_ISP_SINTER_SAD_FILT_THRESH_DATASIZE (8)
#define ACAMERA_ISP_SINTER_SAD_FILT_THRESH_OFFSET (0x4c8)
#define ACAMERA_ISP_SINTER_SAD_FILT_THRESH_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_sinter_sad_filt_thresh_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19350L);
    system_sw_write_32(base + 0x19350L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_sinter_sad_filt_thresh_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19350L) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: rm_center_x
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Center x coordinate of shading map
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_RM_CENTER_X_DEFAULT (0x280)
#define ACAMERA_ISP_SINTER_RM_CENTER_X_DATASIZE (16)
#define ACAMERA_ISP_SINTER_RM_CENTER_X_OFFSET (0x4cc)
#define ACAMERA_ISP_SINTER_RM_CENTER_X_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_sinter_rm_center_x_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19354L);
    system_sw_write_32(base + 0x19354L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_sinter_rm_center_x_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19354L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: rm_center_y
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Center y coordinate of shading map
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_RM_CENTER_Y_DEFAULT (0x168)
#define ACAMERA_ISP_SINTER_RM_CENTER_Y_DATASIZE (16)
#define ACAMERA_ISP_SINTER_RM_CENTER_Y_OFFSET (0x4cc)
#define ACAMERA_ISP_SINTER_RM_CENTER_Y_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_sinter_rm_center_y_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19354L);
    system_sw_write_32(base + 0x19354L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_sinter_rm_center_y_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19354L) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: rm_off_center_mult
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//          Normalizing factor which scales the radial table to the edge of the image.
//          Calculated as 2^31/R^2 where R is the furthest distance from the center coordinate to the edge of the image in pixels.
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_RM_OFF_CENTER_MULT_DEFAULT (0x0100)
#define ACAMERA_ISP_SINTER_RM_OFF_CENTER_MULT_DATASIZE (16)
#define ACAMERA_ISP_SINTER_RM_OFF_CENTER_MULT_OFFSET (0x4d0)
#define ACAMERA_ISP_SINTER_RM_OFF_CENTER_MULT_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_sinter_rm_off_center_mult_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19358L);
    system_sw_write_32(base + 0x19358L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_sinter_rm_off_center_mult_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19358L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Thresh 0h
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise threshold for high horizontal spatial frequencies
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_THRESH_0H_DEFAULT (0x00)
#define ACAMERA_ISP_SINTER_THRESH_0H_DATASIZE (8)
#define ACAMERA_ISP_SINTER_THRESH_0H_OFFSET (0x4d4)
#define ACAMERA_ISP_SINTER_THRESH_0H_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_sinter_thresh_0h_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1935cL);
    system_sw_write_32(base + 0x1935cL, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_sinter_thresh_0h_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1935cL) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Thresh 1h
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise threshold for high horizontal spatial frequencies
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_THRESH_1H_DEFAULT (0x00)
#define ACAMERA_ISP_SINTER_THRESH_1H_DATASIZE (8)
#define ACAMERA_ISP_SINTER_THRESH_1H_OFFSET (0x4d4)
#define ACAMERA_ISP_SINTER_THRESH_1H_MASK (0xff00)

// args: data (8-bit)
static __inline void acamera_isp_sinter_thresh_1h_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1935cL);
    system_sw_write_32(base + 0x1935cL, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
}
static __inline uint8_t acamera_isp_sinter_thresh_1h_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1935cL) & 0xff00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: Thresh 2h
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise threshold for low horizontal spatial frequencies
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_THRESH_2H_DEFAULT (0x00)
#define ACAMERA_ISP_SINTER_THRESH_2H_DATASIZE (8)
#define ACAMERA_ISP_SINTER_THRESH_2H_OFFSET (0x4d4)
#define ACAMERA_ISP_SINTER_THRESH_2H_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_sinter_thresh_2h_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1935cL);
    system_sw_write_32(base + 0x1935cL, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_sinter_thresh_2h_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1935cL) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Thresh 4h
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise threshold for low horizontal spatial frequencies
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_THRESH_4H_DEFAULT (0x00)
#define ACAMERA_ISP_SINTER_THRESH_4H_DATASIZE (8)
#define ACAMERA_ISP_SINTER_THRESH_4H_OFFSET (0x4d4)
#define ACAMERA_ISP_SINTER_THRESH_4H_MASK (0xff000000)

// args: data (8-bit)
static __inline void acamera_isp_sinter_thresh_4h_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1935cL);
    system_sw_write_32(base + 0x1935cL, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
}
static __inline uint8_t acamera_isp_sinter_thresh_4h_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1935cL) & 0xff000000) >> 24);
}
// ------------------------------------------------------------------------------ //
// Register: Thresh 0v
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise threshold for high vertical spatial frequencies
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_THRESH_0V_DEFAULT (0x00)
#define ACAMERA_ISP_SINTER_THRESH_0V_DATASIZE (8)
#define ACAMERA_ISP_SINTER_THRESH_0V_OFFSET (0x4d8)
#define ACAMERA_ISP_SINTER_THRESH_0V_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_sinter_thresh_0v_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19360L);
    system_sw_write_32(base + 0x19360L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_sinter_thresh_0v_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19360L) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Thresh 1v
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise threshold for high vertical spatial frequencies
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_THRESH_1V_DEFAULT (0x00)
#define ACAMERA_ISP_SINTER_THRESH_1V_DATASIZE (8)
#define ACAMERA_ISP_SINTER_THRESH_1V_OFFSET (0x4d8)
#define ACAMERA_ISP_SINTER_THRESH_1V_MASK (0xff00)

// args: data (8-bit)
static __inline void acamera_isp_sinter_thresh_1v_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19360L);
    system_sw_write_32(base + 0x19360L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
}
static __inline uint8_t acamera_isp_sinter_thresh_1v_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19360L) & 0xff00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: Thresh 2v
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise threshold for low vertical spatial frequencies
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_THRESH_2V_DEFAULT (0x00)
#define ACAMERA_ISP_SINTER_THRESH_2V_DATASIZE (8)
#define ACAMERA_ISP_SINTER_THRESH_2V_OFFSET (0x4d8)
#define ACAMERA_ISP_SINTER_THRESH_2V_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_sinter_thresh_2v_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19360L);
    system_sw_write_32(base + 0x19360L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_sinter_thresh_2v_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19360L) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Thresh 4v
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise threshold for low vertical spatial frequencies
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_THRESH_4V_DEFAULT (0x00)
#define ACAMERA_ISP_SINTER_THRESH_4V_DATASIZE (8)
#define ACAMERA_ISP_SINTER_THRESH_4V_OFFSET (0x4d8)
#define ACAMERA_ISP_SINTER_THRESH_4V_MASK (0xff000000)

// args: data (8-bit)
static __inline void acamera_isp_sinter_thresh_4v_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19360L);
    system_sw_write_32(base + 0x19360L, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
}
static __inline uint8_t acamera_isp_sinter_thresh_4v_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19360L) & 0xff000000) >> 24);
}
// ------------------------------------------------------------------------------ //
// Register: Strength 0
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Unused - no effect
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_STRENGTH_0_DEFAULT (0xFF)
#define ACAMERA_ISP_SINTER_STRENGTH_0_DATASIZE (8)
#define ACAMERA_ISP_SINTER_STRENGTH_0_OFFSET (0x4dc)
#define ACAMERA_ISP_SINTER_STRENGTH_0_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_sinter_strength_0_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19364L);
    system_sw_write_32(base + 0x19364L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_sinter_strength_0_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19364L) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Strength 1
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise reduction effect for high spatial frequencies
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_STRENGTH_1_DEFAULT (0xFF)
#define ACAMERA_ISP_SINTER_STRENGTH_1_DATASIZE (8)
#define ACAMERA_ISP_SINTER_STRENGTH_1_OFFSET (0x4dc)
#define ACAMERA_ISP_SINTER_STRENGTH_1_MASK (0xff00)

// args: data (8-bit)
static __inline void acamera_isp_sinter_strength_1_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19364L);
    system_sw_write_32(base + 0x19364L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
}
static __inline uint8_t acamera_isp_sinter_strength_1_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19364L) & 0xff00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: Strength 2
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Unused - no effect
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_STRENGTH_2_DEFAULT (0xFF)
#define ACAMERA_ISP_SINTER_STRENGTH_2_DATASIZE (8)
#define ACAMERA_ISP_SINTER_STRENGTH_2_OFFSET (0x4dc)
#define ACAMERA_ISP_SINTER_STRENGTH_2_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_sinter_strength_2_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19364L);
    system_sw_write_32(base + 0x19364L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_sinter_strength_2_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19364L) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Strength 4
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise reduction effect for low spatial frequencies
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_STRENGTH_4_DEFAULT (0xFF)
#define ACAMERA_ISP_SINTER_STRENGTH_4_DATASIZE (8)
#define ACAMERA_ISP_SINTER_STRENGTH_4_OFFSET (0x4dc)
#define ACAMERA_ISP_SINTER_STRENGTH_4_MASK (0xff000000)

// args: data (8-bit)
static __inline void acamera_isp_sinter_strength_4_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19364L);
    system_sw_write_32(base + 0x19364L, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
}
static __inline uint8_t acamera_isp_sinter_strength_4_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19364L) & 0xff000000) >> 24);
}
// ------------------------------------------------------------------------------ //
// Group: sinter Noise Profile
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise profile controls for Sinter
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: use LUT
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            1 = use LUT data
//			0 = use exposure mask provided by Frame stitching or threshold
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_NOISE_PROFILE_USE_LUT_DEFAULT (1)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_USE_LUT_DATASIZE (1)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_USE_LUT_OFFSET (0x4e0)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_USE_LUT_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_sinter_noise_profile_use_lut_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19368L);
    system_sw_write_32(base + 0x19368L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_sinter_noise_profile_use_lut_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19368L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: use_exp_mask
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//			1 = use exposure mask provided by Frame stitching or threshold
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_NOISE_PROFILE_USE_EXP_MASK_DEFAULT (1)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_USE_EXP_MASK_DATASIZE (1)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_USE_EXP_MASK_OFFSET (0x4e0)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_USE_EXP_MASK_MASK (0x2)

// args: data (1-bit)
static __inline void acamera_isp_sinter_noise_profile_use_exp_mask_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19368L);
    system_sw_write_32(base + 0x19368L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
}
static __inline uint8_t acamera_isp_sinter_noise_profile_use_exp_mask_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19368L) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: Black Reflect
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Specifies how to deal with data below black level. 0: Clip to zero, 1: Reflect.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_NOISE_PROFILE_BLACK_REFLECT_DEFAULT (0x0)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_BLACK_REFLECT_DATASIZE (1)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_BLACK_REFLECT_OFFSET (0x4e0)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_BLACK_REFLECT_MASK (0x4)

// args: data (1-bit)
static __inline void acamera_isp_sinter_noise_profile_black_reflect_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19368L);
    system_sw_write_32(base + 0x19368L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
}
static __inline uint8_t acamera_isp_sinter_noise_profile_black_reflect_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19368L) & 0x4) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: global offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// A global offset that will be added to each of the hlog... values above..
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_NOISE_PROFILE_GLOBAL_OFFSET_DEFAULT (0x08)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_GLOBAL_OFFSET_DATASIZE (8)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_GLOBAL_OFFSET_OFFSET (0x4e0)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_GLOBAL_OFFSET_MASK (0xff00)

// args: data (8-bit)
static __inline void acamera_isp_sinter_noise_profile_global_offset_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19368L);
    system_sw_write_32(base + 0x19368L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
}
static __inline uint8_t acamera_isp_sinter_noise_profile_global_offset_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x19368L) & 0xff00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: Black Level
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Black level offset for Mode 0
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_NOISE_PROFILE_BLACK_LEVEL_DEFAULT (0x0)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_BLACK_LEVEL_DATASIZE (16)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_BLACK_LEVEL_OFFSET (0x4e4)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_BLACK_LEVEL_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_sinter_noise_profile_black_level_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1936cL);
    system_sw_write_32(base + 0x1936cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_sinter_noise_profile_black_level_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1936cL) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Thresh1
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//		  Exposure thresholds. Used to determine which exposure generated the current pixel.
//		  Pixels with a value greater than or equal to a given threshold will be deemed to have been generated by the shorter exposure.
//		  Pixels with a value less than a given threshold will be deemed to have been generated by the longer exposure.
//		  
//		  E.G. Where 4 exposures are used:
//		    VS >= Thresh 3 > S >= Thresh 2 > M >= Thresh 1 > L
//		    
//		  For 3 exposures set Thresh 1 to 0
//		  For 2 exposures set Thresh 1 and Thresh 2 to 0
//		  For 1 exposures set all exposure thresholds to 0
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_NOISE_PROFILE_THRESH1_DEFAULT (0x4000)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_THRESH1_DATASIZE (16)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_THRESH1_OFFSET (0x4e8)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_THRESH1_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_sinter_noise_profile_thresh1_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19370L);
    system_sw_write_32(base + 0x19370L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_sinter_noise_profile_thresh1_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19370L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Thresh2
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// See above.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_NOISE_PROFILE_THRESH2_DEFAULT (0x8000)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_THRESH2_DATASIZE (16)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_THRESH2_OFFSET (0x4ec)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_THRESH2_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_sinter_noise_profile_thresh2_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19374L);
    system_sw_write_32(base + 0x19374L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_sinter_noise_profile_thresh2_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19374L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Thresh3
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// See above.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_NOISE_PROFILE_THRESH3_DEFAULT (0xC000)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_THRESH3_DATASIZE (16)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_THRESH3_OFFSET (0x4f0)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_THRESH3_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_sinter_noise_profile_thresh3_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x19378L);
    system_sw_write_32(base + 0x19378L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_sinter_noise_profile_thresh3_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x19378L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: noise_level_0
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise level of VS exposure
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_NOISE_PROFILE_NOISE_LEVEL_0_DEFAULT (0x0)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_NOISE_LEVEL_0_DATASIZE (8)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_NOISE_LEVEL_0_OFFSET (0x4f4)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_NOISE_LEVEL_0_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_sinter_noise_profile_noise_level_0_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1937cL);
    system_sw_write_32(base + 0x1937cL, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_sinter_noise_profile_noise_level_0_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1937cL) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: noise_level_1
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise level of S exposure
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_NOISE_PROFILE_NOISE_LEVEL_1_DEFAULT (0x0)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_NOISE_LEVEL_1_DATASIZE (8)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_NOISE_LEVEL_1_OFFSET (0x4f4)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_NOISE_LEVEL_1_MASK (0xff00)

// args: data (8-bit)
static __inline void acamera_isp_sinter_noise_profile_noise_level_1_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1937cL);
    system_sw_write_32(base + 0x1937cL, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
}
static __inline uint8_t acamera_isp_sinter_noise_profile_noise_level_1_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1937cL) & 0xff00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: noise_level_2
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise level of M exposure
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_NOISE_PROFILE_NOISE_LEVEL_2_DEFAULT (0x0)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_NOISE_LEVEL_2_DATASIZE (8)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_NOISE_LEVEL_2_OFFSET (0x4f4)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_NOISE_LEVEL_2_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_sinter_noise_profile_noise_level_2_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1937cL);
    system_sw_write_32(base + 0x1937cL, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_sinter_noise_profile_noise_level_2_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1937cL) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: noise_level_3
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise level of L exposure
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_NOISE_PROFILE_NOISE_LEVEL_3_DEFAULT (0x0)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_NOISE_LEVEL_3_DATASIZE (8)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_NOISE_LEVEL_3_OFFSET (0x4f4)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_NOISE_LEVEL_3_MASK (0xff000000)

// args: data (8-bit)
static __inline void acamera_isp_sinter_noise_profile_noise_level_3_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1937cL);
    system_sw_write_32(base + 0x1937cL, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
}
static __inline uint8_t acamera_isp_sinter_noise_profile_noise_level_3_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1937cL) & 0xff000000) >> 24);
}
// ------------------------------------------------------------------------------ //
// Group: sinter Noise Profile LUT
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Weight lut
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise profile LUT.  Calculated during calibration process.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_NOISE_PROFILE_LUT_WEIGHT_LUT_DEFAULT (0x0)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_LUT_WEIGHT_LUT_DATASIZE (8)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_LUT_WEIGHT_LUT_OFFSET (0x5b0)
#define ACAMERA_ISP_SINTER_NOISE_PROFILE_LUT_WEIGHT_LUT_MASK (0xff)

// index (0-127), args: data (8-bit)
static __inline void acamera_isp_sinter_noise_profile_lut_weight_lut_write( uintptr_t base, uint32_t index,uint8_t data) {
    uintptr_t addr = base + 0x19438L + (index & 0xFFFFFFFC);
    uint8_t offset = (index & 3) << 3;
    uint32_t curr = system_sw_read_32(addr);
    system_sw_write_32(addr, ((uint32_t)data << offset) | (curr & ~(0xFF << offset)));
}
static __inline uint8_t acamera_isp_sinter_noise_profile_lut_weight_lut_read( uintptr_t base, uint32_t index) {
    uintptr_t addr = base + 0x19438L + (index & 0xFFFFFFFC);
    uint8_t offset = (index & 3) << 3;
    return (uint8_t)(system_sw_read_32(addr) >> offset);
}
// ------------------------------------------------------------------------------ //
// Group: sinter shading
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// LUT: rm_shading_lut
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Radial Sinter LUT.  See ISP guide for more details
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SINTER_SHADING_RM_SHADING_LUT_NODES (33)
#define ACAMERA_ISP_SINTER_SHADING_RM_SHADING_LUT_ADDRBITS (6)
#define ACAMERA_ISP_SINTER_SHADING_RM_SHADING_LUT_DATASIZE (8)
#define ACAMERA_ISP_SINTER_SHADING_RM_SHADING_LUT_OFFSET (0x1a9f8L)

// args: index (0-32), data (8-bit)
static __inline void acamera_isp_sinter_shading_rm_shading_lut_write( uintptr_t base, uint8_t index,uint8_t data) {
    uintptr_t addr = base + 0x1a9f8L + (index & 0xFFFFFFFC);
    uint8_t offset = (index & 3) << 3;
    uint32_t curr = system_sw_read_32(addr);
    system_sw_write_32(addr, ((uint32_t)data << offset) | (curr & ~(0xFF << offset)));
}
static __inline uint8_t acamera_isp_sinter_shading_rm_shading_lut_read( uintptr_t base, uint8_t index) {
    uintptr_t addr = base + 0x1a9f8L + (index & 0xFFFFFFFC);
    uint8_t offset = (index & 3) << 3;
    return (uint8_t)(system_sw_read_32(addr) >> offset);
}
// ------------------------------------------------------------------------------ //
// Group: temper
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//				Temporal noise reduction
//			
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Enable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//					Temper enable: 0=off 1=on
//				
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_ENABLE_DEFAULT (0)
#define ACAMERA_ISP_TEMPER_ENABLE_DATASIZE (1)
#define ACAMERA_ISP_TEMPER_ENABLE_OFFSET (0x1b94)
#define ACAMERA_ISP_TEMPER_ENABLE_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_temper_enable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aa1cL);
    system_sw_write_32(base + 0x1aa1cL, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_temper_enable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aa1cL) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Temper2 Mode
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//					0: 0=Temper3 mode 1=Temper2 mode
//				
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_TEMPER2_MODE_DEFAULT (0)
#define ACAMERA_ISP_TEMPER_TEMPER2_MODE_DATASIZE (1)
#define ACAMERA_ISP_TEMPER_TEMPER2_MODE_OFFSET (0x1b94)
#define ACAMERA_ISP_TEMPER_TEMPER2_MODE_MASK (0x2)

// args: data (1-bit)
static __inline void acamera_isp_temper_temper2_mode_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aa1cL);
    system_sw_write_32(base + 0x1aa1cL, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
}
static __inline uint8_t acamera_isp_temper_temper2_mode_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aa1cL) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: Frame delay
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//					Extra output delay: 0=normal output 1=delayed by 1 frame
//				
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_FRAME_DELAY_DEFAULT (0)
#define ACAMERA_ISP_TEMPER_FRAME_DELAY_DATASIZE (1)
#define ACAMERA_ISP_TEMPER_FRAME_DELAY_OFFSET (0x1b98)
#define ACAMERA_ISP_TEMPER_FRAME_DELAY_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_temper_frame_delay_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aa20L);
    system_sw_write_32(base + 0x1aa20L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_temper_frame_delay_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aa20L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Log Enable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//					1=Normal operation, 0=disable logarithmic weighting function for debug
//				
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_LOG_ENABLE_DEFAULT (1)
#define ACAMERA_ISP_TEMPER_LOG_ENABLE_DATASIZE (1)
#define ACAMERA_ISP_TEMPER_LOG_ENABLE_OFFSET (0x1b98)
#define ACAMERA_ISP_TEMPER_LOG_ENABLE_MASK (0x2)

// args: data (1-bit)
static __inline void acamera_isp_temper_log_enable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aa20L);
    system_sw_write_32(base + 0x1aa20L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
}
static __inline uint8_t acamera_isp_temper_log_enable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aa20L) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: Show Alpha
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//					0=Normal operation, 1=output alpha channel for debug
//				
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_SHOW_ALPHA_DEFAULT (0)
#define ACAMERA_ISP_TEMPER_SHOW_ALPHA_DATASIZE (1)
#define ACAMERA_ISP_TEMPER_SHOW_ALPHA_OFFSET (0x1b98)
#define ACAMERA_ISP_TEMPER_SHOW_ALPHA_MASK (0x4)

// args: data (1-bit)
static __inline void acamera_isp_temper_show_alpha_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aa20L);
    system_sw_write_32(base + 0x1aa20L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
}
static __inline uint8_t acamera_isp_temper_show_alpha_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aa20L) & 0x4) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: Show AlphaAB
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//					0=Normal operation, 1=output alpha channel for debug
//				
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_SHOW_ALPHAAB_DEFAULT (0)
#define ACAMERA_ISP_TEMPER_SHOW_ALPHAAB_DATASIZE (1)
#define ACAMERA_ISP_TEMPER_SHOW_ALPHAAB_OFFSET (0x1b98)
#define ACAMERA_ISP_TEMPER_SHOW_ALPHAAB_MASK (0x8)

// args: data (1-bit)
static __inline void acamera_isp_temper_show_alphaab_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aa20L);
    system_sw_write_32(base + 0x1aa20L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
}
static __inline uint8_t acamera_isp_temper_show_alphaab_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aa20L) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: Mixer Select
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//					Debug mixer select(Only active when Temper disabled): 0=Input video stream, 1=Frame buffer video stream
//				
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_MIXER_SELECT_DEFAULT (0)
#define ACAMERA_ISP_TEMPER_MIXER_SELECT_DATASIZE (1)
#define ACAMERA_ISP_TEMPER_MIXER_SELECT_OFFSET (0x1b98)
#define ACAMERA_ISP_TEMPER_MIXER_SELECT_MASK (0x10)

// args: data (1-bit)
static __inline void acamera_isp_temper_mixer_select_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aa20L);
    system_sw_write_32(base + 0x1aa20L, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
}
static __inline uint8_t acamera_isp_temper_mixer_select_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aa20L) & 0x10) >> 4);
}
// ------------------------------------------------------------------------------ //
// Register: Recursion Limit
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//					 Controls length of filter history. Low values result in longer history and stronger temporal filtering.
//				
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_RECURSION_LIMIT_DEFAULT (0x2)
#define ACAMERA_ISP_TEMPER_RECURSION_LIMIT_DATASIZE (4)
#define ACAMERA_ISP_TEMPER_RECURSION_LIMIT_OFFSET (0x1b9c)
#define ACAMERA_ISP_TEMPER_RECURSION_LIMIT_MASK (0xf)

// args: data (4-bit)
static __inline void acamera_isp_temper_recursion_limit_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aa24L);
    system_sw_write_32(base + 0x1aa24L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
}
static __inline uint8_t acamera_isp_temper_recursion_limit_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aa24L) & 0xf) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Delta
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//				
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DELTA_DEFAULT (0x2)
#define ACAMERA_ISP_TEMPER_DELTA_DATASIZE (8)
#define ACAMERA_ISP_TEMPER_DELTA_OFFSET (0x1b9c)
#define ACAMERA_ISP_TEMPER_DELTA_MASK (0xff00)

// args: data (8-bit)
static __inline void acamera_isp_temper_delta_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aa24L);
    system_sw_write_32(base + 0x1aa24L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
}
static __inline uint8_t acamera_isp_temper_delta_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aa24L) & 0xff00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Group: temper Noise Profile
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise profile controls for Temper
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: use LUT
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            1 = use LUT data
//			0 = use exposure mask provided by Frame stitching or threshold
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_USE_LUT_DEFAULT (1)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_USE_LUT_DATASIZE (1)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_USE_LUT_OFFSET (0x1ba0)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_USE_LUT_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_temper_noise_profile_use_lut_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aa28L);
    system_sw_write_32(base + 0x1aa28L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_temper_noise_profile_use_lut_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aa28L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: use_exp_mask
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//			1 = use exposure mask provided by Frame stitching or threshold
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_USE_EXP_MASK_DEFAULT (1)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_USE_EXP_MASK_DATASIZE (1)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_USE_EXP_MASK_OFFSET (0x1ba0)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_USE_EXP_MASK_MASK (0x2)

// args: data (1-bit)
static __inline void acamera_isp_temper_noise_profile_use_exp_mask_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aa28L);
    system_sw_write_32(base + 0x1aa28L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
}
static __inline uint8_t acamera_isp_temper_noise_profile_use_exp_mask_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aa28L) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: Black Reflect
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Specifies how to deal with data below black level. 0: Clip to zero, 1: Reflect.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_BLACK_REFLECT_DEFAULT (0x0)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_BLACK_REFLECT_DATASIZE (1)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_BLACK_REFLECT_OFFSET (0x1ba0)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_BLACK_REFLECT_MASK (0x4)

// args: data (1-bit)
static __inline void acamera_isp_temper_noise_profile_black_reflect_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aa28L);
    system_sw_write_32(base + 0x1aa28L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
}
static __inline uint8_t acamera_isp_temper_noise_profile_black_reflect_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aa28L) & 0x4) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: global offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// A global offset that will be added to each of the hlog... values above..
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_GLOBAL_OFFSET_DEFAULT (0x08)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_GLOBAL_OFFSET_DATASIZE (8)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_GLOBAL_OFFSET_OFFSET (0x1ba0)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_GLOBAL_OFFSET_MASK (0xff00)

// args: data (8-bit)
static __inline void acamera_isp_temper_noise_profile_global_offset_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aa28L);
    system_sw_write_32(base + 0x1aa28L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
}
static __inline uint8_t acamera_isp_temper_noise_profile_global_offset_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aa28L) & 0xff00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: Black Level
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Black level offset for Mode 0
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_BLACK_LEVEL_DEFAULT (0x0)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_BLACK_LEVEL_DATASIZE (16)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_BLACK_LEVEL_OFFSET (0x1ba4)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_BLACK_LEVEL_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_temper_noise_profile_black_level_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aa2cL);
    system_sw_write_32(base + 0x1aa2cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_temper_noise_profile_black_level_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1aa2cL) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Thresh1
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//		  Exposure thresholds. Used to determine which exposure generated the current pixel.
//		  Pixels with a value greater than or equal to a given threshold will be deemed to have been generated by the shorter exposure.
//		  Pixels with a value less than a given threshold will be deemed to have been generated by the longer exposure.
//		  
//		  E.G. Where 4 exposures are used:
//		    VS >= Thresh 3 > S >= Thresh 2 > M >= Thresh 1 > L
//		    
//		  For 3 exposures set Thresh 1 to 0
//		  For 2 exposures set Thresh 1 and Thresh 2 to 0
//		  For 1 exposures set all exposure thresholds to 0
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_THRESH1_DEFAULT (0x4000)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_THRESH1_DATASIZE (16)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_THRESH1_OFFSET (0x1ba8)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_THRESH1_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_temper_noise_profile_thresh1_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aa30L);
    system_sw_write_32(base + 0x1aa30L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_temper_noise_profile_thresh1_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1aa30L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Thresh2
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// See above.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_THRESH2_DEFAULT (0x8000)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_THRESH2_DATASIZE (16)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_THRESH2_OFFSET (0x1bac)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_THRESH2_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_temper_noise_profile_thresh2_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aa34L);
    system_sw_write_32(base + 0x1aa34L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_temper_noise_profile_thresh2_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1aa34L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Thresh3
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// See above.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_THRESH3_DEFAULT (0xC000)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_THRESH3_DATASIZE (16)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_THRESH3_OFFSET (0x1bb0)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_THRESH3_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_temper_noise_profile_thresh3_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aa38L);
    system_sw_write_32(base + 0x1aa38L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_temper_noise_profile_thresh3_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1aa38L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: noise_level_0
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise level of VS exposure
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_NOISE_LEVEL_0_DEFAULT (0x0)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_NOISE_LEVEL_0_DATASIZE (8)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_NOISE_LEVEL_0_OFFSET (0x1bb4)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_NOISE_LEVEL_0_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_temper_noise_profile_noise_level_0_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aa3cL);
    system_sw_write_32(base + 0x1aa3cL, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_temper_noise_profile_noise_level_0_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aa3cL) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: noise_level_1
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise level of S exposure
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_NOISE_LEVEL_1_DEFAULT (0x0)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_NOISE_LEVEL_1_DATASIZE (8)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_NOISE_LEVEL_1_OFFSET (0x1bb4)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_NOISE_LEVEL_1_MASK (0xff00)

// args: data (8-bit)
static __inline void acamera_isp_temper_noise_profile_noise_level_1_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aa3cL);
    system_sw_write_32(base + 0x1aa3cL, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
}
static __inline uint8_t acamera_isp_temper_noise_profile_noise_level_1_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aa3cL) & 0xff00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: noise_level_2
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise level of M exposure
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_NOISE_LEVEL_2_DEFAULT (0x0)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_NOISE_LEVEL_2_DATASIZE (8)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_NOISE_LEVEL_2_OFFSET (0x1bb4)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_NOISE_LEVEL_2_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_temper_noise_profile_noise_level_2_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aa3cL);
    system_sw_write_32(base + 0x1aa3cL, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_temper_noise_profile_noise_level_2_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aa3cL) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: noise_level_3
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise level of L exposure
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_NOISE_LEVEL_3_DEFAULT (0x0)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_NOISE_LEVEL_3_DATASIZE (8)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_NOISE_LEVEL_3_OFFSET (0x1bb4)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_NOISE_LEVEL_3_MASK (0xff000000)

// args: data (8-bit)
static __inline void acamera_isp_temper_noise_profile_noise_level_3_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aa3cL);
    system_sw_write_32(base + 0x1aa3cL, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
}
static __inline uint8_t acamera_isp_temper_noise_profile_noise_level_3_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aa3cL) & 0xff000000) >> 24);
}
// ------------------------------------------------------------------------------ //
// Group: temper Noise Profile LUT
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Weight lut
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise profile LUT.  Calculated during calibration process.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_LUT_WEIGHT_LUT_DEFAULT (0x0)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_LUT_WEIGHT_LUT_DATASIZE (8)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_LUT_WEIGHT_LUT_OFFSET (0x1c70)
#define ACAMERA_ISP_TEMPER_NOISE_PROFILE_LUT_WEIGHT_LUT_MASK (0xff)

// index (0-127), args: data (8-bit)
static __inline void acamera_isp_temper_noise_profile_lut_weight_lut_write( uintptr_t base, uint32_t index,uint8_t data) {
    uintptr_t addr = base + 0x1aaf8L + (index & 0xFFFFFFFC);
    uint8_t offset = (index & 3) << 3;
    uint32_t curr = system_sw_read_32(addr);
    system_sw_write_32(addr, ((uint32_t)data << offset) | (curr & ~(0xFF << offset)));
}
static __inline uint8_t acamera_isp_temper_noise_profile_lut_weight_lut_read( uintptr_t base, uint32_t index) {
    uintptr_t addr = base + 0x1aaf8L + (index & 0xFFFFFFFC);
    uint8_t offset = (index & 3) << 3;
    return (uint8_t)(system_sw_read_32(addr) >> offset);
}
// ------------------------------------------------------------------------------ //
// Group: temper dma
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Frame write on MSB dma
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// This must be set to 1 only in Temper-3 mode
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_FRAME_WRITE_ON_MSB_DMA_DEFAULT (1)
#define ACAMERA_ISP_TEMPER_DMA_FRAME_WRITE_ON_MSB_DMA_DATASIZE (1)
#define ACAMERA_ISP_TEMPER_DMA_FRAME_WRITE_ON_MSB_DMA_OFFSET (0x1cf0)
#define ACAMERA_ISP_TEMPER_DMA_FRAME_WRITE_ON_MSB_DMA_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_temper_dma_frame_write_on_msb_dma_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ab78L);
    system_sw_write_32(base + 0x1ab78L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_temper_dma_frame_write_on_msb_dma_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ab78L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Frame write on LSB dma
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// This must be set to 1 whenever Temper (either T2 or T3 mode) is enabled
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_FRAME_WRITE_ON_LSB_DMA_DEFAULT (1)
#define ACAMERA_ISP_TEMPER_DMA_FRAME_WRITE_ON_LSB_DMA_DATASIZE (1)
#define ACAMERA_ISP_TEMPER_DMA_FRAME_WRITE_ON_LSB_DMA_OFFSET (0x1cf0)
#define ACAMERA_ISP_TEMPER_DMA_FRAME_WRITE_ON_LSB_DMA_MASK (0x2)

// args: data (1-bit)
static __inline void acamera_isp_temper_dma_frame_write_on_lsb_dma_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ab78L);
    system_sw_write_32(base + 0x1ab78L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
}
static __inline uint8_t acamera_isp_temper_dma_frame_write_on_lsb_dma_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ab78L) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: Frame read on MSB dma
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// This must be set to 1 only in Temper-3 mode
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_FRAME_READ_ON_MSB_DMA_DEFAULT (1)
#define ACAMERA_ISP_TEMPER_DMA_FRAME_READ_ON_MSB_DMA_DATASIZE (1)
#define ACAMERA_ISP_TEMPER_DMA_FRAME_READ_ON_MSB_DMA_OFFSET (0x1cf0)
#define ACAMERA_ISP_TEMPER_DMA_FRAME_READ_ON_MSB_DMA_MASK (0x4)

// args: data (1-bit)
static __inline void acamera_isp_temper_dma_frame_read_on_msb_dma_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ab78L);
    system_sw_write_32(base + 0x1ab78L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
}
static __inline uint8_t acamera_isp_temper_dma_frame_read_on_msb_dma_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ab78L) & 0x4) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: Frame read on LSB dma
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// This must be set to 1 whenever Temper (either T2 or T3 mode) is enabled
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_FRAME_READ_ON_LSB_DMA_DEFAULT (1)
#define ACAMERA_ISP_TEMPER_DMA_FRAME_READ_ON_LSB_DMA_DATASIZE (1)
#define ACAMERA_ISP_TEMPER_DMA_FRAME_READ_ON_LSB_DMA_OFFSET (0x1cf0)
#define ACAMERA_ISP_TEMPER_DMA_FRAME_READ_ON_LSB_DMA_MASK (0x8)

// args: data (1-bit)
static __inline void acamera_isp_temper_dma_frame_read_on_lsb_dma_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ab78L);
    system_sw_write_32(base + 0x1ab78L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
}
static __inline uint8_t acamera_isp_temper_dma_frame_read_on_lsb_dma_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ab78L) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: temper_dw
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            0: 16bit valid data
//            1: upto 12 bit valid data, MSB aligened to 16 bit
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_TEMPER_DW_DEFAULT (0)
#define ACAMERA_ISP_TEMPER_DMA_TEMPER_DW_DATASIZE (1)
#define ACAMERA_ISP_TEMPER_DMA_TEMPER_DW_OFFSET (0x1cf0)
#define ACAMERA_ISP_TEMPER_DMA_TEMPER_DW_MASK (0x400)

// args: data (1-bit)
static __inline void acamera_isp_temper_dma_temper_dw_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ab78L);
    system_sw_write_32(base + 0x1ab78L, (((uint32_t) (data & 0x1)) << 10) | (curr & 0xfffffbff));
}
static __inline uint8_t acamera_isp_temper_dma_temper_dw_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ab78L) & 0x400) >> 10);
}
// ------------------------------------------------------------------------------ //
// Register: format
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        20: for 16bit data both in T3 and T2 modes
//        6 : for 12bit data both in T3 and T2 modes
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_FORMAT_DEFAULT (20)
#define ACAMERA_ISP_TEMPER_DMA_FORMAT_DATASIZE (8)
#define ACAMERA_ISP_TEMPER_DMA_FORMAT_OFFSET (0x1cf4)
#define ACAMERA_ISP_TEMPER_DMA_FORMAT_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_temper_dma_format_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ab7cL);
    system_sw_write_32(base + 0x1ab7cL, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_temper_dma_format_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ab7cL) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: blk_status
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//          The bits are defined as follows:
//          0     Write FIFO Fail (Full)
//          1     Write FIFO Fail (Empty)
//          2     Read FIFO Fail (Full)
//          3     Read FIFO Fail (Empty)
//          4     Pack Fail (Overflow)
//          5     Unpack Fail (Overflow)
//          6     Writer fail (Active Width)
//          7     Writer fail (Active Height)
//          8     Writer fail (Interline blanking)
//          9     Writer fail (Interframe blanking)
//          10    Reader fail (Active Width)
//          11    Reader fail (Active Height)
//          12    Reader fail (Interline blanking)
//          13    Reader fail (Interframe blanking)
//          14    0
//          15    0
//          16    Writer fail (A resp)
//          17    Writer fail (AW wait)
//          18    Writer fail (W wait)
//          19    Writer fail (Outstanding Transactions)
//          20    Reader fail (AR wait)
//          21    Reader fail (R resp)
//          22    Reader fail (Oustanding Transfers)
//          23    0
//          24    intw_fail_user_intfc_sig
//          25    intr_fail_user_intfc_sig
//          26    0
//          27    0
//          28    0
//          29    0
//          30    0
//          31    0
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_BLK_STATUS_DEFAULT (0x0000)
#define ACAMERA_ISP_TEMPER_DMA_BLK_STATUS_DATASIZE (32)
#define ACAMERA_ISP_TEMPER_DMA_BLK_STATUS_OFFSET (0x1cf8)
#define ACAMERA_ISP_TEMPER_DMA_BLK_STATUS_MASK (0xffffffff)

// args: data (32-bit)
static __inline uint32_t acamera_isp_temper_dma_blk_status_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1ab80L);
}
// ------------------------------------------------------------------------------ //
// Register: msb_bank_base_writer
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            base address for frame buffer, should be word-aligned. This is used only in 16bit temper3 mode.
//            In 16bit temper3 mode, each 40 bit temper data (32bit data+8bit meta data) is split into 2 chunks and each
//            is stored in one of the buffers. The MSB part is stored into this buffer
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_MSB_BANK_BASE_WRITER_DEFAULT (0x0)
#define ACAMERA_ISP_TEMPER_DMA_MSB_BANK_BASE_WRITER_DATASIZE (32)
#define ACAMERA_ISP_TEMPER_DMA_MSB_BANK_BASE_WRITER_OFFSET (0x1cfc)
#define ACAMERA_ISP_TEMPER_DMA_MSB_BANK_BASE_WRITER_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_temper_dma_msb_bank_base_writer_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1ab84L, data);
}
static __inline uint32_t acamera_isp_temper_dma_msb_bank_base_writer_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1ab84L);
}
// ------------------------------------------------------------------------------ //
// Register: lsb_bank_base_writer
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            base address for frame buffer, should be word-aligned. This is used all the times temper is used..
//            In 16bit temper3 mode, each 40 bit temper data (32bit data+8bit meta data) is split into 2 chunks and each
//            is stored in one of the buffers. The LSB part is stored into this buffer.
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_LSB_BANK_BASE_WRITER_DEFAULT (0x0)
#define ACAMERA_ISP_TEMPER_DMA_LSB_BANK_BASE_WRITER_DATASIZE (32)
#define ACAMERA_ISP_TEMPER_DMA_LSB_BANK_BASE_WRITER_OFFSET (0x1d00)
#define ACAMERA_ISP_TEMPER_DMA_LSB_BANK_BASE_WRITER_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_temper_dma_lsb_bank_base_writer_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1ab88L, data);
}
static __inline uint32_t acamera_isp_temper_dma_lsb_bank_base_writer_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1ab88L);
}
// ------------------------------------------------------------------------------ //
// Register: msb_bank_base_reader
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            base address for frame buffer, should be word-aligned. This is used only in 16bit temper3 mode.
//            In 16bit temper3 mode, each 40 bit temper data (32bit data+8bit meta data) is split into 2 chunks and each
//            is stored in one of the buffers. The MSB part is stored into this buffer
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_MSB_BANK_BASE_READER_DEFAULT (0x0)
#define ACAMERA_ISP_TEMPER_DMA_MSB_BANK_BASE_READER_DATASIZE (32)
#define ACAMERA_ISP_TEMPER_DMA_MSB_BANK_BASE_READER_OFFSET (0x1d04)
#define ACAMERA_ISP_TEMPER_DMA_MSB_BANK_BASE_READER_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_temper_dma_msb_bank_base_reader_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1ab8cL, data);
}
static __inline uint32_t acamera_isp_temper_dma_msb_bank_base_reader_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1ab8cL);
}
// ------------------------------------------------------------------------------ //
// Register: lsb_bank_base_reader
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            base address for frame buffer, should be word-aligned. This is used all the times temper is used..
//            In 16bit temper3 mode, each 40 bit temper data (32bit data+8bit meta data) is split into 2 chunks and each
//            is stored in one of the buffers. The LSB part is stored into this buffer.
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_LSB_BANK_BASE_READER_DEFAULT (0x0)
#define ACAMERA_ISP_TEMPER_DMA_LSB_BANK_BASE_READER_DATASIZE (32)
#define ACAMERA_ISP_TEMPER_DMA_LSB_BANK_BASE_READER_OFFSET (0x1d08)
#define ACAMERA_ISP_TEMPER_DMA_LSB_BANK_BASE_READER_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_temper_dma_lsb_bank_base_reader_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1ab90L, data);
}
static __inline uint32_t acamera_isp_temper_dma_lsb_bank_base_reader_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1ab90L);
}
// ------------------------------------------------------------------------------ //
// Register: Line_offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//          Indicates the offset in bytes from the start of one line to the next line.  
//          This value should be equal to or larger than one line of image data and should be word-aligned
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_LINE_OFFSET_DEFAULT (0x1000)
#define ACAMERA_ISP_TEMPER_DMA_LINE_OFFSET_DATASIZE (32)
#define ACAMERA_ISP_TEMPER_DMA_LINE_OFFSET_OFFSET (0x1d0c)
#define ACAMERA_ISP_TEMPER_DMA_LINE_OFFSET_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_temper_dma_line_offset_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1ab94L, data);
}
static __inline uint32_t acamera_isp_temper_dma_line_offset_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1ab94L);
}
// ------------------------------------------------------------------------------ //
// Register: linetick_eol
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// linetick start/end of line control. 0 = use start of line, 1 = use end of line
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_LINETICK_EOL_DEFAULT (1)
#define ACAMERA_ISP_TEMPER_DMA_LINETICK_EOL_DATASIZE (1)
#define ACAMERA_ISP_TEMPER_DMA_LINETICK_EOL_OFFSET (0x1d10)
#define ACAMERA_ISP_TEMPER_DMA_LINETICK_EOL_MASK (0x2)

// args: data (1-bit)
static __inline void acamera_isp_temper_dma_linetick_eol_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ab98L);
    system_sw_write_32(base + 0x1ab98L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
}
static __inline uint8_t acamera_isp_temper_dma_linetick_eol_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ab98L) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: Lines_wrapped
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// number of lines to write from base address before wrapping back to base address 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_LINES_WRAPPED_DEFAULT (0x0000)
#define ACAMERA_ISP_TEMPER_DMA_LINES_WRAPPED_DATASIZE (16)
#define ACAMERA_ISP_TEMPER_DMA_LINES_WRAPPED_OFFSET (0x1d14)
#define ACAMERA_ISP_TEMPER_DMA_LINES_WRAPPED_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_temper_dma_lines_wrapped_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ab9cL);
    system_sw_write_32(base + 0x1ab9cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_temper_dma_lines_wrapped_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ab9cL) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: fifo_maxfill
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// max fill level of fifo to allow 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_FIFO_MAXFILL_DEFAULT (0x0000)
#define ACAMERA_ISP_TEMPER_DMA_FIFO_MAXFILL_DATASIZE (16)
#define ACAMERA_ISP_TEMPER_DMA_FIFO_MAXFILL_OFFSET (0x1d14)
#define ACAMERA_ISP_TEMPER_DMA_FIFO_MAXFILL_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_temper_dma_fifo_maxfill_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ab9cL);
    system_sw_write_32(base + 0x1ab9cL, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_temper_dma_fifo_maxfill_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ab9cL) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: linetick_first
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// line number of first linetick. 0  = no linetick 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_LINETICK_FIRST_DEFAULT (0x0040)
#define ACAMERA_ISP_TEMPER_DMA_LINETICK_FIRST_DATASIZE (16)
#define ACAMERA_ISP_TEMPER_DMA_LINETICK_FIRST_OFFSET (0x1d18)
#define ACAMERA_ISP_TEMPER_DMA_LINETICK_FIRST_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_temper_dma_linetick_first_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aba0L);
    system_sw_write_32(base + 0x1aba0L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_temper_dma_linetick_first_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1aba0L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: linetick_repeat
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// line number of first linetick. 0 = no repeat
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_LINETICK_REPEAT_DEFAULT (0x0000)
#define ACAMERA_ISP_TEMPER_DMA_LINETICK_REPEAT_DATASIZE (16)
#define ACAMERA_ISP_TEMPER_DMA_LINETICK_REPEAT_OFFSET (0x1d18)
#define ACAMERA_ISP_TEMPER_DMA_LINETICK_REPEAT_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_temper_dma_linetick_repeat_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aba0L);
    system_sw_write_32(base + 0x1aba0L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_temper_dma_linetick_repeat_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1aba0L) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: linetick_delay
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// linetick delay in vcke cycles to add
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_LINETICK_DELAY_DEFAULT (0x0000)
#define ACAMERA_ISP_TEMPER_DMA_LINETICK_DELAY_DATASIZE (16)
#define ACAMERA_ISP_TEMPER_DMA_LINETICK_DELAY_OFFSET (0x1d1c)
#define ACAMERA_ISP_TEMPER_DMA_LINETICK_DELAY_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_temper_dma_linetick_delay_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aba4L);
    system_sw_write_32(base + 0x1aba4L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_temper_dma_linetick_delay_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1aba4L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: msb_writer_axi_id_value
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        value to send for awid, wid and expected on bid.
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_MSB_WRITER_AXI_ID_VALUE_DEFAULT (0x0)
#define ACAMERA_ISP_TEMPER_DMA_MSB_WRITER_AXI_ID_VALUE_DATASIZE (4)
#define ACAMERA_ISP_TEMPER_DMA_MSB_WRITER_AXI_ID_VALUE_OFFSET (0x1d20)
#define ACAMERA_ISP_TEMPER_DMA_MSB_WRITER_AXI_ID_VALUE_MASK (0xf)

// args: data (4-bit)
static __inline void acamera_isp_temper_dma_msb_writer_axi_id_value_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aba8L);
    system_sw_write_32(base + 0x1aba8L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
}
static __inline uint8_t acamera_isp_temper_dma_msb_writer_axi_id_value_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aba8L) & 0xf) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: lsb_writer_axi_id_value
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        value to send for awid, wid and expected on bid.
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_LSB_WRITER_AXI_ID_VALUE_DEFAULT (0x0)
#define ACAMERA_ISP_TEMPER_DMA_LSB_WRITER_AXI_ID_VALUE_DATASIZE (4)
#define ACAMERA_ISP_TEMPER_DMA_LSB_WRITER_AXI_ID_VALUE_OFFSET (0x1d20)
#define ACAMERA_ISP_TEMPER_DMA_LSB_WRITER_AXI_ID_VALUE_MASK (0xf0)

// args: data (4-bit)
static __inline void acamera_isp_temper_dma_lsb_writer_axi_id_value_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aba8L);
    system_sw_write_32(base + 0x1aba8L, (((uint32_t) (data & 0xf)) << 4) | (curr & 0xffffff0f));
}
static __inline uint8_t acamera_isp_temper_dma_lsb_writer_axi_id_value_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aba8L) & 0xf0) >> 4);
}
// ------------------------------------------------------------------------------ //
// Register: writer_axi_id_multi
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        0= static value (axi_id_value) for awid/wid, 1 = incrementing value per transaction for awid/wid wrapping to 0 after axi_id_value
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_WRITER_AXI_ID_MULTI_DEFAULT (0)
#define ACAMERA_ISP_TEMPER_DMA_WRITER_AXI_ID_MULTI_DATASIZE (1)
#define ACAMERA_ISP_TEMPER_DMA_WRITER_AXI_ID_MULTI_OFFSET (0x1d20)
#define ACAMERA_ISP_TEMPER_DMA_WRITER_AXI_ID_MULTI_MASK (0x100)

// args: data (1-bit)
static __inline void acamera_isp_temper_dma_writer_axi_id_multi_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aba8L);
    system_sw_write_32(base + 0x1aba8L, (((uint32_t) (data & 0x1)) << 8) | (curr & 0xfffffeff));
}
static __inline uint8_t acamera_isp_temper_dma_writer_axi_id_multi_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aba8L) & 0x100) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: writer_axi_burstsplit
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        memory boundary that splits bursts: 0=2Transfers,1=4Transfers,2=8Transfers,3=16Transfers. (for axi_data_w=128,  16transfers=256Bytes). Good default = 11
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_WRITER_AXI_BURSTSPLIT_DEFAULT (0x3)
#define ACAMERA_ISP_TEMPER_DMA_WRITER_AXI_BURSTSPLIT_DATASIZE (2)
#define ACAMERA_ISP_TEMPER_DMA_WRITER_AXI_BURSTSPLIT_OFFSET (0x1d20)
#define ACAMERA_ISP_TEMPER_DMA_WRITER_AXI_BURSTSPLIT_MASK (0x600)

// args: data (2-bit)
static __inline void acamera_isp_temper_dma_writer_axi_burstsplit_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aba8L);
    system_sw_write_32(base + 0x1aba8L, (((uint32_t) (data & 0x3)) << 9) | (curr & 0xfffff9ff));
}
static __inline uint8_t acamera_isp_temper_dma_writer_axi_burstsplit_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aba8L) & 0x600) >> 9);
}
// ------------------------------------------------------------------------------ //
// Register: writer_axi_cache_value
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        value to send for awcache. Good default = 1111
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_WRITER_AXI_CACHE_VALUE_DEFAULT (0xf)
#define ACAMERA_ISP_TEMPER_DMA_WRITER_AXI_CACHE_VALUE_DATASIZE (4)
#define ACAMERA_ISP_TEMPER_DMA_WRITER_AXI_CACHE_VALUE_OFFSET (0x1d20)
#define ACAMERA_ISP_TEMPER_DMA_WRITER_AXI_CACHE_VALUE_MASK (0x7800)

// args: data (4-bit)
static __inline void acamera_isp_temper_dma_writer_axi_cache_value_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aba8L);
    system_sw_write_32(base + 0x1aba8L, (((uint32_t) (data & 0xf)) << 11) | (curr & 0xffff87ff));
}
static __inline uint8_t acamera_isp_temper_dma_writer_axi_cache_value_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aba8L) & 0x7800) >> 11);
}
// ------------------------------------------------------------------------------ //
// Register: writer_axi_maxostand
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        max outstanding write transactions (bursts) allowed. zero means no maximum(uses internal limit of 2048). 
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_WRITER_AXI_MAXOSTAND_DEFAULT (0x00)
#define ACAMERA_ISP_TEMPER_DMA_WRITER_AXI_MAXOSTAND_DATASIZE (8)
#define ACAMERA_ISP_TEMPER_DMA_WRITER_AXI_MAXOSTAND_OFFSET (0x1d20)
#define ACAMERA_ISP_TEMPER_DMA_WRITER_AXI_MAXOSTAND_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_temper_dma_writer_axi_maxostand_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aba8L);
    system_sw_write_32(base + 0x1aba8L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_temper_dma_writer_axi_maxostand_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aba8L) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: writer_axi_max_awlen
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        max value to use for awlen (axi burst length). 0000= max 1 transfer/burst , upto 1111= max 16 transfers/burst
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_WRITER_AXI_MAX_AWLEN_DEFAULT (0xf)
#define ACAMERA_ISP_TEMPER_DMA_WRITER_AXI_MAX_AWLEN_DATASIZE (4)
#define ACAMERA_ISP_TEMPER_DMA_WRITER_AXI_MAX_AWLEN_OFFSET (0x1d20)
#define ACAMERA_ISP_TEMPER_DMA_WRITER_AXI_MAX_AWLEN_MASK (0xf000000)

// args: data (4-bit)
static __inline void acamera_isp_temper_dma_writer_axi_max_awlen_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aba8L);
    system_sw_write_32(base + 0x1aba8L, (((uint32_t) (data & 0xf)) << 24) | (curr & 0xf0ffffff));
}
static __inline uint8_t acamera_isp_temper_dma_writer_axi_max_awlen_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aba8L) & 0xf000000) >> 24);
}
// ------------------------------------------------------------------------------ //
// Register: writer_pagewarm_on
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        active high, enables posting of pagewarm dummy writes to SMMU for early page translation of upcomming 4K pages. 
//        Recommend SMMU has min 8 page cache to avoid translation miss. Pagewarms are posted as dummy writes with wstrb= 0
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_WRITER_PAGEWARM_ON_DEFAULT (0)
#define ACAMERA_ISP_TEMPER_DMA_WRITER_PAGEWARM_ON_DATASIZE (1)
#define ACAMERA_ISP_TEMPER_DMA_WRITER_PAGEWARM_ON_OFFSET (0x1d20)
#define ACAMERA_ISP_TEMPER_DMA_WRITER_PAGEWARM_ON_MASK (0x10000000)

// args: data (1-bit)
static __inline void acamera_isp_temper_dma_writer_pagewarm_on_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aba8L);
    system_sw_write_32(base + 0x1aba8L, (((uint32_t) (data & 0x1)) << 28) | (curr & 0xefffffff));
}
static __inline uint8_t acamera_isp_temper_dma_writer_pagewarm_on_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aba8L) & 0x10000000) >> 28);
}
// ------------------------------------------------------------------------------ //
// Register: msb_reader_axi_id_value
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        value to send for awid, wid and expected on bid. Good default = "0000" 
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_MSB_READER_AXI_ID_VALUE_DEFAULT (0x0)
#define ACAMERA_ISP_TEMPER_DMA_MSB_READER_AXI_ID_VALUE_DATASIZE (4)
#define ACAMERA_ISP_TEMPER_DMA_MSB_READER_AXI_ID_VALUE_OFFSET (0x1d24)
#define ACAMERA_ISP_TEMPER_DMA_MSB_READER_AXI_ID_VALUE_MASK (0xf)

// args: data (4-bit)
static __inline void acamera_isp_temper_dma_msb_reader_axi_id_value_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abacL);
    system_sw_write_32(base + 0x1abacL, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
}
static __inline uint8_t acamera_isp_temper_dma_msb_reader_axi_id_value_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1abacL) & 0xf) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: lsb_reader_axi_id_value
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        value to send for awid, wid and expected on bid. Good default = "0000" 
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_LSB_READER_AXI_ID_VALUE_DEFAULT (0x0)
#define ACAMERA_ISP_TEMPER_DMA_LSB_READER_AXI_ID_VALUE_DATASIZE (4)
#define ACAMERA_ISP_TEMPER_DMA_LSB_READER_AXI_ID_VALUE_OFFSET (0x1d24)
#define ACAMERA_ISP_TEMPER_DMA_LSB_READER_AXI_ID_VALUE_MASK (0xf0)

// args: data (4-bit)
static __inline void acamera_isp_temper_dma_lsb_reader_axi_id_value_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abacL);
    system_sw_write_32(base + 0x1abacL, (((uint32_t) (data & 0xf)) << 4) | (curr & 0xffffff0f));
}
static __inline uint8_t acamera_isp_temper_dma_lsb_reader_axi_id_value_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1abacL) & 0xf0) >> 4);
}
// ------------------------------------------------------------------------------ //
// Register: reader_axi_burstsplit
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        memory boundary that splits bursts: 0=2Transfers,1=4Transfers,2=8Transfers,3=16Transfers. (for axi_data_w=128,  16transfers=256Bytes). Good default = 11
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_READER_AXI_BURSTSPLIT_DEFAULT (0x3)
#define ACAMERA_ISP_TEMPER_DMA_READER_AXI_BURSTSPLIT_DATASIZE (2)
#define ACAMERA_ISP_TEMPER_DMA_READER_AXI_BURSTSPLIT_OFFSET (0x1d24)
#define ACAMERA_ISP_TEMPER_DMA_READER_AXI_BURSTSPLIT_MASK (0x600)

// args: data (2-bit)
static __inline void acamera_isp_temper_dma_reader_axi_burstsplit_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abacL);
    system_sw_write_32(base + 0x1abacL, (((uint32_t) (data & 0x3)) << 9) | (curr & 0xfffff9ff));
}
static __inline uint8_t acamera_isp_temper_dma_reader_axi_burstsplit_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1abacL) & 0x600) >> 9);
}
// ------------------------------------------------------------------------------ //
// Register: reader_axi_cache_value
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        value to send for awcache. Good default = 1111
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_READER_AXI_CACHE_VALUE_DEFAULT (0xf)
#define ACAMERA_ISP_TEMPER_DMA_READER_AXI_CACHE_VALUE_DATASIZE (4)
#define ACAMERA_ISP_TEMPER_DMA_READER_AXI_CACHE_VALUE_OFFSET (0x1d24)
#define ACAMERA_ISP_TEMPER_DMA_READER_AXI_CACHE_VALUE_MASK (0x7800)

// args: data (4-bit)
static __inline void acamera_isp_temper_dma_reader_axi_cache_value_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abacL);
    system_sw_write_32(base + 0x1abacL, (((uint32_t) (data & 0xf)) << 11) | (curr & 0xffff87ff));
}
static __inline uint8_t acamera_isp_temper_dma_reader_axi_cache_value_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1abacL) & 0x7800) >> 11);
}
// ------------------------------------------------------------------------------ //
// Register: reader_axi_maxostand
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        max outstanding write transactions (bursts) allowed. zero means no maximum(uses internal limit of 2048). 
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_READER_AXI_MAXOSTAND_DEFAULT (0x00)
#define ACAMERA_ISP_TEMPER_DMA_READER_AXI_MAXOSTAND_DATASIZE (8)
#define ACAMERA_ISP_TEMPER_DMA_READER_AXI_MAXOSTAND_OFFSET (0x1d24)
#define ACAMERA_ISP_TEMPER_DMA_READER_AXI_MAXOSTAND_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_temper_dma_reader_axi_maxostand_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abacL);
    system_sw_write_32(base + 0x1abacL, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_temper_dma_reader_axi_maxostand_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1abacL) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: reader_axi_max_arlen
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        max value to use for awlen (axi burst length). 0000= max 1 transfer/burst , upto 1111= max 16 transfers/burst
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_READER_AXI_MAX_ARLEN_DEFAULT (0xf)
#define ACAMERA_ISP_TEMPER_DMA_READER_AXI_MAX_ARLEN_DATASIZE (4)
#define ACAMERA_ISP_TEMPER_DMA_READER_AXI_MAX_ARLEN_OFFSET (0x1d24)
#define ACAMERA_ISP_TEMPER_DMA_READER_AXI_MAX_ARLEN_MASK (0xf000000)

// args: data (4-bit)
static __inline void acamera_isp_temper_dma_reader_axi_max_arlen_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abacL);
    system_sw_write_32(base + 0x1abacL, (((uint32_t) (data & 0xf)) << 24) | (curr & 0xf0ffffff));
}
static __inline uint8_t acamera_isp_temper_dma_reader_axi_max_arlen_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1abacL) & 0xf000000) >> 24);
}
// ------------------------------------------------------------------------------ //
// Register: reader_pagewarm_on
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        active high, enables posting of pagewarm dummy writes to SMMU for early page translation of upcomming 4K pages. 
//        Recommend SMMU has min 8 page cache to avoid translation miss. Pagewarms are posted as dummy writes with wstrb= 0
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_TEMPER_DMA_READER_PAGEWARM_ON_DEFAULT (0)
#define ACAMERA_ISP_TEMPER_DMA_READER_PAGEWARM_ON_DATASIZE (1)
#define ACAMERA_ISP_TEMPER_DMA_READER_PAGEWARM_ON_OFFSET (0x1d24)
#define ACAMERA_ISP_TEMPER_DMA_READER_PAGEWARM_ON_MASK (0x10000000)

// args: data (1-bit)
static __inline void acamera_isp_temper_dma_reader_pagewarm_on_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abacL);
    system_sw_write_32(base + 0x1abacL, (((uint32_t) (data & 0x1)) << 28) | (curr & 0xefffffff));
}
static __inline uint8_t acamera_isp_temper_dma_reader_pagewarm_on_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1abacL) & 0x10000000) >> 28);
}
// ------------------------------------------------------------------------------ //
// Group: ca correction
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Ca Correction
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Enable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// module enable, if 0 the data_i(dw*(kh-1)/2+dw-1 downto dw*(kh-1)/2) is presented at data_o after pipeline length
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CA_CORRECTION_ENABLE_DEFAULT (0x0)
#define ACAMERA_ISP_CA_CORRECTION_ENABLE_DATASIZE (1)
#define ACAMERA_ISP_CA_CORRECTION_ENABLE_OFFSET (0x1d28)
#define ACAMERA_ISP_CA_CORRECTION_ENABLE_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_ca_correction_enable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abb0L);
    system_sw_write_32(base + 0x1abb0L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_ca_correction_enable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1abb0L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Mesh Scale
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// extra shift of mesh data: 00- no shift, 01- shift left by 1, ..., 11- shift left by 3, used to increase the range at cost of accuracy
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CA_CORRECTION_MESH_SCALE_DEFAULT (0x0)
#define ACAMERA_ISP_CA_CORRECTION_MESH_SCALE_DATASIZE (2)
#define ACAMERA_ISP_CA_CORRECTION_MESH_SCALE_OFFSET (0x1d28)
#define ACAMERA_ISP_CA_CORRECTION_MESH_SCALE_MASK (0x30)

// args: data (2-bit)
static __inline void acamera_isp_ca_correction_mesh_scale_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abb0L);
    system_sw_write_32(base + 0x1abb0L, (((uint32_t) (data & 0x3)) << 4) | (curr & 0xffffffcf));
}
static __inline uint8_t acamera_isp_ca_correction_mesh_scale_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1abb0L) & 0x30) >> 4);
}
// ------------------------------------------------------------------------------ //
// Register: Mesh Width
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//       		    number of tiles across. Maximum supported mesh width is 64. 
//       		
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CA_CORRECTION_MESH_WIDTH_DEFAULT (64)
#define ACAMERA_ISP_CA_CORRECTION_MESH_WIDTH_DATASIZE (7)
#define ACAMERA_ISP_CA_CORRECTION_MESH_WIDTH_OFFSET (0x1d2c)
#define ACAMERA_ISP_CA_CORRECTION_MESH_WIDTH_MASK (0x7f)

// args: data (7-bit)
static __inline void acamera_isp_ca_correction_mesh_width_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abb4L);
    system_sw_write_32(base + 0x1abb4L, (((uint32_t) (data & 0x7f)) << 0) | (curr & 0xffffff80));
}
static __inline uint8_t acamera_isp_ca_correction_mesh_width_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1abb4L) & 0x7f) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Mesh Height
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//       		number of tiles vertically. Maximum supported mesh height is 64 for RGGB sensor and 42 for RGBIr sensors.
//       		
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CA_CORRECTION_MESH_HEIGHT_DEFAULT (64)
#define ACAMERA_ISP_CA_CORRECTION_MESH_HEIGHT_DATASIZE (7)
#define ACAMERA_ISP_CA_CORRECTION_MESH_HEIGHT_OFFSET (0x1d2c)
#define ACAMERA_ISP_CA_CORRECTION_MESH_HEIGHT_MASK (0x7f0000)

// args: data (7-bit)
static __inline void acamera_isp_ca_correction_mesh_height_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abb4L);
    system_sw_write_32(base + 0x1abb4L, (((uint32_t) (data & 0x7f)) << 16) | (curr & 0xff80ffff));
}
static __inline uint8_t acamera_isp_ca_correction_mesh_height_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1abb4L) & 0x7f0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Line Offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset between lines of tiles, can differ from mesh_width, but its safe to keep same as mesh width
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CA_CORRECTION_LINE_OFFSET_DEFAULT (64)
#define ACAMERA_ISP_CA_CORRECTION_LINE_OFFSET_DATASIZE (13)
#define ACAMERA_ISP_CA_CORRECTION_LINE_OFFSET_OFFSET (0x1d30)
#define ACAMERA_ISP_CA_CORRECTION_LINE_OFFSET_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_ca_correction_line_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abb8L);
    system_sw_write_32(base + 0x1abb8L, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_ca_correction_line_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1abb8L) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Plane Offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset between colour planes, can differ from line_offset*mesh_height
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CA_CORRECTION_PLANE_OFFSET_DEFAULT (64)
#define ACAMERA_ISP_CA_CORRECTION_PLANE_OFFSET_DATASIZE (13)
#define ACAMERA_ISP_CA_CORRECTION_PLANE_OFFSET_OFFSET (0x1d30)
#define ACAMERA_ISP_CA_CORRECTION_PLANE_OFFSET_MASK (0x1fff0000)

// args: data (13-bit)
static __inline void acamera_isp_ca_correction_plane_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abb8L);
    system_sw_write_32(base + 0x1abb8L, (((uint32_t) (data & 0x1fff)) << 16) | (curr & 0xe000ffff));
}
static __inline uint16_t acamera_isp_ca_correction_plane_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1abb8L) & 0x1fff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Mesh Reload
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0-1 triggers mesh and filter coefficient reload in the internal cache. Used after RAM is updated by CPU Chromatic Aberration correction module
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CA_CORRECTION_MESH_RELOAD_DEFAULT (0x0)
#define ACAMERA_ISP_CA_CORRECTION_MESH_RELOAD_DATASIZE (1)
#define ACAMERA_ISP_CA_CORRECTION_MESH_RELOAD_OFFSET (0x1d34)
#define ACAMERA_ISP_CA_CORRECTION_MESH_RELOAD_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_ca_correction_mesh_reload_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abbcL);
    system_sw_write_32(base + 0x1abbcL, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_ca_correction_mesh_reload_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1abbcL) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Group: square be
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// sensor offset for the square module
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: black_level_in
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// input Data black level
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SQUARE_BE_BLACK_LEVEL_IN_DEFAULT (0x000)
#define ACAMERA_ISP_SQUARE_BE_BLACK_LEVEL_IN_DATASIZE (16)
#define ACAMERA_ISP_SQUARE_BE_BLACK_LEVEL_IN_OFFSET (0x1d38)
#define ACAMERA_ISP_SQUARE_BE_BLACK_LEVEL_IN_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_square_be_black_level_in_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abc0L);
    system_sw_write_32(base + 0x1abc0L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_square_be_black_level_in_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1abc0L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: black_level_out
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// output Data black level
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SQUARE_BE_BLACK_LEVEL_OUT_DEFAULT (0x000)
#define ACAMERA_ISP_SQUARE_BE_BLACK_LEVEL_OUT_DATASIZE (20)
#define ACAMERA_ISP_SQUARE_BE_BLACK_LEVEL_OUT_OFFSET (0x1d3c)
#define ACAMERA_ISP_SQUARE_BE_BLACK_LEVEL_OUT_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_square_be_black_level_out_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abc4L);
    system_sw_write_32(base + 0x1abc4L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_square_be_black_level_out_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x1abc4L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Group: sensor offset pre shading
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset subtraction for each color channel and exposure
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: offset 00
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset for color channel 00 (R)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SENSOR_OFFSET_PRE_SHADING_OFFSET_00_DEFAULT (0x00)
#define ACAMERA_ISP_SENSOR_OFFSET_PRE_SHADING_OFFSET_00_DATASIZE (20)
#define ACAMERA_ISP_SENSOR_OFFSET_PRE_SHADING_OFFSET_00_OFFSET (0x1d40)
#define ACAMERA_ISP_SENSOR_OFFSET_PRE_SHADING_OFFSET_00_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_sensor_offset_pre_shading_offset_00_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abc8L);
    system_sw_write_32(base + 0x1abc8L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_sensor_offset_pre_shading_offset_00_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x1abc8L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: offset 01
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset for color channel 01 (Gr)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SENSOR_OFFSET_PRE_SHADING_OFFSET_01_DEFAULT (0x00)
#define ACAMERA_ISP_SENSOR_OFFSET_PRE_SHADING_OFFSET_01_DATASIZE (20)
#define ACAMERA_ISP_SENSOR_OFFSET_PRE_SHADING_OFFSET_01_OFFSET (0x1d44)
#define ACAMERA_ISP_SENSOR_OFFSET_PRE_SHADING_OFFSET_01_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_sensor_offset_pre_shading_offset_01_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abccL);
    system_sw_write_32(base + 0x1abccL, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_sensor_offset_pre_shading_offset_01_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x1abccL) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: offset 10
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset for color channel 10 (Gb)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SENSOR_OFFSET_PRE_SHADING_OFFSET_10_DEFAULT (0x00)
#define ACAMERA_ISP_SENSOR_OFFSET_PRE_SHADING_OFFSET_10_DATASIZE (20)
#define ACAMERA_ISP_SENSOR_OFFSET_PRE_SHADING_OFFSET_10_OFFSET (0x1d48)
#define ACAMERA_ISP_SENSOR_OFFSET_PRE_SHADING_OFFSET_10_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_sensor_offset_pre_shading_offset_10_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abd0L);
    system_sw_write_32(base + 0x1abd0L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_sensor_offset_pre_shading_offset_10_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x1abd0L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: offset 11
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// offset offset for color channel 11 (B)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_SENSOR_OFFSET_PRE_SHADING_OFFSET_11_DEFAULT (0x00)
#define ACAMERA_ISP_SENSOR_OFFSET_PRE_SHADING_OFFSET_11_DATASIZE (20)
#define ACAMERA_ISP_SENSOR_OFFSET_PRE_SHADING_OFFSET_11_OFFSET (0x1d4c)
#define ACAMERA_ISP_SENSOR_OFFSET_PRE_SHADING_OFFSET_11_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_sensor_offset_pre_shading_offset_11_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abd4L);
    system_sw_write_32(base + 0x1abd4L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_sensor_offset_pre_shading_offset_11_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x1abd4L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Group: radial shading
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Radial Lens shading correction
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Enable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Lens shading correction enable: 0=off, 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RADIAL_SHADING_ENABLE_DEFAULT (0)
#define ACAMERA_ISP_RADIAL_SHADING_ENABLE_DATASIZE (1)
#define ACAMERA_ISP_RADIAL_SHADING_ENABLE_OFFSET (0x1d50)
#define ACAMERA_ISP_RADIAL_SHADING_ENABLE_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_radial_shading_enable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abd8L);
    system_sw_write_32(base + 0x1abd8L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_radial_shading_enable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1abd8L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: centerR x
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Center x coordinate of the red shading map
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RADIAL_SHADING_CENTERR_X_DEFAULT (0x3C0)
#define ACAMERA_ISP_RADIAL_SHADING_CENTERR_X_DATASIZE (16)
#define ACAMERA_ISP_RADIAL_SHADING_CENTERR_X_OFFSET (0x1d54)
#define ACAMERA_ISP_RADIAL_SHADING_CENTERR_X_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_radial_shading_centerr_x_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abdcL);
    system_sw_write_32(base + 0x1abdcL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_radial_shading_centerr_x_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1abdcL) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: centerR y
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Center y coordinate of the red shading map
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RADIAL_SHADING_CENTERR_Y_DEFAULT (0x21C)
#define ACAMERA_ISP_RADIAL_SHADING_CENTERR_Y_DATASIZE (16)
#define ACAMERA_ISP_RADIAL_SHADING_CENTERR_Y_OFFSET (0x1d54)
#define ACAMERA_ISP_RADIAL_SHADING_CENTERR_Y_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_radial_shading_centerr_y_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abdcL);
    system_sw_write_32(base + 0x1abdcL, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_radial_shading_centerr_y_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1abdcL) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: centerG x
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Center x coordinate of the green shading map
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RADIAL_SHADING_CENTERG_X_DEFAULT (0x3C0)
#define ACAMERA_ISP_RADIAL_SHADING_CENTERG_X_DATASIZE (16)
#define ACAMERA_ISP_RADIAL_SHADING_CENTERG_X_OFFSET (0x1d58)
#define ACAMERA_ISP_RADIAL_SHADING_CENTERG_X_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_radial_shading_centerg_x_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abe0L);
    system_sw_write_32(base + 0x1abe0L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_radial_shading_centerg_x_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1abe0L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: centerG y
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Center y coordinate of the green shading map
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RADIAL_SHADING_CENTERG_Y_DEFAULT (0x21C)
#define ACAMERA_ISP_RADIAL_SHADING_CENTERG_Y_DATASIZE (16)
#define ACAMERA_ISP_RADIAL_SHADING_CENTERG_Y_OFFSET (0x1d58)
#define ACAMERA_ISP_RADIAL_SHADING_CENTERG_Y_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_radial_shading_centerg_y_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abe0L);
    system_sw_write_32(base + 0x1abe0L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_radial_shading_centerg_y_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1abe0L) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: centerB x
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Center x coordinate of the blue shading map
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RADIAL_SHADING_CENTERB_X_DEFAULT (0x3C0)
#define ACAMERA_ISP_RADIAL_SHADING_CENTERB_X_DATASIZE (16)
#define ACAMERA_ISP_RADIAL_SHADING_CENTERB_X_OFFSET (0x1d5c)
#define ACAMERA_ISP_RADIAL_SHADING_CENTERB_X_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_radial_shading_centerb_x_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abe4L);
    system_sw_write_32(base + 0x1abe4L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_radial_shading_centerb_x_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1abe4L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: centerB y
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Center y coordinate of the blue shading map
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RADIAL_SHADING_CENTERB_Y_DEFAULT (0x21C)
#define ACAMERA_ISP_RADIAL_SHADING_CENTERB_Y_DATASIZE (16)
#define ACAMERA_ISP_RADIAL_SHADING_CENTERB_Y_OFFSET (0x1d5c)
#define ACAMERA_ISP_RADIAL_SHADING_CENTERB_Y_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_radial_shading_centerb_y_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abe4L);
    system_sw_write_32(base + 0x1abe4L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_radial_shading_centerb_y_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1abe4L) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: centerIr x
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Center x coordinate of the IR shading map
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RADIAL_SHADING_CENTERIR_X_DEFAULT (0x3C0)
#define ACAMERA_ISP_RADIAL_SHADING_CENTERIR_X_DATASIZE (16)
#define ACAMERA_ISP_RADIAL_SHADING_CENTERIR_X_OFFSET (0x1d60)
#define ACAMERA_ISP_RADIAL_SHADING_CENTERIR_X_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_radial_shading_centerir_x_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abe8L);
    system_sw_write_32(base + 0x1abe8L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_radial_shading_centerir_x_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1abe8L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: centerIr y
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Center y coordinate of the IR shading map
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RADIAL_SHADING_CENTERIR_Y_DEFAULT (0x21C)
#define ACAMERA_ISP_RADIAL_SHADING_CENTERIR_Y_DATASIZE (16)
#define ACAMERA_ISP_RADIAL_SHADING_CENTERIR_Y_OFFSET (0x1d60)
#define ACAMERA_ISP_RADIAL_SHADING_CENTERIR_Y_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_radial_shading_centerir_y_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abe8L);
    system_sw_write_32(base + 0x1abe8L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_radial_shading_centerir_y_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1abe8L) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: off center multRx
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Normalizing X factor which scales the Red radial table to the edge of the image.
//        Calculated as 2^31/R^2 where R is the furthest distance from the center coordinate to the edge of the image in pixels.
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTRX_DEFAULT (0x06EA)
#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTRX_DATASIZE (16)
#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTRX_OFFSET (0x1d64)
#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTRX_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_radial_shading_off_center_multrx_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abecL);
    system_sw_write_32(base + 0x1abecL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_radial_shading_off_center_multrx_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1abecL) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: off center multRy
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Normalizing Y factor which scales the Red radial table to the edge of the image.
//        Calculated as 2^31/R^2 where R is the furthest distance from the center coordinate to the edge of the image in pixels.
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTRY_DEFAULT (0x06EA)
#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTRY_DATASIZE (16)
#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTRY_OFFSET (0x1d64)
#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTRY_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_radial_shading_off_center_multry_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abecL);
    system_sw_write_32(base + 0x1abecL, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_radial_shading_off_center_multry_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1abecL) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: off center multGx
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Normalizing X factor which scales the green radial table to the edge of the image.
//        Calculated as 2^31/R^2 where R is the furthest distance from the center coordinate to the edge of the image in pixels.
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTGX_DEFAULT (0x06EA)
#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTGX_DATASIZE (16)
#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTGX_OFFSET (0x1d68)
#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTGX_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_radial_shading_off_center_multgx_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abf0L);
    system_sw_write_32(base + 0x1abf0L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_radial_shading_off_center_multgx_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1abf0L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: off center multGy
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Normalizing Y factor which scales the green radial table to the edge of the image.
//        Calculated as 2^31/R^2 where R is the furthest distance from the center coordinate to the edge of the image in pixels.
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTGY_DEFAULT (0x06EA)
#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTGY_DATASIZE (16)
#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTGY_OFFSET (0x1d68)
#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTGY_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_radial_shading_off_center_multgy_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abf0L);
    system_sw_write_32(base + 0x1abf0L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_radial_shading_off_center_multgy_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1abf0L) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: off center multBx
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Normalizing X factor which scales the blue radial table to the edge of the image.
//        Calculated as 2^31/R^2 where R is the furthest distance from the center coordinate to the edge of the image in pixels.
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTBX_DEFAULT (0x06EA)
#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTBX_DATASIZE (16)
#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTBX_OFFSET (0x1d6c)
#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTBX_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_radial_shading_off_center_multbx_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abf4L);
    system_sw_write_32(base + 0x1abf4L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_radial_shading_off_center_multbx_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1abf4L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: off center multBy
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Normalizing Y factor which scales the blue radial table to the edge of the image.
//        Calculated as 2^31/R^2 where R is the furthest distance from the center coordinate to the edge of the image in pixels.
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTBY_DEFAULT (0x06EA)
#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTBY_DATASIZE (16)
#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTBY_OFFSET (0x1d6c)
#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTBY_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_radial_shading_off_center_multby_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abf4L);
    system_sw_write_32(base + 0x1abf4L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_radial_shading_off_center_multby_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1abf4L) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: off center multIRx
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Normalizing X factor which scales the Ir radial table to the edge of the image.
//        Calculated as 2^31/R^2 where R is the furthest distance from the center coordinate to the edge of the image in pixels.
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTIRX_DEFAULT (0x06EA)
#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTIRX_DATASIZE (16)
#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTIRX_OFFSET (0x1d70)
#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTIRX_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_radial_shading_off_center_multirx_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abf8L);
    system_sw_write_32(base + 0x1abf8L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_radial_shading_off_center_multirx_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1abf8L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: off center multIRy
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Normalizing Y factor which scales the Ir radial table to the edge of the image.
//        Calculated as 2^31/R^2 where R is the furthest distance from the center coordinate to the edge of the image in pixels.
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTIRY_DEFAULT (0x06EA)
#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTIRY_DATASIZE (16)
#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTIRY_OFFSET (0x1d70)
#define ACAMERA_ISP_RADIAL_SHADING_OFF_CENTER_MULTIRY_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_radial_shading_off_center_multiry_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abf8L);
    system_sw_write_32(base + 0x1abf8L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_radial_shading_off_center_multiry_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1abf8L) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Group: mesh shading
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Mesh Lens shading correction
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Enable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Lens shading correction enable: 0=off, 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_MESH_SHADING_ENABLE_DEFAULT (0)
#define ACAMERA_ISP_MESH_SHADING_ENABLE_DATASIZE (1)
#define ACAMERA_ISP_MESH_SHADING_ENABLE_OFFSET (0x1d74)
#define ACAMERA_ISP_MESH_SHADING_ENABLE_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_mesh_shading_enable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abfcL);
    system_sw_write_32(base + 0x1abfcL, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_mesh_shading_enable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1abfcL) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Mesh show
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Lens shading correction debug: 0=off, 1=on (show mesh data)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_MESH_SHADING_MESH_SHOW_DEFAULT (1)
#define ACAMERA_ISP_MESH_SHADING_MESH_SHOW_DATASIZE (1)
#define ACAMERA_ISP_MESH_SHADING_MESH_SHOW_OFFSET (0x1d74)
#define ACAMERA_ISP_MESH_SHADING_MESH_SHOW_MASK (0x2)

// args: data (1-bit)
static __inline void acamera_isp_mesh_shading_mesh_show_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abfcL);
    system_sw_write_32(base + 0x1abfcL, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
}
static __inline uint8_t acamera_isp_mesh_shading_mesh_show_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1abfcL) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: Mesh scale
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Selects the precision and maximal gain range of mesh shading correction
//        Gain range:    00- 0..2; 01- 0..4; 02- 0..8; 03- 0..16; 04- 1..2; 05- 1..3; 06- 1..5; 07- 1..9(float)
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_MESH_SHADING_MESH_SCALE_DEFAULT (1)
#define ACAMERA_ISP_MESH_SHADING_MESH_SCALE_DATASIZE (3)
#define ACAMERA_ISP_MESH_SHADING_MESH_SCALE_OFFSET (0x1d74)
#define ACAMERA_ISP_MESH_SHADING_MESH_SCALE_MASK (0x1c)

// args: data (3-bit)
static __inline void acamera_isp_mesh_shading_mesh_scale_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abfcL);
    system_sw_write_32(base + 0x1abfcL, (((uint32_t) (data & 0x7)) << 2) | (curr & 0xffffffe3));
}
static __inline uint8_t acamera_isp_mesh_shading_mesh_scale_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1abfcL) & 0x1c) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: Mesh alpha mode
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Sets alpha blending between mesh shading tables.
//        0 = no alpha blending; 
//        1=2 banks (odd/even bytes) 
//        2=4 banks (one per 8 bit lane in each dword)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_MODE_DEFAULT (0)
#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_MODE_DATASIZE (2)
#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_MODE_OFFSET (0x1d74)
#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_MODE_MASK (0x60)

// args: data (2-bit)
static __inline void acamera_isp_mesh_shading_mesh_alpha_mode_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abfcL);
    system_sw_write_32(base + 0x1abfcL, (((uint32_t) (data & 0x3)) << 5) | (curr & 0xffffff9f));
}
static __inline uint8_t acamera_isp_mesh_shading_mesh_alpha_mode_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1abfcL) & 0x60) >> 5);
}
// ------------------------------------------------------------------------------ //
// Register: Mesh page R
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Selects memory page for red pixels correction.  See ISP guide for further details
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_MESH_SHADING_MESH_PAGE_R_DEFAULT (0)
#define ACAMERA_ISP_MESH_SHADING_MESH_PAGE_R_DATASIZE (2)
#define ACAMERA_ISP_MESH_SHADING_MESH_PAGE_R_OFFSET (0x1d74)
#define ACAMERA_ISP_MESH_SHADING_MESH_PAGE_R_MASK (0x300)

// args: data (2-bit)
static __inline void acamera_isp_mesh_shading_mesh_page_r_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abfcL);
    system_sw_write_32(base + 0x1abfcL, (((uint32_t) (data & 0x3)) << 8) | (curr & 0xfffffcff));
}
static __inline uint8_t acamera_isp_mesh_shading_mesh_page_r_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1abfcL) & 0x300) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: Mesh page G
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Selects memory page for green pixels correction.  See ISP guide for further details
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_MESH_SHADING_MESH_PAGE_G_DEFAULT (1)
#define ACAMERA_ISP_MESH_SHADING_MESH_PAGE_G_DATASIZE (2)
#define ACAMERA_ISP_MESH_SHADING_MESH_PAGE_G_OFFSET (0x1d74)
#define ACAMERA_ISP_MESH_SHADING_MESH_PAGE_G_MASK (0xc00)

// args: data (2-bit)
static __inline void acamera_isp_mesh_shading_mesh_page_g_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abfcL);
    system_sw_write_32(base + 0x1abfcL, (((uint32_t) (data & 0x3)) << 10) | (curr & 0xfffff3ff));
}
static __inline uint8_t acamera_isp_mesh_shading_mesh_page_g_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1abfcL) & 0xc00) >> 10);
}
// ------------------------------------------------------------------------------ //
// Register: Mesh page B
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Selects memory page for blue pixels correction.  See ISP guide for further details
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_MESH_SHADING_MESH_PAGE_B_DEFAULT (2)
#define ACAMERA_ISP_MESH_SHADING_MESH_PAGE_B_DATASIZE (2)
#define ACAMERA_ISP_MESH_SHADING_MESH_PAGE_B_OFFSET (0x1d74)
#define ACAMERA_ISP_MESH_SHADING_MESH_PAGE_B_MASK (0x3000)

// args: data (2-bit)
static __inline void acamera_isp_mesh_shading_mesh_page_b_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abfcL);
    system_sw_write_32(base + 0x1abfcL, (((uint32_t) (data & 0x3)) << 12) | (curr & 0xffffcfff));
}
static __inline uint8_t acamera_isp_mesh_shading_mesh_page_b_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1abfcL) & 0x3000) >> 12);
}
// ------------------------------------------------------------------------------ //
// Register: Mesh page Ir
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Selects memory page for IR pixels correction.  See ISP guide for further details
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_MESH_SHADING_MESH_PAGE_IR_DEFAULT (3)
#define ACAMERA_ISP_MESH_SHADING_MESH_PAGE_IR_DATASIZE (2)
#define ACAMERA_ISP_MESH_SHADING_MESH_PAGE_IR_OFFSET (0x1d74)
#define ACAMERA_ISP_MESH_SHADING_MESH_PAGE_IR_MASK (0xc000)

// args: data (2-bit)
static __inline void acamera_isp_mesh_shading_mesh_page_ir_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abfcL);
    system_sw_write_32(base + 0x1abfcL, (((uint32_t) (data & 0x3)) << 14) | (curr & 0xffff3fff));
}
static __inline uint8_t acamera_isp_mesh_shading_mesh_page_ir_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1abfcL) & 0xc000) >> 14);
}
// ------------------------------------------------------------------------------ //
// Register: Mesh width
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Number of horizontal nodes minus 1
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_MESH_SHADING_MESH_WIDTH_DEFAULT (63)
#define ACAMERA_ISP_MESH_SHADING_MESH_WIDTH_DATASIZE (6)
#define ACAMERA_ISP_MESH_SHADING_MESH_WIDTH_OFFSET (0x1d74)
#define ACAMERA_ISP_MESH_SHADING_MESH_WIDTH_MASK (0x3f0000)

// args: data (6-bit)
static __inline void acamera_isp_mesh_shading_mesh_width_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abfcL);
    system_sw_write_32(base + 0x1abfcL, (((uint32_t) (data & 0x3f)) << 16) | (curr & 0xffc0ffff));
}
static __inline uint8_t acamera_isp_mesh_shading_mesh_width_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1abfcL) & 0x3f0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Mesh height
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Number of vertical nodes minus 1
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_MESH_SHADING_MESH_HEIGHT_DEFAULT (63)
#define ACAMERA_ISP_MESH_SHADING_MESH_HEIGHT_DATASIZE (6)
#define ACAMERA_ISP_MESH_SHADING_MESH_HEIGHT_OFFSET (0x1d74)
#define ACAMERA_ISP_MESH_SHADING_MESH_HEIGHT_MASK (0x3f000000)

// args: data (6-bit)
static __inline void acamera_isp_mesh_shading_mesh_height_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1abfcL);
    system_sw_write_32(base + 0x1abfcL, (((uint32_t) (data & 0x3f)) << 24) | (curr & 0xc0ffffff));
}
static __inline uint8_t acamera_isp_mesh_shading_mesh_height_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1abfcL) & 0x3f000000) >> 24);
}
// ------------------------------------------------------------------------------ //
// Register: Mesh reload
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0-1 triggers cache reload
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_MESH_SHADING_MESH_RELOAD_DEFAULT (0)
#define ACAMERA_ISP_MESH_SHADING_MESH_RELOAD_DATASIZE (1)
#define ACAMERA_ISP_MESH_SHADING_MESH_RELOAD_OFFSET (0x1d78)
#define ACAMERA_ISP_MESH_SHADING_MESH_RELOAD_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_mesh_shading_mesh_reload_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac00L);
    system_sw_write_32(base + 0x1ac00L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_mesh_shading_mesh_reload_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac00L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Mesh alpha bank R
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bank selection for R blend: 0: 0+1; 1: 1+2; 2: 2:3; 3: 3+0; 4:0+2; 5: 1+3; 6,7: reserved
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_BANK_R_DEFAULT (0)
#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_BANK_R_DATASIZE (3)
#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_BANK_R_OFFSET (0x1d7c)
#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_BANK_R_MASK (0x7)

// args: data (3-bit)
static __inline void acamera_isp_mesh_shading_mesh_alpha_bank_r_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac04L);
    system_sw_write_32(base + 0x1ac04L, (((uint32_t) (data & 0x7)) << 0) | (curr & 0xfffffff8));
}
static __inline uint8_t acamera_isp_mesh_shading_mesh_alpha_bank_r_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac04L) & 0x7) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Mesh alpha bank G
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bank selection for G blend: 0: 0+1; 1: 1+2; 2: 2:3; 3: 3+0; 4:0+2; 5: 1+3; 6,7: reserved: 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_BANK_G_DEFAULT (0)
#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_BANK_G_DATASIZE (3)
#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_BANK_G_OFFSET (0x1d7c)
#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_BANK_G_MASK (0x38)

// args: data (3-bit)
static __inline void acamera_isp_mesh_shading_mesh_alpha_bank_g_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac04L);
    system_sw_write_32(base + 0x1ac04L, (((uint32_t) (data & 0x7)) << 3) | (curr & 0xffffffc7));
}
static __inline uint8_t acamera_isp_mesh_shading_mesh_alpha_bank_g_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac04L) & 0x38) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: Mesh alpha bank B
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bank selection for B blend: 0: 0+1; 1: 1+2; 2: 2:3; 3: 3+0; 4:0+2; 5: 1+3; 6,7: reserved
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_BANK_B_DEFAULT (0)
#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_BANK_B_DATASIZE (3)
#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_BANK_B_OFFSET (0x1d7c)
#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_BANK_B_MASK (0x1c0)

// args: data (3-bit)
static __inline void acamera_isp_mesh_shading_mesh_alpha_bank_b_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac04L);
    system_sw_write_32(base + 0x1ac04L, (((uint32_t) (data & 0x7)) << 6) | (curr & 0xfffffe3f));
}
static __inline uint8_t acamera_isp_mesh_shading_mesh_alpha_bank_b_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac04L) & 0x1c0) >> 6);
}
// ------------------------------------------------------------------------------ //
// Register: Mesh alpha bank Ir
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bank selection for Ir blend: 0: 0+1; 1: 1+2; 2: 2:3; 3: 3+0; 4:0+2; 5: 1+3; 6,7: reserved
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_BANK_IR_DEFAULT (0)
#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_BANK_IR_DATASIZE (3)
#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_BANK_IR_OFFSET (0x1d7c)
#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_BANK_IR_MASK (0xe00)

// args: data (3-bit)
static __inline void acamera_isp_mesh_shading_mesh_alpha_bank_ir_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac04L);
    system_sw_write_32(base + 0x1ac04L, (((uint32_t) (data & 0x7)) << 9) | (curr & 0xfffff1ff));
}
static __inline uint8_t acamera_isp_mesh_shading_mesh_alpha_bank_ir_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac04L) & 0xe00) >> 9);
}
// ------------------------------------------------------------------------------ //
// Register: Mesh alpha R
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Alpha blend coeff for R
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_R_DEFAULT (0)
#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_R_DATASIZE (8)
#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_R_OFFSET (0x1d80)
#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_R_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_mesh_shading_mesh_alpha_r_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac08L);
    system_sw_write_32(base + 0x1ac08L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_mesh_shading_mesh_alpha_r_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac08L) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Mesh alpha G
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Alpha blend coeff for G
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_G_DEFAULT (0)
#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_G_DATASIZE (8)
#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_G_OFFSET (0x1d80)
#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_G_MASK (0xff00)

// args: data (8-bit)
static __inline void acamera_isp_mesh_shading_mesh_alpha_g_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac08L);
    system_sw_write_32(base + 0x1ac08L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
}
static __inline uint8_t acamera_isp_mesh_shading_mesh_alpha_g_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac08L) & 0xff00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: Mesh alpha B
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Alpha blend coeff for B
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_B_DEFAULT (0)
#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_B_DATASIZE (8)
#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_B_OFFSET (0x1d80)
#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_B_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_mesh_shading_mesh_alpha_b_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac08L);
    system_sw_write_32(base + 0x1ac08L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_mesh_shading_mesh_alpha_b_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac08L) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Mesh alpha Ir
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Alpha blend coeff for IR
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_IR_DEFAULT (0)
#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_IR_DATASIZE (8)
#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_IR_OFFSET (0x1d80)
#define ACAMERA_ISP_MESH_SHADING_MESH_ALPHA_IR_MASK (0xff000000)

// args: data (8-bit)
static __inline void acamera_isp_mesh_shading_mesh_alpha_ir_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac08L);
    system_sw_write_32(base + 0x1ac08L, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
}
static __inline uint8_t acamera_isp_mesh_shading_mesh_alpha_ir_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac08L) & 0xff000000) >> 24);
}
// ------------------------------------------------------------------------------ //
// Register: Mesh strength
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Mesh strength in 4.12 format, e.g. 0 - no correction, 4096 - correction to match mesh data. Can be used to reduce shading correction based on AE.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_MESH_SHADING_MESH_STRENGTH_DEFAULT (0x1000)
#define ACAMERA_ISP_MESH_SHADING_MESH_STRENGTH_DATASIZE (16)
#define ACAMERA_ISP_MESH_SHADING_MESH_STRENGTH_OFFSET (0x1d84)
#define ACAMERA_ISP_MESH_SHADING_MESH_STRENGTH_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_mesh_shading_mesh_strength_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac0cL);
    system_sw_write_32(base + 0x1ac0cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_mesh_shading_mesh_strength_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ac0cL) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Group: white balance
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Static white balance - independent gain for each color channel
//      
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Gain 00
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Multiplier for color channel 00 (R)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_WHITE_BALANCE_GAIN_00_DEFAULT (0x100)
#define ACAMERA_ISP_WHITE_BALANCE_GAIN_00_DATASIZE (12)
#define ACAMERA_ISP_WHITE_BALANCE_GAIN_00_OFFSET (0x1d88)
#define ACAMERA_ISP_WHITE_BALANCE_GAIN_00_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_white_balance_gain_00_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac10L);
    system_sw_write_32(base + 0x1ac10L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_white_balance_gain_00_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ac10L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Gain 01
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Multiplier for color channel 01 (Gr)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_WHITE_BALANCE_GAIN_01_DEFAULT (0x100)
#define ACAMERA_ISP_WHITE_BALANCE_GAIN_01_DATASIZE (12)
#define ACAMERA_ISP_WHITE_BALANCE_GAIN_01_OFFSET (0x1d88)
#define ACAMERA_ISP_WHITE_BALANCE_GAIN_01_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_white_balance_gain_01_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac10L);
    system_sw_write_32(base + 0x1ac10L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_white_balance_gain_01_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ac10L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Gain 10
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Multiplier for color channel 10 (Gb)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_WHITE_BALANCE_GAIN_10_DEFAULT (0x100)
#define ACAMERA_ISP_WHITE_BALANCE_GAIN_10_DATASIZE (12)
#define ACAMERA_ISP_WHITE_BALANCE_GAIN_10_OFFSET (0x1d8c)
#define ACAMERA_ISP_WHITE_BALANCE_GAIN_10_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_white_balance_gain_10_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac14L);
    system_sw_write_32(base + 0x1ac14L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_white_balance_gain_10_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ac14L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Gain 11
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Multiplier for color channel 11 (B)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_WHITE_BALANCE_GAIN_11_DEFAULT (0x100)
#define ACAMERA_ISP_WHITE_BALANCE_GAIN_11_DATASIZE (12)
#define ACAMERA_ISP_WHITE_BALANCE_GAIN_11_OFFSET (0x1d8c)
#define ACAMERA_ISP_WHITE_BALANCE_GAIN_11_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_white_balance_gain_11_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac14L);
    system_sw_write_32(base + 0x1ac14L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_white_balance_gain_11_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ac14L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Group: white balance aexp
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Static white balance - independent gain for each color channel
//      
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Gain 00
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Multiplier for color channel 00 (R)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_WHITE_BALANCE_AEXP_GAIN_00_DEFAULT (0x100)
#define ACAMERA_ISP_WHITE_BALANCE_AEXP_GAIN_00_DATASIZE (12)
#define ACAMERA_ISP_WHITE_BALANCE_AEXP_GAIN_00_OFFSET (0x1d90)
#define ACAMERA_ISP_WHITE_BALANCE_AEXP_GAIN_00_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_white_balance_aexp_gain_00_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac18L);
    system_sw_write_32(base + 0x1ac18L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_white_balance_aexp_gain_00_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ac18L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Gain 01
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Multiplier for color channel 01 (Gr)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_WHITE_BALANCE_AEXP_GAIN_01_DEFAULT (0x100)
#define ACAMERA_ISP_WHITE_BALANCE_AEXP_GAIN_01_DATASIZE (12)
#define ACAMERA_ISP_WHITE_BALANCE_AEXP_GAIN_01_OFFSET (0x1d90)
#define ACAMERA_ISP_WHITE_BALANCE_AEXP_GAIN_01_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_white_balance_aexp_gain_01_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac18L);
    system_sw_write_32(base + 0x1ac18L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_white_balance_aexp_gain_01_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ac18L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Gain 10
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Multiplier for color channel 10 (Gb)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_WHITE_BALANCE_AEXP_GAIN_10_DEFAULT (0x100)
#define ACAMERA_ISP_WHITE_BALANCE_AEXP_GAIN_10_DATASIZE (12)
#define ACAMERA_ISP_WHITE_BALANCE_AEXP_GAIN_10_OFFSET (0x1d94)
#define ACAMERA_ISP_WHITE_BALANCE_AEXP_GAIN_10_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_white_balance_aexp_gain_10_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac1cL);
    system_sw_write_32(base + 0x1ac1cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_white_balance_aexp_gain_10_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ac1cL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Gain 11
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Multiplier for color channel 11 (B)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_WHITE_BALANCE_AEXP_GAIN_11_DEFAULT (0x100)
#define ACAMERA_ISP_WHITE_BALANCE_AEXP_GAIN_11_DATASIZE (12)
#define ACAMERA_ISP_WHITE_BALANCE_AEXP_GAIN_11_OFFSET (0x1d94)
#define ACAMERA_ISP_WHITE_BALANCE_AEXP_GAIN_11_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_white_balance_aexp_gain_11_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac1cL);
    system_sw_write_32(base + 0x1ac1cL, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_white_balance_aexp_gain_11_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ac1cL) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Group: iridix gain
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Digital gain for RAW sensor data
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Gain
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Gain applied to data in 4.8 format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_GAIN_GAIN_DEFAULT (0x100)
#define ACAMERA_ISP_IRIDIX_GAIN_GAIN_DATASIZE (12)
#define ACAMERA_ISP_IRIDIX_GAIN_GAIN_OFFSET (0x1d98)
#define ACAMERA_ISP_IRIDIX_GAIN_GAIN_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_iridix_gain_gain_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac20L);
    system_sw_write_32(base + 0x1ac20L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_iridix_gain_gain_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ac20L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Data black level
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_GAIN_OFFSET_DEFAULT (0x000)
#define ACAMERA_ISP_IRIDIX_GAIN_OFFSET_DATASIZE (20)
#define ACAMERA_ISP_IRIDIX_GAIN_OFFSET_OFFSET (0x1d9c)
#define ACAMERA_ISP_IRIDIX_GAIN_OFFSET_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_iridix_gain_offset_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac24L);
    system_sw_write_32(base + 0x1ac24L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_iridix_gain_offset_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x1ac24L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Group: iridix
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//                 Iridix is an adaptive, space-variant tone mapping engine.
//                 It is used to maintain or enhance shadow detail while preserving highlights.
//             
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: iridix_on
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Iridix enable: 0=off 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_ENABLE_DEFAULT (0x1)
#define ACAMERA_ISP_IRIDIX_ENABLE_DATASIZE (1)
#define ACAMERA_ISP_IRIDIX_ENABLE_OFFSET (0x1da0)
#define ACAMERA_ISP_IRIDIX_ENABLE_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_iridix_enable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac28L);
    system_sw_write_32(base + 0x1ac28L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_iridix_enable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac28L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: max_alg_type
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Max Bayer Algorithm Type.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_MAX_ALG_TYPE_DEFAULT (0x1)
#define ACAMERA_ISP_IRIDIX_MAX_ALG_TYPE_DATASIZE (1)
#define ACAMERA_ISP_IRIDIX_MAX_ALG_TYPE_OFFSET (0x1da0)
#define ACAMERA_ISP_IRIDIX_MAX_ALG_TYPE_MASK (0x8)

// args: data (1-bit)
static __inline void acamera_isp_iridix_max_alg_type_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac28L);
    system_sw_write_32(base + 0x1ac28L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
}
static __inline uint8_t acamera_isp_iridix_max_alg_type_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac28L) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: black_level_amp0
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 1=Ignore Black level (set to zero) in amplificator. 0=Use Black level value.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_BLACK_LEVEL_AMP0_DEFAULT (0x1)
#define ACAMERA_ISP_IRIDIX_BLACK_LEVEL_AMP0_DATASIZE (1)
#define ACAMERA_ISP_IRIDIX_BLACK_LEVEL_AMP0_OFFSET (0x1da0)
#define ACAMERA_ISP_IRIDIX_BLACK_LEVEL_AMP0_MASK (0x20)

// args: data (1-bit)
static __inline void acamera_isp_iridix_black_level_amp0_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac28L);
    system_sw_write_32(base + 0x1ac28L, (((uint32_t) (data & 0x1)) << 5) | (curr & 0xffffffdf));
}
static __inline uint8_t acamera_isp_iridix_black_level_amp0_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac28L) & 0x20) >> 5);
}
// ------------------------------------------------------------------------------ //
// Register: postgamma_pos
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// PosGamma application  0=gain 1=data
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_POSTGAMMA_POS_DEFAULT (0x0)
#define ACAMERA_ISP_IRIDIX_POSTGAMMA_POS_DATASIZE (1)
#define ACAMERA_ISP_IRIDIX_POSTGAMMA_POS_OFFSET (0x1da0)
#define ACAMERA_ISP_IRIDIX_POSTGAMMA_POS_MASK (0x40)

// args: data (1-bit)
static __inline void acamera_isp_iridix_postgamma_pos_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac28L);
    system_sw_write_32(base + 0x1ac28L, (((uint32_t) (data & 0x1)) << 6) | (curr & 0xffffffbf));
}
static __inline uint8_t acamera_isp_iridix_postgamma_pos_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac28L) & 0x40) >> 6);
}
// ------------------------------------------------------------------------------ //
// Register: collect_ovl
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_COLLECT_OVL_DEFAULT (0x0)
#define ACAMERA_ISP_IRIDIX_COLLECT_OVL_DATASIZE (1)
#define ACAMERA_ISP_IRIDIX_COLLECT_OVL_OFFSET (0x1da0)
#define ACAMERA_ISP_IRIDIX_COLLECT_OVL_MASK (0x100)

// args: data (1-bit)
static __inline void acamera_isp_iridix_collect_ovl_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac28L);
    system_sw_write_32(base + 0x1ac28L, (((uint32_t) (data & 0x1)) << 8) | (curr & 0xfffffeff));
}
static __inline uint8_t acamera_isp_iridix_collect_ovl_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac28L) & 0x100) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: collect_rnd
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_COLLECT_RND_DEFAULT (0x1)
#define ACAMERA_ISP_IRIDIX_COLLECT_RND_DATASIZE (1)
#define ACAMERA_ISP_IRIDIX_COLLECT_RND_OFFSET (0x1da0)
#define ACAMERA_ISP_IRIDIX_COLLECT_RND_MASK (0x200)

// args: data (1-bit)
static __inline void acamera_isp_iridix_collect_rnd_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac28L);
    system_sw_write_32(base + 0x1ac28L, (((uint32_t) (data & 0x1)) << 9) | (curr & 0xfffffdff));
}
static __inline uint8_t acamera_isp_iridix_collect_rnd_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac28L) & 0x200) >> 9);
}
// ------------------------------------------------------------------------------ //
// Register: stat_norm
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_STAT_NORM_DEFAULT (0x1)
#define ACAMERA_ISP_IRIDIX_STAT_NORM_DATASIZE (1)
#define ACAMERA_ISP_IRIDIX_STAT_NORM_OFFSET (0x1da0)
#define ACAMERA_ISP_IRIDIX_STAT_NORM_MASK (0x400)

// args: data (1-bit)
static __inline void acamera_isp_iridix_stat_norm_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac28L);
    system_sw_write_32(base + 0x1ac28L, (((uint32_t) (data & 0x1)) << 10) | (curr & 0xfffffbff));
}
static __inline uint8_t acamera_isp_iridix_stat_norm_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac28L) & 0x400) >> 10);
}
// ------------------------------------------------------------------------------ //
// Register: stat_mult
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_STAT_MULT_DEFAULT (0x1)
#define ACAMERA_ISP_IRIDIX_STAT_MULT_DATASIZE (2)
#define ACAMERA_ISP_IRIDIX_STAT_MULT_OFFSET (0x1da0)
#define ACAMERA_ISP_IRIDIX_STAT_MULT_MASK (0xc000)

// args: data (2-bit)
static __inline void acamera_isp_iridix_stat_mult_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac28L);
    system_sw_write_32(base + 0x1ac28L, (((uint32_t) (data & 0x3)) << 14) | (curr & 0xffff3fff));
}
static __inline uint8_t acamera_isp_iridix_stat_mult_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac28L) & 0xc000) >> 14);
}
// ------------------------------------------------------------------------------ //
// Register: variance_space
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Sets the degree of spatial sensitivity of the algorithm(Irdx7F)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_VARIANCE_SPACE_DEFAULT (0x2)
#define ACAMERA_ISP_IRIDIX_VARIANCE_SPACE_DATASIZE (4)
#define ACAMERA_ISP_IRIDIX_VARIANCE_SPACE_OFFSET (0x1da4)
#define ACAMERA_ISP_IRIDIX_VARIANCE_SPACE_MASK (0xf)

// args: data (4-bit)
static __inline void acamera_isp_iridix_variance_space_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac2cL);
    system_sw_write_32(base + 0x1ac2cL, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
}
static __inline uint8_t acamera_isp_iridix_variance_space_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac2cL) & 0xf) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: variance_intensity
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Sets the degree of luminance sensitivity of the algorithm(Irdx7F)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_VARIANCE_INTENSITY_DEFAULT (0x1)
#define ACAMERA_ISP_IRIDIX_VARIANCE_INTENSITY_DATASIZE (4)
#define ACAMERA_ISP_IRIDIX_VARIANCE_INTENSITY_OFFSET (0x1da4)
#define ACAMERA_ISP_IRIDIX_VARIANCE_INTENSITY_MASK (0xf0)

// args: data (4-bit)
static __inline void acamera_isp_iridix_variance_intensity_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac2cL);
    system_sw_write_32(base + 0x1ac2cL, (((uint32_t) (data & 0xf)) << 4) | (curr & 0xffffff0f));
}
static __inline uint8_t acamera_isp_iridix_variance_intensity_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac2cL) & 0xf0) >> 4);
}
// ------------------------------------------------------------------------------ //
// Register: slope_max
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Restricts the maximum slope (gain) which can be generated by the adaptive algorithm
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_SLOPE_MAX_DEFAULT (0x80)
#define ACAMERA_ISP_IRIDIX_SLOPE_MAX_DATASIZE (8)
#define ACAMERA_ISP_IRIDIX_SLOPE_MAX_OFFSET (0x1da4)
#define ACAMERA_ISP_IRIDIX_SLOPE_MAX_MASK (0xff00)

// args: data (8-bit)
static __inline void acamera_isp_iridix_slope_max_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac2cL);
    system_sw_write_32(base + 0x1ac2cL, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
}
static __inline uint8_t acamera_isp_iridix_slope_max_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac2cL) & 0xff00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: slope_min
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Restricts the minimum slope (gain) which can be generated by the adaptive algorithm
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_SLOPE_MIN_DEFAULT (0x40)
#define ACAMERA_ISP_IRIDIX_SLOPE_MIN_DATASIZE (8)
#define ACAMERA_ISP_IRIDIX_SLOPE_MIN_OFFSET (0x1da4)
#define ACAMERA_ISP_IRIDIX_SLOPE_MIN_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_iridix_slope_min_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac2cL);
    system_sw_write_32(base + 0x1ac2cL, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_iridix_slope_min_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac2cL) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: black_level
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Iridix black level. Values below this will not be affected by Iridix.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_BLACK_LEVEL_DEFAULT (0x0000)
#define ACAMERA_ISP_IRIDIX_BLACK_LEVEL_DATASIZE (20)
#define ACAMERA_ISP_IRIDIX_BLACK_LEVEL_OFFSET (0x1da8)
#define ACAMERA_ISP_IRIDIX_BLACK_LEVEL_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_iridix_black_level_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac30L);
    system_sw_write_32(base + 0x1ac30L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_iridix_black_level_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x1ac30L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: white_level
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Iridix white level. Values above this will not be affected by Iridix.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_WHITE_LEVEL_DEFAULT (0xFFFF)
#define ACAMERA_ISP_IRIDIX_WHITE_LEVEL_DATASIZE (20)
#define ACAMERA_ISP_IRIDIX_WHITE_LEVEL_OFFSET (0x1dac)
#define ACAMERA_ISP_IRIDIX_WHITE_LEVEL_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_iridix_white_level_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac34L);
    system_sw_write_32(base + 0x1ac34L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_iridix_white_level_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x1ac34L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: collection_correction
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_COLLECTION_CORRECTION_DEFAULT (0x100)
#define ACAMERA_ISP_IRIDIX_COLLECTION_CORRECTION_DATASIZE (12)
#define ACAMERA_ISP_IRIDIX_COLLECTION_CORRECTION_OFFSET (0x1db0)
#define ACAMERA_ISP_IRIDIX_COLLECTION_CORRECTION_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_iridix_collection_correction_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac38L);
    system_sw_write_32(base + 0x1ac38L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_iridix_collection_correction_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ac38L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: fwd_percept_control
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Iridix gamma processing select: 0=pass through 1=gamma_dl 2=sqrt 3=gamma_lut.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_FWD_PERCEPT_CONTROL_DEFAULT (0x1)
#define ACAMERA_ISP_IRIDIX_FWD_PERCEPT_CONTROL_DATASIZE (2)
#define ACAMERA_ISP_IRIDIX_FWD_PERCEPT_CONTROL_OFFSET (0x1db4)
#define ACAMERA_ISP_IRIDIX_FWD_PERCEPT_CONTROL_MASK (0x3)

// args: data (2-bit)
static __inline void acamera_isp_iridix_fwd_percept_control_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac3cL);
    system_sw_write_32(base + 0x1ac3cL, (((uint32_t) (data & 0x3)) << 0) | (curr & 0xfffffffc));
}
static __inline uint8_t acamera_isp_iridix_fwd_percept_control_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac3cL) & 0x3) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: rev_percept_control
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Iridix gamma processing select: 0=pass through 1=gamma_dl 2=sqrt 3=gamma_lut.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_REV_PERCEPT_CONTROL_DEFAULT (0x1)
#define ACAMERA_ISP_IRIDIX_REV_PERCEPT_CONTROL_DATASIZE (2)
#define ACAMERA_ISP_IRIDIX_REV_PERCEPT_CONTROL_OFFSET (0x1db4)
#define ACAMERA_ISP_IRIDIX_REV_PERCEPT_CONTROL_MASK (0x300)

// args: data (2-bit)
static __inline void acamera_isp_iridix_rev_percept_control_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac3cL);
    system_sw_write_32(base + 0x1ac3cL, (((uint32_t) (data & 0x3)) << 8) | (curr & 0xfffffcff));
}
static __inline uint8_t acamera_isp_iridix_rev_percept_control_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac3cL) & 0x300) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: strength_inroi
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Manual Strength value for inside of ROI 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_STRENGTH_INROI_DEFAULT (0x200)
#define ACAMERA_ISP_IRIDIX_STRENGTH_INROI_DATASIZE (10)
#define ACAMERA_ISP_IRIDIX_STRENGTH_INROI_OFFSET (0x1db4)
#define ACAMERA_ISP_IRIDIX_STRENGTH_INROI_MASK (0x3ff0000)

// args: data (10-bit)
static __inline void acamera_isp_iridix_strength_inroi_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac3cL);
    system_sw_write_32(base + 0x1ac3cL, (((uint32_t) (data & 0x3ff)) << 16) | (curr & 0xfc00ffff));
}
static __inline uint16_t acamera_isp_iridix_strength_inroi_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ac3cL) & 0x3ff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: strength_outroi
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Manual Strength value for outside of ROI 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_STRENGTH_OUTROI_DEFAULT (0x200)
#define ACAMERA_ISP_IRIDIX_STRENGTH_OUTROI_DATASIZE (10)
#define ACAMERA_ISP_IRIDIX_STRENGTH_OUTROI_OFFSET (0x1db8)
#define ACAMERA_ISP_IRIDIX_STRENGTH_OUTROI_MASK (0x3ff)

// args: data (10-bit)
static __inline void acamera_isp_iridix_strength_outroi_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac40L);
    system_sw_write_32(base + 0x1ac40L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
}
static __inline uint16_t acamera_isp_iridix_strength_outroi_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ac40L) & 0x3ff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: roi_hor_start
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Horizontal starting point of ROI 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_ROI_HOR_START_DEFAULT (0x0000)
#define ACAMERA_ISP_IRIDIX_ROI_HOR_START_DATASIZE (16)
#define ACAMERA_ISP_IRIDIX_ROI_HOR_START_OFFSET (0x1dbc)
#define ACAMERA_ISP_IRIDIX_ROI_HOR_START_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_iridix_roi_hor_start_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac44L);
    system_sw_write_32(base + 0x1ac44L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_iridix_roi_hor_start_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ac44L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: roi_hor_end
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Horizontal ending point of ROI 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_ROI_HOR_END_DEFAULT (0xFFFF)
#define ACAMERA_ISP_IRIDIX_ROI_HOR_END_DATASIZE (16)
#define ACAMERA_ISP_IRIDIX_ROI_HOR_END_OFFSET (0x1dbc)
#define ACAMERA_ISP_IRIDIX_ROI_HOR_END_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_iridix_roi_hor_end_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac44L);
    system_sw_write_32(base + 0x1ac44L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_iridix_roi_hor_end_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ac44L) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: roi_ver_start
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Vertical starting point of ROI 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_ROI_VER_START_DEFAULT (0x0000)
#define ACAMERA_ISP_IRIDIX_ROI_VER_START_DATASIZE (16)
#define ACAMERA_ISP_IRIDIX_ROI_VER_START_OFFSET (0x1dc0)
#define ACAMERA_ISP_IRIDIX_ROI_VER_START_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_iridix_roi_ver_start_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac48L);
    system_sw_write_32(base + 0x1ac48L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_iridix_roi_ver_start_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ac48L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: roi_ver_end
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Vertical ending point of ROI 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_ROI_VER_END_DEFAULT (0xFFFF)
#define ACAMERA_ISP_IRIDIX_ROI_VER_END_DATASIZE (16)
#define ACAMERA_ISP_IRIDIX_ROI_VER_END_OFFSET (0x1dc0)
#define ACAMERA_ISP_IRIDIX_ROI_VER_END_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_iridix_roi_ver_end_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac48L);
    system_sw_write_32(base + 0x1ac48L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_iridix_roi_ver_end_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ac48L) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: filter_mux
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Selects between Iridix8 and Iridix7, 1=Iridix8 and 0=Iridix7 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_FILTER_MUX_DEFAULT (0x1)
#define ACAMERA_ISP_IRIDIX_FILTER_MUX_DATASIZE (1)
#define ACAMERA_ISP_IRIDIX_FILTER_MUX_OFFSET (0x1dc4)
#define ACAMERA_ISP_IRIDIX_FILTER_MUX_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_iridix_filter_mux_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac4cL);
    system_sw_write_32(base + 0x1ac4cL, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_iridix_filter_mux_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac4cL) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: svariance
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Iridix8 transform sensitivity to different areas of image 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_SVARIANCE_DEFAULT (0x0)
#define ACAMERA_ISP_IRIDIX_SVARIANCE_DATASIZE (4)
#define ACAMERA_ISP_IRIDIX_SVARIANCE_OFFSET (0x1dc4)
#define ACAMERA_ISP_IRIDIX_SVARIANCE_MASK (0xf00)

// args: data (4-bit)
static __inline void acamera_isp_iridix_svariance_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac4cL);
    system_sw_write_32(base + 0x1ac4cL, (((uint32_t) (data & 0xf)) << 8) | (curr & 0xfffff0ff));
}
static __inline uint8_t acamera_isp_iridix_svariance_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac4cL) & 0xf00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: bright_pr
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Manual Bright_Preserve value to control Iridix core 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_BRIGHT_PR_DEFAULT (0xA0)
#define ACAMERA_ISP_IRIDIX_BRIGHT_PR_DATASIZE (8)
#define ACAMERA_ISP_IRIDIX_BRIGHT_PR_OFFSET (0x1dc4)
#define ACAMERA_ISP_IRIDIX_BRIGHT_PR_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_iridix_bright_pr_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac4cL);
    system_sw_write_32(base + 0x1ac4cL, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_iridix_bright_pr_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac4cL) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: contrast
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Iridix8 contrast control parameter 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_CONTRAST_DEFAULT (0xB0)
#define ACAMERA_ISP_IRIDIX_CONTRAST_DATASIZE (8)
#define ACAMERA_ISP_IRIDIX_CONTRAST_OFFSET (0x1dc4)
#define ACAMERA_ISP_IRIDIX_CONTRAST_MASK (0xff000000)

// args: data (8-bit)
static __inline void acamera_isp_iridix_contrast_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac4cL);
    system_sw_write_32(base + 0x1ac4cL, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
}
static __inline uint8_t acamera_isp_iridix_contrast_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac4cL) & 0xff000000) >> 24);
}
// ------------------------------------------------------------------------------ //
// Register: dark_enh
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Manual Dark_Enhance value to control Iridix core 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_DARK_ENH_DEFAULT (0x1000)
#define ACAMERA_ISP_IRIDIX_DARK_ENH_DATASIZE (16)
#define ACAMERA_ISP_IRIDIX_DARK_ENH_OFFSET (0x1dc8)
#define ACAMERA_ISP_IRIDIX_DARK_ENH_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_iridix_dark_enh_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac50L);
    system_sw_write_32(base + 0x1ac50L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_iridix_dark_enh_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ac50L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: fwd_alpha
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// alpha for gamma_dl 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_FWD_ALPHA_DEFAULT (0x0100)
#define ACAMERA_ISP_IRIDIX_FWD_ALPHA_DATASIZE (18)
#define ACAMERA_ISP_IRIDIX_FWD_ALPHA_OFFSET (0x1dcc)
#define ACAMERA_ISP_IRIDIX_FWD_ALPHA_MASK (0x3ffff)

// args: data (18-bit)
static __inline void acamera_isp_iridix_fwd_alpha_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac54L);
    system_sw_write_32(base + 0x1ac54L, (((uint32_t) (data & 0x3ffff)) << 0) | (curr & 0xfffc0000));
}
static __inline uint32_t acamera_isp_iridix_fwd_alpha_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x1ac54L) & 0x3ffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: rev_alpha
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// alpha for gamma_dl 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_REV_ALPHA_DEFAULT (0x1000)
#define ACAMERA_ISP_IRIDIX_REV_ALPHA_DATASIZE (18)
#define ACAMERA_ISP_IRIDIX_REV_ALPHA_OFFSET (0x1dd0)
#define ACAMERA_ISP_IRIDIX_REV_ALPHA_MASK (0x3ffff)

// args: data (18-bit)
static __inline void acamera_isp_iridix_rev_alpha_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac58L);
    system_sw_write_32(base + 0x1ac58L, (((uint32_t) (data & 0x3ffff)) << 0) | (curr & 0xfffc0000));
}
static __inline uint32_t acamera_isp_iridix_rev_alpha_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x1ac58L) & 0x3ffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: context_no
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Context id of a input Frame
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_CONTEXT_NO_DEFAULT (0x0)
#define ACAMERA_ISP_IRIDIX_CONTEXT_NO_DATASIZE (2)
#define ACAMERA_ISP_IRIDIX_CONTEXT_NO_OFFSET (0x1dd4)
#define ACAMERA_ISP_IRIDIX_CONTEXT_NO_MASK (0x3)

// args: data (2-bit)
static __inline void acamera_isp_iridix_context_no_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac5cL);
    system_sw_write_32(base + 0x1ac5cL, (((uint32_t) (data & 0x3)) << 0) | (curr & 0xfffffffc));
}
static __inline uint8_t acamera_isp_iridix_context_no_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac5cL) & 0x3) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: wb_offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// White balance offset 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_WB_OFFSET_DEFAULT (0x0000)
#define ACAMERA_ISP_IRIDIX_WB_OFFSET_DATASIZE (20)
#define ACAMERA_ISP_IRIDIX_WB_OFFSET_OFFSET (0x1dd8)
#define ACAMERA_ISP_IRIDIX_WB_OFFSET_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_iridix_wb_offset_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac60L);
    system_sw_write_32(base + 0x1ac60L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_iridix_wb_offset_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x1ac60L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: gain_r
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// White balance gain for R 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_GAIN_R_DEFAULT (0x100)
#define ACAMERA_ISP_IRIDIX_GAIN_R_DATASIZE (12)
#define ACAMERA_ISP_IRIDIX_GAIN_R_OFFSET (0x1ddc)
#define ACAMERA_ISP_IRIDIX_GAIN_R_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_iridix_gain_r_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac64L);
    system_sw_write_32(base + 0x1ac64L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_iridix_gain_r_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ac64L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: gain_gr
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// White balance gain for GR 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_GAIN_GR_DEFAULT (0x100)
#define ACAMERA_ISP_IRIDIX_GAIN_GR_DATASIZE (12)
#define ACAMERA_ISP_IRIDIX_GAIN_GR_OFFSET (0x1ddc)
#define ACAMERA_ISP_IRIDIX_GAIN_GR_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_iridix_gain_gr_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac64L);
    system_sw_write_32(base + 0x1ac64L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_iridix_gain_gr_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ac64L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: gain_gb
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// White balance gain for GB 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_GAIN_GB_DEFAULT (0x100)
#define ACAMERA_ISP_IRIDIX_GAIN_GB_DATASIZE (12)
#define ACAMERA_ISP_IRIDIX_GAIN_GB_OFFSET (0x1de0)
#define ACAMERA_ISP_IRIDIX_GAIN_GB_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_iridix_gain_gb_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac68L);
    system_sw_write_32(base + 0x1ac68L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_iridix_gain_gb_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ac68L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: gain_b
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// White balance gain for B 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_GAIN_B_DEFAULT (0x100)
#define ACAMERA_ISP_IRIDIX_GAIN_B_DATASIZE (12)
#define ACAMERA_ISP_IRIDIX_GAIN_B_OFFSET (0x1de0)
#define ACAMERA_ISP_IRIDIX_GAIN_B_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_iridix_gain_b_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac68L);
    system_sw_write_32(base + 0x1ac68L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_iridix_gain_b_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ac68L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: GTm_select
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Global Tone map select : 0 : Local TM 1: Full Global TM 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_GTM_SELECT_DEFAULT (0x0)
#define ACAMERA_ISP_IRIDIX_GTM_SELECT_DATASIZE (1)
#define ACAMERA_ISP_IRIDIX_GTM_SELECT_OFFSET (0x1de4)
#define ACAMERA_ISP_IRIDIX_GTM_SELECT_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_iridix_gtm_select_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ac6cL);
    system_sw_write_32(base + 0x1ac6cL, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_iridix_gtm_select_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ac6cL) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Group: iridix LUT
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// LUT: Asymmetry LUT
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Iridix target curve. 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_LUT_ASYMMETRY_LUT_NODES (65)
#define ACAMERA_ISP_IRIDIX_LUT_ASYMMETRY_LUT_ADDRBITS (7)
#define ACAMERA_ISP_IRIDIX_LUT_ASYMMETRY_LUT_DATASIZE (20)
#define ACAMERA_ISP_IRIDIX_LUT_ASYMMETRY_LUT_OFFSET (0x1ac70L)

// args: index (0-64), data (20-bit)
static __inline void acamera_isp_iridix_lut_asymmetry_lut_write( uintptr_t base, uint8_t index,uint32_t data) {
    uintptr_t addr = base + 0x1ac70L + (index << 2);
    system_sw_write_32(addr, data);
}
static __inline uint32_t acamera_isp_iridix_lut_asymmetry_lut_read( uintptr_t base, uint8_t index) {
    uintptr_t addr = base + 0x1ac70L + (index << 2);
    return system_sw_read_32(addr);
}
// ------------------------------------------------------------------------------ //
// LUT: GlobalTM X LUT
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_LUT_GLOBALTM_X_LUT_NODES (33)
#define ACAMERA_ISP_IRIDIX_LUT_GLOBALTM_X_LUT_ADDRBITS (6)
#define ACAMERA_ISP_IRIDIX_LUT_GLOBALTM_X_LUT_DATASIZE (20)
#define ACAMERA_ISP_IRIDIX_LUT_GLOBALTM_X_LUT_OFFSET (0x1ad74L)

// args: index (0-32), data (20-bit)
static __inline void acamera_isp_iridix_lut_globaltm_x_lut_write( uintptr_t base, uint8_t index,uint32_t data) {
    uintptr_t addr = base + 0x1ad74L + (index << 2);
    system_sw_write_32(addr, data);
}
static __inline uint32_t acamera_isp_iridix_lut_globaltm_x_lut_read( uintptr_t base, uint8_t index) {
    uintptr_t addr = base + 0x1ad74L + (index << 2);
    return system_sw_read_32(addr);
}
// ------------------------------------------------------------------------------ //
// LUT: GlobalTM Y LUT
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_IRIDIX_LUT_GLOBALTM_Y_LUT_NODES (33)
#define ACAMERA_ISP_IRIDIX_LUT_GLOBALTM_Y_LUT_ADDRBITS (6)
#define ACAMERA_ISP_IRIDIX_LUT_GLOBALTM_Y_LUT_DATASIZE (20)
#define ACAMERA_ISP_IRIDIX_LUT_GLOBALTM_Y_LUT_OFFSET (0x1adf8L)

// args: index (0-32), data (20-bit)
static __inline void acamera_isp_iridix_lut_globaltm_y_lut_write( uintptr_t base, uint8_t index,uint32_t data) {
    uintptr_t addr = base + 0x1adf8L + (index << 2);
    system_sw_write_32(addr, data);
}
static __inline uint32_t acamera_isp_iridix_lut_globaltm_y_lut_read( uintptr_t base, uint8_t index) {
    uintptr_t addr = base + 0x1adf8L + (index << 2);
    return system_sw_read_32(addr);
}
// ------------------------------------------------------------------------------ //
// Group: demosaic rgb
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bayer Demosaic
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: VH Slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Slope of vertical/horizontal blending threshold in 4.4 logarithmic format. 
//        High values will tend to favor one direction over the other (depending on VH Thresh) while lower values will give smoother blending.
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_VH_SLOPE_DEFAULT (0xC0)
#define ACAMERA_ISP_DEMOSAIC_RGB_VH_SLOPE_DATASIZE (8)
#define ACAMERA_ISP_DEMOSAIC_RGB_VH_SLOPE_OFFSET (0x1ff4)
#define ACAMERA_ISP_DEMOSAIC_RGB_VH_SLOPE_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_demosaic_rgb_vh_slope_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ae7cL);
    system_sw_write_32(base + 0x1ae7cL, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_demosaic_rgb_vh_slope_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ae7cL) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: AA Slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Slope of angular (45/135) blending threshold in 4.4 format. 
//        High values will tend to favor one direction over the other (depending on AA Thresh) while lower values will give smoother blending.
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_AA_SLOPE_DEFAULT (0xC0)
#define ACAMERA_ISP_DEMOSAIC_RGB_AA_SLOPE_DATASIZE (8)
#define ACAMERA_ISP_DEMOSAIC_RGB_AA_SLOPE_OFFSET (0x1ff4)
#define ACAMERA_ISP_DEMOSAIC_RGB_AA_SLOPE_MASK (0xff00)

// args: data (8-bit)
static __inline void acamera_isp_demosaic_rgb_aa_slope_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ae7cL);
    system_sw_write_32(base + 0x1ae7cL, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
}
static __inline uint8_t acamera_isp_demosaic_rgb_aa_slope_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ae7cL) & 0xff00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: VA Slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Slope of VH-AA blending threshold in 4.4 log format. 
//        High values will tend to favor one direction over the other (depending on VA Thresh) 
//        while lower values will give smoother blending.
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_VA_SLOPE_DEFAULT (0xAA)
#define ACAMERA_ISP_DEMOSAIC_RGB_VA_SLOPE_DATASIZE (8)
#define ACAMERA_ISP_DEMOSAIC_RGB_VA_SLOPE_OFFSET (0x1ff4)
#define ACAMERA_ISP_DEMOSAIC_RGB_VA_SLOPE_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_demosaic_rgb_va_slope_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ae7cL);
    system_sw_write_32(base + 0x1ae7cL, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_demosaic_rgb_va_slope_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ae7cL) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: UU Slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Slope of undefined blending threshold in 4.4 logarithmic format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_UU_SLOPE_DEFAULT (0xAD)
#define ACAMERA_ISP_DEMOSAIC_RGB_UU_SLOPE_DATASIZE (8)
#define ACAMERA_ISP_DEMOSAIC_RGB_UU_SLOPE_OFFSET (0x1ff4)
#define ACAMERA_ISP_DEMOSAIC_RGB_UU_SLOPE_MASK (0xff000000)

// args: data (8-bit)
static __inline void acamera_isp_demosaic_rgb_uu_slope_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ae7cL);
    system_sw_write_32(base + 0x1ae7cL, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
}
static __inline uint8_t acamera_isp_demosaic_rgb_uu_slope_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ae7cL) & 0xff000000) >> 24);
}
// ------------------------------------------------------------------------------ //
// Register: Sat Slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Slope of saturation blending threshold in linear format 2.6
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_SAT_SLOPE_DEFAULT (0x5D)
#define ACAMERA_ISP_DEMOSAIC_RGB_SAT_SLOPE_DATASIZE (8)
#define ACAMERA_ISP_DEMOSAIC_RGB_SAT_SLOPE_OFFSET (0x1ff8)
#define ACAMERA_ISP_DEMOSAIC_RGB_SAT_SLOPE_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_demosaic_rgb_sat_slope_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ae80L);
    system_sw_write_32(base + 0x1ae80L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_demosaic_rgb_sat_slope_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ae80L) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: VH Thresh
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Threshold for the range of vertical/horizontal blending
//            The threshold defines the difference of vertical and horizontal gradients at which the vertical gradient will 
//            start to be taken into account in the blending (if VH Offset is set to 0). 
//            Setting the offset not null (or the slope low) will include proportion of the vertical 
//            gradient in the blending before even the gradient difference reaches the threshold (see VH Offset for more details).
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_VH_THRESH_DEFAULT (0x131)
#define ACAMERA_ISP_DEMOSAIC_RGB_VH_THRESH_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGB_VH_THRESH_OFFSET (0x1ffc)
#define ACAMERA_ISP_DEMOSAIC_RGB_VH_THRESH_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgb_vh_thresh_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ae84L);
    system_sw_write_32(base + 0x1ae84L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgb_vh_thresh_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ae84L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: AA Thresh
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Threshold for the range of angular (45/135) blending. 
//        The threshold defines the difference of 45 and 135 gradients at which the 45 gradient will start to be taken into account in the 
//        blending (if AA Offset is set to 0). 
//        Setting the offset not null (or the slope low) will include proportion of the 45 gradient in the blending before 
//        even the gradient difierence reaches the threshold (see AA Offset for more details).
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_AA_THRESH_DEFAULT (0xA0)
#define ACAMERA_ISP_DEMOSAIC_RGB_AA_THRESH_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGB_AA_THRESH_OFFSET (0x1ffc)
#define ACAMERA_ISP_DEMOSAIC_RGB_AA_THRESH_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgb_aa_thresh_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ae84L);
    system_sw_write_32(base + 0x1ae84L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_demosaic_rgb_aa_thresh_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ae84L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: VA Thresh
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Threshold for the range of VH-AA blending. 
//        The threshold defines the difference of VH and AA gradients at which the VH gradient will start to be taken into account in the blending 
//        (if VA Offset is set to 0). Setting the offset not null (or the slope low) will include proportion of the VH gradient 
//        in the blending before even the gradient difference reaches the threshold (see VA Offiset for more details).
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_VA_THRESH_DEFAULT (0x70)
#define ACAMERA_ISP_DEMOSAIC_RGB_VA_THRESH_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGB_VA_THRESH_OFFSET (0x2000)
#define ACAMERA_ISP_DEMOSAIC_RGB_VA_THRESH_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgb_va_thresh_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ae88L);
    system_sw_write_32(base + 0x1ae88L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgb_va_thresh_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ae88L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: UU Thresh
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Threshold for the range of undefined blending
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_UU_THRESH_DEFAULT (0x171)
#define ACAMERA_ISP_DEMOSAIC_RGB_UU_THRESH_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGB_UU_THRESH_OFFSET (0x2000)
#define ACAMERA_ISP_DEMOSAIC_RGB_UU_THRESH_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgb_uu_thresh_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ae88L);
    system_sw_write_32(base + 0x1ae88L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_demosaic_rgb_uu_thresh_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ae88L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Sat Thresh
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Threshold for the range of saturation blending  in signed 2.9 format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_SAT_THRESH_DEFAULT (0x171)
#define ACAMERA_ISP_DEMOSAIC_RGB_SAT_THRESH_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGB_SAT_THRESH_OFFSET (0x2004)
#define ACAMERA_ISP_DEMOSAIC_RGB_SAT_THRESH_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgb_sat_thresh_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ae8cL);
    system_sw_write_32(base + 0x1ae8cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgb_sat_thresh_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ae8cL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: lum_thresh
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Luminance threshold for directional sharpening
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_LUM_THRESH_DEFAULT (0x060)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUM_THRESH_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUM_THRESH_OFFSET (0x2004)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUM_THRESH_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgb_lum_thresh_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ae8cL);
    system_sw_write_32(base + 0x1ae8cL, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_demosaic_rgb_lum_thresh_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ae8cL) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: VH Offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Offset for vertical/horizontal blending threshold
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_VH_OFFSET_DEFAULT (0x800)
#define ACAMERA_ISP_DEMOSAIC_RGB_VH_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGB_VH_OFFSET_OFFSET (0x2008)
#define ACAMERA_ISP_DEMOSAIC_RGB_VH_OFFSET_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgb_vh_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ae90L);
    system_sw_write_32(base + 0x1ae90L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgb_vh_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ae90L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: AA Offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Offset for angular (A45/A135) blending threshold. 
//        This register has great impact on how AA Thresh is used. 
//        Setting this register to a value offset tells the blending process to weight the 45 and 135 gradients, 
//        at the threshold, with respectively offset/16 and 255 - (offset/16). 
//        If AA Thresh not equals to 0, these same blending weights apply from -AA Thresh to +AA Thresh.
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_AA_OFFSET_DEFAULT (0x800)
#define ACAMERA_ISP_DEMOSAIC_RGB_AA_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGB_AA_OFFSET_OFFSET (0x2008)
#define ACAMERA_ISP_DEMOSAIC_RGB_AA_OFFSET_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgb_aa_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ae90L);
    system_sw_write_32(base + 0x1ae90L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_demosaic_rgb_aa_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ae90L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: VA Offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Offset for VH-AA blending threshold. This register has great impact on how VA Thresh is used. 
//        Setting this register to a value offset tells the blending process to weight the VH and AA gradients, 
//        at the threshold, with respectively offset/16 and 255 - (offset/16).
//        If VA Thresh not equals to 0, these same blending weights apply from -VA Thresh to +VA Thresh.
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_VA_OFFSET_DEFAULT (0x800)
#define ACAMERA_ISP_DEMOSAIC_RGB_VA_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGB_VA_OFFSET_OFFSET (0x200c)
#define ACAMERA_ISP_DEMOSAIC_RGB_VA_OFFSET_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgb_va_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ae94L);
    system_sw_write_32(base + 0x1ae94L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgb_va_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ae94L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: UU Offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Offset for undefined blending threshold
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_UU_OFFSET_DEFAULT (0x000)
#define ACAMERA_ISP_DEMOSAIC_RGB_UU_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGB_UU_OFFSET_OFFSET (0x200c)
#define ACAMERA_ISP_DEMOSAIC_RGB_UU_OFFSET_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgb_uu_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ae94L);
    system_sw_write_32(base + 0x1ae94L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_demosaic_rgb_uu_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ae94L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Sat Offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Offset for saturation blending threshold in signed 2.9 format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_SAT_OFFSET_DEFAULT (0x000)
#define ACAMERA_ISP_DEMOSAIC_RGB_SAT_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGB_SAT_OFFSET_OFFSET (0x2010)
#define ACAMERA_ISP_DEMOSAIC_RGB_SAT_OFFSET_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgb_sat_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ae98L);
    system_sw_write_32(base + 0x1ae98L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgb_sat_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ae98L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: AC Offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Offset for AC blending threshold in signed 2.9 format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_AC_OFFSET_DEFAULT (0x000)
#define ACAMERA_ISP_DEMOSAIC_RGB_AC_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGB_AC_OFFSET_OFFSET (0x2010)
#define ACAMERA_ISP_DEMOSAIC_RGB_AC_OFFSET_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgb_ac_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ae98L);
    system_sw_write_32(base + 0x1ae98L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_demosaic_rgb_ac_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1ae98L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: sharp_alt_d
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Directional sharp mask strength in signed 4.4 format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_SHARP_ALT_D_DEFAULT (0x30)
#define ACAMERA_ISP_DEMOSAIC_RGB_SHARP_ALT_D_DATASIZE (8)
#define ACAMERA_ISP_DEMOSAIC_RGB_SHARP_ALT_D_OFFSET (0x2014)
#define ACAMERA_ISP_DEMOSAIC_RGB_SHARP_ALT_D_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_demosaic_rgb_sharp_alt_d_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ae9cL);
    system_sw_write_32(base + 0x1ae9cL, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_demosaic_rgb_sharp_alt_d_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ae9cL) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: sharp_alt_ud
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Non-directional sharp mask strength in signed 4.4 format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_SHARP_ALT_UD_DEFAULT (0x20)
#define ACAMERA_ISP_DEMOSAIC_RGB_SHARP_ALT_UD_DATASIZE (8)
#define ACAMERA_ISP_DEMOSAIC_RGB_SHARP_ALT_UD_OFFSET (0x2014)
#define ACAMERA_ISP_DEMOSAIC_RGB_SHARP_ALT_UD_MASK (0xff00)

// args: data (8-bit)
static __inline void acamera_isp_demosaic_rgb_sharp_alt_ud_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ae9cL);
    system_sw_write_32(base + 0x1ae9cL, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
}
static __inline uint8_t acamera_isp_demosaic_rgb_sharp_alt_ud_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ae9cL) & 0xff00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: np_offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise profile offset in logarithmic 4.4 format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_NP_OFFSET_DEFAULT (0x00)
#define ACAMERA_ISP_DEMOSAIC_RGB_NP_OFFSET_DATASIZE (8)
#define ACAMERA_ISP_DEMOSAIC_RGB_NP_OFFSET_OFFSET (0x2014)
#define ACAMERA_ISP_DEMOSAIC_RGB_NP_OFFSET_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_demosaic_rgb_np_offset_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1ae9cL);
    system_sw_write_32(base + 0x1ae9cL, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_demosaic_rgb_np_offset_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1ae9cL) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Dmsc config
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Debug output select. Set to 0x00 for normal operation.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_DMSC_CONFIG_DEFAULT (0x00)
#define ACAMERA_ISP_DEMOSAIC_RGB_DMSC_CONFIG_DATASIZE (8)
#define ACAMERA_ISP_DEMOSAIC_RGB_DMSC_CONFIG_OFFSET (0x2018)
#define ACAMERA_ISP_DEMOSAIC_RGB_DMSC_CONFIG_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_demosaic_rgb_dmsc_config_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aea0L);
    system_sw_write_32(base + 0x1aea0L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_demosaic_rgb_dmsc_config_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aea0L) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: AC Thresh
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Threshold for the range of AC blending in signed 2.9 format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_AC_THRESH_DEFAULT (0x1B3)
#define ACAMERA_ISP_DEMOSAIC_RGB_AC_THRESH_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGB_AC_THRESH_OFFSET (0x201c)
#define ACAMERA_ISP_DEMOSAIC_RGB_AC_THRESH_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgb_ac_thresh_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aea4L);
    system_sw_write_32(base + 0x1aea4L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgb_ac_thresh_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1aea4L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: AC Slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Slope of AC blending threshold in linear format 2.6
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_AC_SLOPE_DEFAULT (0xCF)
#define ACAMERA_ISP_DEMOSAIC_RGB_AC_SLOPE_DATASIZE (8)
#define ACAMERA_ISP_DEMOSAIC_RGB_AC_SLOPE_OFFSET (0x201c)
#define ACAMERA_ISP_DEMOSAIC_RGB_AC_SLOPE_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_demosaic_rgb_ac_slope_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aea4L);
    system_sw_write_32(base + 0x1aea4L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_demosaic_rgb_ac_slope_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aea4L) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: FC Slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Slope (strength) of false color correction
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_FC_SLOPE_DEFAULT (0x80)
#define ACAMERA_ISP_DEMOSAIC_RGB_FC_SLOPE_DATASIZE (8)
#define ACAMERA_ISP_DEMOSAIC_RGB_FC_SLOPE_OFFSET (0x2020)
#define ACAMERA_ISP_DEMOSAIC_RGB_FC_SLOPE_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_demosaic_rgb_fc_slope_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aea8L);
    system_sw_write_32(base + 0x1aea8L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_demosaic_rgb_fc_slope_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aea8L) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: FC Alias Slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Slope (strength) of false colour correction after blending with saturation value in 2.6 unsigned format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_FC_ALIAS_SLOPE_DEFAULT (0x55)
#define ACAMERA_ISP_DEMOSAIC_RGB_FC_ALIAS_SLOPE_DATASIZE (8)
#define ACAMERA_ISP_DEMOSAIC_RGB_FC_ALIAS_SLOPE_OFFSET (0x2020)
#define ACAMERA_ISP_DEMOSAIC_RGB_FC_ALIAS_SLOPE_MASK (0xff00)

// args: data (8-bit)
static __inline void acamera_isp_demosaic_rgb_fc_alias_slope_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aea8L);
    system_sw_write_32(base + 0x1aea8L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
}
static __inline uint8_t acamera_isp_demosaic_rgb_fc_alias_slope_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aea8L) & 0xff00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: FC Alias Thresh
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Threshold of false colour correction after blending with saturation valuet in in 0.8 unsigned format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_FC_ALIAS_THRESH_DEFAULT (0x00)
#define ACAMERA_ISP_DEMOSAIC_RGB_FC_ALIAS_THRESH_DATASIZE (8)
#define ACAMERA_ISP_DEMOSAIC_RGB_FC_ALIAS_THRESH_OFFSET (0x2020)
#define ACAMERA_ISP_DEMOSAIC_RGB_FC_ALIAS_THRESH_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_demosaic_rgb_fc_alias_thresh_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aea8L);
    system_sw_write_32(base + 0x1aea8L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_demosaic_rgb_fc_alias_thresh_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aea8L) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: NP off
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise profile black level offset
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_NP_OFF_DEFAULT (0)
#define ACAMERA_ISP_DEMOSAIC_RGB_NP_OFF_DATASIZE (7)
#define ACAMERA_ISP_DEMOSAIC_RGB_NP_OFF_OFFSET (0x2024)
#define ACAMERA_ISP_DEMOSAIC_RGB_NP_OFF_MASK (0x7f)

// args: data (7-bit)
static __inline void acamera_isp_demosaic_rgb_np_off_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aeacL);
    system_sw_write_32(base + 0x1aeacL, (((uint32_t) (data & 0x7f)) << 0) | (curr & 0xffffff80));
}
static __inline uint8_t acamera_isp_demosaic_rgb_np_off_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aeacL) & 0x7f) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: NP off reflect
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//          Defines how values below black level are obtained.
//          0: Repeat the first table entry.
//          1: Reflect the noise profile curve below black level.
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_NP_OFF_REFLECT_DEFAULT (0)
#define ACAMERA_ISP_DEMOSAIC_RGB_NP_OFF_REFLECT_DATASIZE (1)
#define ACAMERA_ISP_DEMOSAIC_RGB_NP_OFF_REFLECT_OFFSET (0x2024)
#define ACAMERA_ISP_DEMOSAIC_RGB_NP_OFF_REFLECT_MASK (0x80)

// args: data (1-bit)
static __inline void acamera_isp_demosaic_rgb_np_off_reflect_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aeacL);
    system_sw_write_32(base + 0x1aeacL, (((uint32_t) (data & 0x1)) << 7) | (curr & 0xffffff7f));
}
static __inline uint8_t acamera_isp_demosaic_rgb_np_off_reflect_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aeacL) & 0x80) >> 7);
}
// ------------------------------------------------------------------------------ //
// Register: sharp_alt_ld
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Sharpen strength for L_Ld in unsigned 4.4 format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_SHARP_ALT_LD_DEFAULT (0x10)
#define ACAMERA_ISP_DEMOSAIC_RGB_SHARP_ALT_LD_DATASIZE (8)
#define ACAMERA_ISP_DEMOSAIC_RGB_SHARP_ALT_LD_OFFSET (0x2028)
#define ACAMERA_ISP_DEMOSAIC_RGB_SHARP_ALT_LD_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_demosaic_rgb_sharp_alt_ld_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aeb0L);
    system_sw_write_32(base + 0x1aeb0L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_demosaic_rgb_sharp_alt_ld_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aeb0L) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: sharp_alt_ldu
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Sharpen strength for L_Ldu in unsigned 4.4 format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_SHARP_ALT_LDU_DEFAULT (0x10)
#define ACAMERA_ISP_DEMOSAIC_RGB_SHARP_ALT_LDU_DATASIZE (8)
#define ACAMERA_ISP_DEMOSAIC_RGB_SHARP_ALT_LDU_OFFSET (0x2028)
#define ACAMERA_ISP_DEMOSAIC_RGB_SHARP_ALT_LDU_MASK (0xff00)

// args: data (8-bit)
static __inline void acamera_isp_demosaic_rgb_sharp_alt_ldu_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aeb0L);
    system_sw_write_32(base + 0x1aeb0L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
}
static __inline uint8_t acamera_isp_demosaic_rgb_sharp_alt_ldu_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aeb0L) & 0xff00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: sharp_alt_lu
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Sharpen strength for L_Lu in unsigned 4.4 format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_SHARP_ALT_LU_DEFAULT (0x10)
#define ACAMERA_ISP_DEMOSAIC_RGB_SHARP_ALT_LU_DATASIZE (8)
#define ACAMERA_ISP_DEMOSAIC_RGB_SHARP_ALT_LU_OFFSET (0x2028)
#define ACAMERA_ISP_DEMOSAIC_RGB_SHARP_ALT_LU_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_demosaic_rgb_sharp_alt_lu_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aeb0L);
    system_sw_write_32(base + 0x1aeb0L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_demosaic_rgb_sharp_alt_lu_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aeb0L) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: sad_amp
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Sad amplifier in unsigned 4.4 format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_SAD_AMP_DEFAULT (0x10)
#define ACAMERA_ISP_DEMOSAIC_RGB_SAD_AMP_DATASIZE (8)
#define ACAMERA_ISP_DEMOSAIC_RGB_SAD_AMP_OFFSET (0x2028)
#define ACAMERA_ISP_DEMOSAIC_RGB_SAD_AMP_MASK (0xff000000)

// args: data (8-bit)
static __inline void acamera_isp_demosaic_rgb_sad_amp_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aeb0L);
    system_sw_write_32(base + 0x1aeb0L, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
}
static __inline uint8_t acamera_isp_demosaic_rgb_sad_amp_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aeb0L) & 0xff000000) >> 24);
}
// ------------------------------------------------------------------------------ //
// Register: min_d_strength
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Min threshold for the directional L_L in signed 2's complement s.12 format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_MIN_D_STRENGTH_DEFAULT (0x1F33)
#define ACAMERA_ISP_DEMOSAIC_RGB_MIN_D_STRENGTH_DATASIZE (13)
#define ACAMERA_ISP_DEMOSAIC_RGB_MIN_D_STRENGTH_OFFSET (0x202c)
#define ACAMERA_ISP_DEMOSAIC_RGB_MIN_D_STRENGTH_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_demosaic_rgb_min_d_strength_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aeb4L);
    system_sw_write_32(base + 0x1aeb4L, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_demosaic_rgb_min_d_strength_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1aeb4L) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: min_ud_strength
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Min threshold for the un-directional L_Lu in signed 2's complement s.12 format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_MIN_UD_STRENGTH_DEFAULT (0x1F48)
#define ACAMERA_ISP_DEMOSAIC_RGB_MIN_UD_STRENGTH_DATASIZE (13)
#define ACAMERA_ISP_DEMOSAIC_RGB_MIN_UD_STRENGTH_OFFSET (0x2030)
#define ACAMERA_ISP_DEMOSAIC_RGB_MIN_UD_STRENGTH_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_demosaic_rgb_min_ud_strength_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aeb8L);
    system_sw_write_32(base + 0x1aeb8L, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_demosaic_rgb_min_ud_strength_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1aeb8L) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: sharpen_alg_select
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// To select new sharp algorithm or not
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_SHARPEN_ALG_SELECT_DEFAULT (0x01)
#define ACAMERA_ISP_DEMOSAIC_RGB_SHARPEN_ALG_SELECT_DATASIZE (1)
#define ACAMERA_ISP_DEMOSAIC_RGB_SHARPEN_ALG_SELECT_OFFSET (0x2034)
#define ACAMERA_ISP_DEMOSAIC_RGB_SHARPEN_ALG_SELECT_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_demosaic_rgb_sharpen_alg_select_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aebcL);
    system_sw_write_32(base + 0x1aebcL, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_demosaic_rgb_sharpen_alg_select_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aebcL) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: UU SH Slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Slope of undefined blending threshold in 4.4 logarithmic format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_UU_SH_SLOPE_DEFAULT (0x80)
#define ACAMERA_ISP_DEMOSAIC_RGB_UU_SH_SLOPE_DATASIZE (8)
#define ACAMERA_ISP_DEMOSAIC_RGB_UU_SH_SLOPE_OFFSET (0x2038)
#define ACAMERA_ISP_DEMOSAIC_RGB_UU_SH_SLOPE_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_demosaic_rgb_uu_sh_slope_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aec0L);
    system_sw_write_32(base + 0x1aec0L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_demosaic_rgb_uu_sh_slope_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aec0L) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: lg_det_thresh
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Level to which the green channel is considered low in which case the gradient is calculated using only the blue and red channels
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_LG_DET_THRESH_DEFAULT (0x08)
#define ACAMERA_ISP_DEMOSAIC_RGB_LG_DET_THRESH_DATASIZE (8)
#define ACAMERA_ISP_DEMOSAIC_RGB_LG_DET_THRESH_OFFSET (0x2038)
#define ACAMERA_ISP_DEMOSAIC_RGB_LG_DET_THRESH_MASK (0xff00)

// args: data (8-bit)
static __inline void acamera_isp_demosaic_rgb_lg_det_thresh_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aec0L);
    system_sw_write_32(base + 0x1aec0L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
}
static __inline uint8_t acamera_isp_demosaic_rgb_lg_det_thresh_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aec0L) & 0xff00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: grey_det_thresh
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Threshold applied to the inter-channel difference for detecting grey region
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_GREY_DET_THRESH_DEFAULT (0x08)
#define ACAMERA_ISP_DEMOSAIC_RGB_GREY_DET_THRESH_DATASIZE (8)
#define ACAMERA_ISP_DEMOSAIC_RGB_GREY_DET_THRESH_OFFSET (0x2038)
#define ACAMERA_ISP_DEMOSAIC_RGB_GREY_DET_THRESH_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_demosaic_rgb_grey_det_thresh_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aec0L);
    system_sw_write_32(base + 0x1aec0L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_demosaic_rgb_grey_det_thresh_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aec0L) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: UU SH Thresh
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Threshold for the range of undefined blending
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_UU_SH_THRESH_DEFAULT (0x8)
#define ACAMERA_ISP_DEMOSAIC_RGB_UU_SH_THRESH_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGB_UU_SH_THRESH_OFFSET (0x203c)
#define ACAMERA_ISP_DEMOSAIC_RGB_UU_SH_THRESH_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgb_uu_sh_thresh_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aec4L);
    system_sw_write_32(base + 0x1aec4L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgb_uu_sh_thresh_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1aec4L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: UU SH Offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Offset for undefined blending threshold
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_UU_SH_OFFSET_DEFAULT (0x000)
#define ACAMERA_ISP_DEMOSAIC_RGB_UU_SH_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGB_UU_SH_OFFSET_OFFSET (0x203c)
#define ACAMERA_ISP_DEMOSAIC_RGB_UU_SH_OFFSET_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgb_uu_sh_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aec4L);
    system_sw_write_32(base + 0x1aec4L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_demosaic_rgb_uu_sh_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1aec4L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: lg_det_slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Control the ramp of the linear thresholding for the low green detector
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_LG_DET_SLOPE_DEFAULT (0x8000)
#define ACAMERA_ISP_DEMOSAIC_RGB_LG_DET_SLOPE_DATASIZE (16)
#define ACAMERA_ISP_DEMOSAIC_RGB_LG_DET_SLOPE_OFFSET (0x2040)
#define ACAMERA_ISP_DEMOSAIC_RGB_LG_DET_SLOPE_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_demosaic_rgb_lg_det_slope_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aec8L);
    system_sw_write_32(base + 0x1aec8L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_demosaic_rgb_lg_det_slope_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1aec8L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: grey_det_slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Control the ramp of the linear thresholding for the grey detector
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_GREY_DET_SLOPE_DEFAULT (0x1068)
#define ACAMERA_ISP_DEMOSAIC_RGB_GREY_DET_SLOPE_DATASIZE (16)
#define ACAMERA_ISP_DEMOSAIC_RGB_GREY_DET_SLOPE_OFFSET (0x2040)
#define ACAMERA_ISP_DEMOSAIC_RGB_GREY_DET_SLOPE_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_demosaic_rgb_grey_det_slope_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aec8L);
    system_sw_write_32(base + 0x1aec8L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_demosaic_rgb_grey_det_slope_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1aec8L) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: max_d_strength
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Max threshold for the directional L_L in signed 2's complement s1+0.12 format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_MAX_D_STRENGTH_DEFAULT (0x333)
#define ACAMERA_ISP_DEMOSAIC_RGB_MAX_D_STRENGTH_DATASIZE (13)
#define ACAMERA_ISP_DEMOSAIC_RGB_MAX_D_STRENGTH_OFFSET (0x2044)
#define ACAMERA_ISP_DEMOSAIC_RGB_MAX_D_STRENGTH_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_demosaic_rgb_max_d_strength_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aeccL);
    system_sw_write_32(base + 0x1aeccL, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_demosaic_rgb_max_d_strength_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1aeccL) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: max_ud_strength
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Max threshold for the undirectional L_Lu in signed 2's complement s1+0.12 format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_MAX_UD_STRENGTH_DEFAULT (0x333)
#define ACAMERA_ISP_DEMOSAIC_RGB_MAX_UD_STRENGTH_DATASIZE (13)
#define ACAMERA_ISP_DEMOSAIC_RGB_MAX_UD_STRENGTH_OFFSET (0x2044)
#define ACAMERA_ISP_DEMOSAIC_RGB_MAX_UD_STRENGTH_MASK (0x1fff0000)

// args: data (13-bit)
static __inline void acamera_isp_demosaic_rgb_max_ud_strength_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aeccL);
    system_sw_write_32(base + 0x1aeccL, (((uint32_t) (data & 0x1fff)) << 16) | (curr & 0xe000ffff));
}
static __inline uint16_t acamera_isp_demosaic_rgb_max_ud_strength_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1aeccL) & 0x1fff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: luma_thresh_low_d
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Intensity values above this value will be sharpen
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_THRESH_LOW_D_DEFAULT (0x8)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_THRESH_LOW_D_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_THRESH_LOW_D_OFFSET (0x2048)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_THRESH_LOW_D_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgb_luma_thresh_low_d_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aed0L);
    system_sw_write_32(base + 0x1aed0L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgb_luma_thresh_low_d_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1aed0L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: luma_offset_low_d
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Linear threshold offset corresponding to luma_thresh_low_d
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_OFFSET_LOW_D_DEFAULT (0x0)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_OFFSET_LOW_D_DATASIZE (8)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_OFFSET_LOW_D_OFFSET (0x2048)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_OFFSET_LOW_D_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_demosaic_rgb_luma_offset_low_d_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aed0L);
    system_sw_write_32(base + 0x1aed0L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_demosaic_rgb_luma_offset_low_d_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aed0L) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: luma_slope_low_d
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Linear threshold slope corresponding to luma_thresh_low_d
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_SLOPE_LOW_D_DEFAULT (0x4000)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_SLOPE_LOW_D_DATASIZE (20)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_SLOPE_LOW_D_OFFSET (0x204c)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_SLOPE_LOW_D_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_demosaic_rgb_luma_slope_low_d_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aed4L);
    system_sw_write_32(base + 0x1aed4L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_demosaic_rgb_luma_slope_low_d_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x1aed4L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: luma_thresh_high_d
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Intensity values below this value will be sharpen
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_THRESH_HIGH_D_DEFAULT (0xFA0)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_THRESH_HIGH_D_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_THRESH_HIGH_D_OFFSET (0x2050)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_THRESH_HIGH_D_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgb_luma_thresh_high_d_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aed8L);
    system_sw_write_32(base + 0x1aed8L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_demosaic_rgb_luma_thresh_high_d_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1aed8L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: luma_slope_high_d
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Linear threshold slope corresponding to luma_thresh_high_d
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_SLOPE_HIGH_D_DEFAULT (0x4000)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_SLOPE_HIGH_D_DATASIZE (20)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_SLOPE_HIGH_D_OFFSET (0x2054)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_SLOPE_HIGH_D_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_demosaic_rgb_luma_slope_high_d_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aedcL);
    system_sw_write_32(base + 0x1aedcL, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_demosaic_rgb_luma_slope_high_d_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x1aedcL) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: luma_thresh_low_ud
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Intensity values above this value will be sharpen
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_THRESH_LOW_UD_DEFAULT (0x8)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_THRESH_LOW_UD_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_THRESH_LOW_UD_OFFSET (0x2058)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_THRESH_LOW_UD_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgb_luma_thresh_low_ud_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aee0L);
    system_sw_write_32(base + 0x1aee0L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgb_luma_thresh_low_ud_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1aee0L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: luma_offset_low_ud
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Linear threshold offset corresponding to luma_thresh_low_ud
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_OFFSET_LOW_UD_DEFAULT (0x0)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_OFFSET_LOW_UD_DATASIZE (8)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_OFFSET_LOW_UD_OFFSET (0x2058)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_OFFSET_LOW_UD_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_demosaic_rgb_luma_offset_low_ud_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aee0L);
    system_sw_write_32(base + 0x1aee0L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_demosaic_rgb_luma_offset_low_ud_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1aee0L) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: luma_slope_low_ud
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Linear threshold slope corresponding to luma_thresh_low_ud
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_SLOPE_LOW_UD_DEFAULT (0x4000)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_SLOPE_LOW_UD_DATASIZE (20)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_SLOPE_LOW_UD_OFFSET (0x205c)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_SLOPE_LOW_UD_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_demosaic_rgb_luma_slope_low_ud_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aee4L);
    system_sw_write_32(base + 0x1aee4L, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_demosaic_rgb_luma_slope_low_ud_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x1aee4L) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: luma_thresh_high_ud
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Intensity values below this value will be sharpen
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_THRESH_HIGH_UD_DEFAULT (0xFA0)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_THRESH_HIGH_UD_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_THRESH_HIGH_UD_OFFSET (0x2060)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_THRESH_HIGH_UD_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgb_luma_thresh_high_ud_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aee8L);
    system_sw_write_32(base + 0x1aee8L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgb_luma_thresh_high_ud_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1aee8L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: luma_slope_high_ud
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Linear threshold slope corresponding to luma_thresh_high_ud
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_SLOPE_HIGH_UD_DEFAULT (0x4000)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_SLOPE_HIGH_UD_DATASIZE (20)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_SLOPE_HIGH_UD_OFFSET (0x2064)
#define ACAMERA_ISP_DEMOSAIC_RGB_LUMA_SLOPE_HIGH_UD_MASK (0xfffff)

// args: data (20-bit)
static __inline void acamera_isp_demosaic_rgb_luma_slope_high_ud_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aeecL);
    system_sw_write_32(base + 0x1aeecL, (((uint32_t) (data & 0xfffff)) << 0) | (curr & 0xfff00000));
}
static __inline uint32_t acamera_isp_demosaic_rgb_luma_slope_high_ud_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x1aeecL) & 0xfffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Group: demosaic rgb Noise Profile
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Bayer Demosaic lookup
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Weight lut
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Noise profile LUT
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGB_NOISE_PROFILE_LUT_WEIGHT_LUT_DEFAULT (0x0)
#define ACAMERA_ISP_DEMOSAIC_RGB_NOISE_PROFILE_LUT_WEIGHT_LUT_DATASIZE (8)
#define ACAMERA_ISP_DEMOSAIC_RGB_NOISE_PROFILE_LUT_WEIGHT_LUT_OFFSET (0x2068)
#define ACAMERA_ISP_DEMOSAIC_RGB_NOISE_PROFILE_LUT_WEIGHT_LUT_MASK (0xff)

// index (0-127), args: data (8-bit)
static __inline void acamera_isp_demosaic_rgb_noise_profile_lut_weight_lut_write( uintptr_t base, uint32_t index,uint8_t data) {
    uintptr_t addr = base + 0x1aef0L + (index & 0xFFFFFFFC);
    uint8_t offset = (index & 3) << 3;
    uint32_t curr = system_sw_read_32(addr);
    system_sw_write_32(addr, ((uint32_t)data << offset) | (curr & ~(0xFF << offset)));
}
static __inline uint8_t acamera_isp_demosaic_rgb_noise_profile_lut_weight_lut_read( uintptr_t base, uint32_t index) {
    uintptr_t addr = base + 0x1aef0L + (index & 0xFFFFFFFC);
    uint8_t offset = (index & 3) << 3;
    return (uint8_t)(system_sw_read_32(addr) >> offset);
}
// ------------------------------------------------------------------------------ //
// Group: demosaic rgbir
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Demosaic rgbir Config
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: rgbir_config
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Debug related configurations to select out different internal signals, and normal RGBIR will be outputted by default
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_RGBIR_CONFIG_DEFAULT (0x0)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_RGBIR_CONFIG_DATASIZE (3)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_RGBIR_CONFIG_OFFSET (0x20e8)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_RGBIR_CONFIG_MASK (0x7)

// args: data (3-bit)
static __inline void acamera_isp_demosaic_rgbir_rgbir_config_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1af70L);
    system_sw_write_32(base + 0x1af70L, (((uint32_t) (data & 0x7)) << 0) | (curr & 0xfffffff8));
}
static __inline uint8_t acamera_isp_demosaic_rgbir_rgbir_config_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1af70L) & 0x7) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: clip_level
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// clip level
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_CLIP_LEVEL_DEFAULT (0xe66)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_CLIP_LEVEL_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_CLIP_LEVEL_OFFSET (0x20ec)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_CLIP_LEVEL_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_clip_level_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1af74L);
    system_sw_write_32(base + 0x1af74L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_clip_level_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1af74L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: clip_debloom
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// clip level for debloom
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_CLIP_DEBLOOM_DEFAULT (0xccd)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_CLIP_DEBLOOM_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_CLIP_DEBLOOM_OFFSET (0x20f0)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_CLIP_DEBLOOM_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_clip_debloom_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1af78L);
    system_sw_write_32(base + 0x1af78L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_clip_debloom_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1af78L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: ir_on_blue_row
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// to indicate that the IR is on the same line of Blue
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_ON_BLUE_ROW_DEFAULT (0x0)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_ON_BLUE_ROW_DATASIZE (1)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_ON_BLUE_ROW_OFFSET (0x20f4)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_ON_BLUE_ROW_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_demosaic_rgbir_ir_on_blue_row_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1af7cL);
    system_sw_write_32(base + 0x1af7cL, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_demosaic_rgbir_ir_on_blue_row_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1af7cL) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: declip_mode
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Declip mode
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_DECLIP_MODE_DEFAULT (0x1)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_DECLIP_MODE_DATASIZE (1)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_DECLIP_MODE_OFFSET (0x20f8)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_DECLIP_MODE_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_demosaic_rgbir_declip_mode_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1af80L);
    system_sw_write_32(base + 0x1af80L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_demosaic_rgbir_declip_mode_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1af80L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: gain_r
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// gain for red
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_GAIN_R_DEFAULT (0x100)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_GAIN_R_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_GAIN_R_OFFSET (0x20fc)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_GAIN_R_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_gain_r_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1af84L);
    system_sw_write_32(base + 0x1af84L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_gain_r_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1af84L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: gain_b
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// gain for blue
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_GAIN_B_DEFAULT (0x100)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_GAIN_B_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_GAIN_B_OFFSET (0x20fc)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_GAIN_B_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_gain_b_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1af84L);
    system_sw_write_32(base + 0x1af84L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_gain_b_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1af84L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: static_gain_r
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// static gain for red
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_STATIC_GAIN_R_DEFAULT (0x100)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_STATIC_GAIN_R_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_STATIC_GAIN_R_OFFSET (0x2100)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_STATIC_GAIN_R_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_static_gain_r_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1af88L);
    system_sw_write_32(base + 0x1af88L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_static_gain_r_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1af88L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: static_gain_b
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// static gain for red
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_STATIC_GAIN_B_DEFAULT (0x100)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_STATIC_GAIN_B_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_STATIC_GAIN_B_OFFSET (0x2100)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_STATIC_GAIN_B_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_static_gain_b_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1af88L);
    system_sw_write_32(base + 0x1af88L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_static_gain_b_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1af88L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: static_gain_i
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// static gain for ir
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_STATIC_GAIN_I_DEFAULT (0x100)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_STATIC_GAIN_I_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_STATIC_GAIN_I_OFFSET (0x2104)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_STATIC_GAIN_I_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_static_gain_i_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1af8cL);
    system_sw_write_32(base + 0x1af8cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_static_gain_i_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1af8cL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: interpolation_directionality
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Interpolation Directionality
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_INTERPOLATION_DIRECTIONALITY_DEFAULT (0x400)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_INTERPOLATION_DIRECTIONALITY_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_INTERPOLATION_DIRECTIONALITY_OFFSET (0x2108)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_INTERPOLATION_DIRECTIONALITY_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_interpolation_directionality_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1af90L);
    system_sw_write_32(base + 0x1af90L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_interpolation_directionality_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1af90L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: sharp_limit
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// sharp limit
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_SHARP_LIMIT_DEFAULT (0x5c8)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_SHARP_LIMIT_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_SHARP_LIMIT_OFFSET (0x210c)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_SHARP_LIMIT_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_sharp_limit_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1af94L);
    system_sw_write_32(base + 0x1af94L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_sharp_limit_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1af94L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: sharp_high
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// sharp high
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_SHARP_HIGH_DEFAULT (0x666)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_SHARP_HIGH_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_SHARP_HIGH_OFFSET (0x2110)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_SHARP_HIGH_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_sharp_high_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1af98L);
    system_sw_write_32(base + 0x1af98L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_sharp_high_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1af98L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: sharp_low
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// sharp low
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_SHARP_LOW_DEFAULT (0x32)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_SHARP_LOW_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_SHARP_LOW_OFFSET (0x2114)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_SHARP_LOW_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_sharp_low_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1af9cL);
    system_sw_write_32(base + 0x1af9cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_sharp_low_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1af9cL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: fc_low
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// fc low
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_FC_LOW_DEFAULT (0x8f2)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_FC_LOW_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_FC_LOW_OFFSET (0x2118)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_FC_LOW_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_fc_low_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afa0L);
    system_sw_write_32(base + 0x1afa0L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_fc_low_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afa0L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: fc_grad
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// fc grad
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_FC_GRAD_DEFAULT (0xe6)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_FC_GRAD_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_FC_GRAD_OFFSET (0x211c)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_FC_GRAD_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_fc_grad_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afa4L);
    system_sw_write_32(base + 0x1afa4L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_fc_grad_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afa4L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: ir_correct_mat00
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// ir correct mat 00
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT00_DEFAULT (0x400)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT00_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT00_OFFSET (0x2120)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT00_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_ir_correct_mat00_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afa8L);
    system_sw_write_32(base + 0x1afa8L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_ir_correct_mat00_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afa8L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: ir_correct_mat01
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// ir correct mat 01
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT01_DEFAULT (0x000)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT01_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT01_OFFSET (0x2120)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT01_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_ir_correct_mat01_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afa8L);
    system_sw_write_32(base + 0x1afa8L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_ir_correct_mat01_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afa8L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: ir_correct_mat02
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// ir correct mat 02
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT02_DEFAULT (0x000)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT02_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT02_OFFSET (0x2124)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT02_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_ir_correct_mat02_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afacL);
    system_sw_write_32(base + 0x1afacL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_ir_correct_mat02_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afacL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: ir_correct_mat03
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// ir correct mat 03
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT03_DEFAULT (0x000)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT03_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT03_OFFSET (0x2124)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT03_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_ir_correct_mat03_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afacL);
    system_sw_write_32(base + 0x1afacL, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_ir_correct_mat03_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afacL) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: ir_correct_mat10
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// ir correct mat 10
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT10_DEFAULT (0x000)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT10_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT10_OFFSET (0x2128)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT10_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_ir_correct_mat10_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afb0L);
    system_sw_write_32(base + 0x1afb0L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_ir_correct_mat10_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afb0L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: ir_correct_mat11
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// ir correct mat 11
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT11_DEFAULT (0x400)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT11_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT11_OFFSET (0x2128)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT11_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_ir_correct_mat11_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afb0L);
    system_sw_write_32(base + 0x1afb0L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_ir_correct_mat11_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afb0L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: ir_correct_mat12
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// ir correct mat 12
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT12_DEFAULT (0x000)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT12_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT12_OFFSET (0x212c)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT12_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_ir_correct_mat12_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afb4L);
    system_sw_write_32(base + 0x1afb4L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_ir_correct_mat12_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afb4L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: ir_correct_mat13
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// ir correct mat 13
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT13_DEFAULT (0x000)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT13_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT13_OFFSET (0x212c)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT13_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_ir_correct_mat13_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afb4L);
    system_sw_write_32(base + 0x1afb4L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_ir_correct_mat13_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afb4L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: ir_correct_mat20
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// ir correct mat 20
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT20_DEFAULT (0x000)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT20_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT20_OFFSET (0x2130)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT20_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_ir_correct_mat20_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afb8L);
    system_sw_write_32(base + 0x1afb8L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_ir_correct_mat20_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afb8L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: ir_correct_mat21
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// ir correct mat 21
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT21_DEFAULT (0x000)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT21_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT21_OFFSET (0x2130)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT21_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_ir_correct_mat21_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afb8L);
    system_sw_write_32(base + 0x1afb8L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_ir_correct_mat21_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afb8L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: ir_correct_mat22
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// ir correct mat 22
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT22_DEFAULT (0x400)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT22_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT22_OFFSET (0x2134)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT22_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_ir_correct_mat22_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afbcL);
    system_sw_write_32(base + 0x1afbcL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_ir_correct_mat22_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afbcL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: ir_correct_mat23
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// ir correct mat 23
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT23_DEFAULT (0x000)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT23_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT23_OFFSET (0x2134)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT23_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_ir_correct_mat23_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afbcL);
    system_sw_write_32(base + 0x1afbcL, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_ir_correct_mat23_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afbcL) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: ir_correct_mat30
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// ir correct mat 30
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT30_DEFAULT (0x000)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT30_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT30_OFFSET (0x2138)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT30_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_ir_correct_mat30_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afc0L);
    system_sw_write_32(base + 0x1afc0L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_ir_correct_mat30_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afc0L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: ir_correct_mat31
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// ir correct mat 31
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT31_DEFAULT (0x000)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT31_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT31_OFFSET (0x2138)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT31_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_ir_correct_mat31_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afc0L);
    system_sw_write_32(base + 0x1afc0L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_ir_correct_mat31_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afc0L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: ir_correct_mat32
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// ir correct mat 32
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT32_DEFAULT (0x000)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT32_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT32_OFFSET (0x213c)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT32_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_ir_correct_mat32_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afc4L);
    system_sw_write_32(base + 0x1afc4L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_ir_correct_mat32_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afc4L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: ir_correct_mat33
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// ir correct mat 33
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT33_DEFAULT (0x400)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT33_DATASIZE (12)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT33_OFFSET (0x213c)
#define ACAMERA_ISP_DEMOSAIC_RGBIR_IR_CORRECT_MAT33_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_demosaic_rgbir_ir_correct_mat33_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afc4L);
    system_sw_write_32(base + 0x1afc4L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_demosaic_rgbir_ir_correct_mat33_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afc4L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Group: pf correction
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// purple fringing correction
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: use_color_corrected_rgb
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_USE_COLOR_CORRECTED_RGB_DEFAULT (1)
#define ACAMERA_ISP_PF_CORRECTION_USE_COLOR_CORRECTED_RGB_DATASIZE (1)
#define ACAMERA_ISP_PF_CORRECTION_USE_COLOR_CORRECTED_RGB_OFFSET (0x2140)
#define ACAMERA_ISP_PF_CORRECTION_USE_COLOR_CORRECTED_RGB_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_pf_correction_use_color_corrected_rgb_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afc8L);
    system_sw_write_32(base + 0x1afc8L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_pf_correction_use_color_corrected_rgb_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1afc8L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: hue_strength
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_HUE_STRENGTH_DEFAULT (0x200)
#define ACAMERA_ISP_PF_CORRECTION_HUE_STRENGTH_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_HUE_STRENGTH_OFFSET (0x2144)
#define ACAMERA_ISP_PF_CORRECTION_HUE_STRENGTH_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_hue_strength_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afccL);
    system_sw_write_32(base + 0x1afccL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_pf_correction_hue_strength_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afccL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: sat_strength
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_SAT_STRENGTH_DEFAULT (0x200)
#define ACAMERA_ISP_PF_CORRECTION_SAT_STRENGTH_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_SAT_STRENGTH_OFFSET (0x2148)
#define ACAMERA_ISP_PF_CORRECTION_SAT_STRENGTH_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_sat_strength_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afd0L);
    system_sw_write_32(base + 0x1afd0L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_pf_correction_sat_strength_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afd0L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: luma_strength
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_LUMA_STRENGTH_DEFAULT (0x400)
#define ACAMERA_ISP_PF_CORRECTION_LUMA_STRENGTH_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_LUMA_STRENGTH_OFFSET (0x2148)
#define ACAMERA_ISP_PF_CORRECTION_LUMA_STRENGTH_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_luma_strength_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afd0L);
    system_sw_write_32(base + 0x1afd0L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_pf_correction_luma_strength_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afd0L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: purple_strength
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_PURPLE_STRENGTH_DEFAULT (0x400)
#define ACAMERA_ISP_PF_CORRECTION_PURPLE_STRENGTH_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_PURPLE_STRENGTH_OFFSET (0x214c)
#define ACAMERA_ISP_PF_CORRECTION_PURPLE_STRENGTH_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_purple_strength_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afd4L);
    system_sw_write_32(base + 0x1afd4L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_pf_correction_purple_strength_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afd4L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: saturation_strength
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_SATURATION_STRENGTH_DEFAULT (0x26)
#define ACAMERA_ISP_PF_CORRECTION_SATURATION_STRENGTH_DATASIZE (8)
#define ACAMERA_ISP_PF_CORRECTION_SATURATION_STRENGTH_OFFSET (0x214c)
#define ACAMERA_ISP_PF_CORRECTION_SATURATION_STRENGTH_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_pf_correction_saturation_strength_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afd4L);
    system_sw_write_32(base + 0x1afd4L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_pf_correction_saturation_strength_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1afd4L) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: off_center_mult
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_OFF_CENTER_MULT_DEFAULT (0xF8F)
#define ACAMERA_ISP_PF_CORRECTION_OFF_CENTER_MULT_DATASIZE (16)
#define ACAMERA_ISP_PF_CORRECTION_OFF_CENTER_MULT_OFFSET (0x2150)
#define ACAMERA_ISP_PF_CORRECTION_OFF_CENTER_MULT_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_pf_correction_off_center_mult_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afd8L);
    system_sw_write_32(base + 0x1afd8L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_pf_correction_off_center_mult_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afd8L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: center_x
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_CENTER_X_DEFAULT (0x168)
#define ACAMERA_ISP_PF_CORRECTION_CENTER_X_DATASIZE (16)
#define ACAMERA_ISP_PF_CORRECTION_CENTER_X_OFFSET (0x2154)
#define ACAMERA_ISP_PF_CORRECTION_CENTER_X_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_pf_correction_center_x_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afdcL);
    system_sw_write_32(base + 0x1afdcL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_pf_correction_center_x_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afdcL) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: center_y
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_CENTER_Y_DEFAULT (0x280)
#define ACAMERA_ISP_PF_CORRECTION_CENTER_Y_DATASIZE (16)
#define ACAMERA_ISP_PF_CORRECTION_CENTER_Y_OFFSET (0x2154)
#define ACAMERA_ISP_PF_CORRECTION_CENTER_Y_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_pf_correction_center_y_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afdcL);
    system_sw_write_32(base + 0x1afdcL, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_pf_correction_center_y_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afdcL) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: ccm_coeff_rr
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_RR_DEFAULT (0x01CB)
#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_RR_DATASIZE (13)
#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_RR_OFFSET (0x2158)
#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_RR_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_pf_correction_ccm_coeff_rr_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afe0L);
    system_sw_write_32(base + 0x1afe0L, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_pf_correction_ccm_coeff_rr_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afe0L) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: ccm_coeff_rg
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_RG_DEFAULT (0x10c1)
#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_RG_DATASIZE (13)
#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_RG_OFFSET (0x215c)
#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_RG_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_pf_correction_ccm_coeff_rg_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afe4L);
    system_sw_write_32(base + 0x1afe4L, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_pf_correction_ccm_coeff_rg_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afe4L) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: ccm_coeff_rb
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_RB_DEFAULT (0x100A)
#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_RB_DATASIZE (13)
#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_RB_OFFSET (0x2160)
#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_RB_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_pf_correction_ccm_coeff_rb_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afe8L);
    system_sw_write_32(base + 0x1afe8L, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_pf_correction_ccm_coeff_rb_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afe8L) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: ccm_coeff_gr
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_GR_DEFAULT (0x1028)
#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_GR_DATASIZE (13)
#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_GR_OFFSET (0x2164)
#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_GR_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_pf_correction_ccm_coeff_gr_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1afecL);
    system_sw_write_32(base + 0x1afecL, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_pf_correction_ccm_coeff_gr_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1afecL) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: ccm_coeff_gg
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_GG_DEFAULT (0x16D)
#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_GG_DATASIZE (13)
#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_GG_OFFSET (0x2168)
#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_GG_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_pf_correction_ccm_coeff_gg_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aff0L);
    system_sw_write_32(base + 0x1aff0L, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_pf_correction_ccm_coeff_gg_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1aff0L) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: ccm_coeff_gb
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_GB_DEFAULT (0x1045)
#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_GB_DATASIZE (13)
#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_GB_OFFSET (0x216c)
#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_GB_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_pf_correction_ccm_coeff_gb_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aff4L);
    system_sw_write_32(base + 0x1aff4L, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_pf_correction_ccm_coeff_gb_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1aff4L) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: ccm_coeff_br
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_BR_DEFAULT (0x012)
#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_BR_DATASIZE (13)
#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_BR_OFFSET (0x2170)
#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_BR_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_pf_correction_ccm_coeff_br_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1aff8L);
    system_sw_write_32(base + 0x1aff8L, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_pf_correction_ccm_coeff_br_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1aff8L) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: ccm_coeff_bg
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_BG_DEFAULT (0x10AC)
#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_BG_DATASIZE (13)
#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_BG_OFFSET (0x2174)
#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_BG_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_pf_correction_ccm_coeff_bg_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1affcL);
    system_sw_write_32(base + 0x1affcL, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_pf_correction_ccm_coeff_bg_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1affcL) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: ccm_coeff_bb
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_BB_DEFAULT (0x19A)
#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_BB_DATASIZE (13)
#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_BB_OFFSET (0x2178)
#define ACAMERA_ISP_PF_CORRECTION_CCM_COEFF_BB_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_pf_correction_ccm_coeff_bb_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b000L);
    system_sw_write_32(base + 0x1b000L, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_pf_correction_ccm_coeff_bb_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b000L) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: sad_slope
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_SAD_SLOPE_DEFAULT (0x001)
#define ACAMERA_ISP_PF_CORRECTION_SAD_SLOPE_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_SAD_SLOPE_OFFSET (0x217c)
#define ACAMERA_ISP_PF_CORRECTION_SAD_SLOPE_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_sad_slope_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b004L);
    system_sw_write_32(base + 0x1b004L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_pf_correction_sad_slope_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b004L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: sad_offset
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_SAD_OFFSET_DEFAULT (0x000)
#define ACAMERA_ISP_PF_CORRECTION_SAD_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_SAD_OFFSET_OFFSET (0x217c)
#define ACAMERA_ISP_PF_CORRECTION_SAD_OFFSET_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_sad_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b004L);
    system_sw_write_32(base + 0x1b004L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_pf_correction_sad_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b004L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: sad_thresh
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_SAD_THRESH_DEFAULT (0x148)
#define ACAMERA_ISP_PF_CORRECTION_SAD_THRESH_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_SAD_THRESH_OFFSET (0x2180)
#define ACAMERA_ISP_PF_CORRECTION_SAD_THRESH_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_sad_thresh_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b008L);
    system_sw_write_32(base + 0x1b008L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_pf_correction_sad_thresh_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b008L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: hue_low_slope
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_HUE_LOW_SLOPE_DEFAULT (0x131)
#define ACAMERA_ISP_PF_CORRECTION_HUE_LOW_SLOPE_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_HUE_LOW_SLOPE_OFFSET (0x2184)
#define ACAMERA_ISP_PF_CORRECTION_HUE_LOW_SLOPE_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_hue_low_slope_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b00cL);
    system_sw_write_32(base + 0x1b00cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_pf_correction_hue_low_slope_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b00cL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: hue_low_offset
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_HUE_LOW_OFFSET_DEFAULT (0x000)
#define ACAMERA_ISP_PF_CORRECTION_HUE_LOW_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_HUE_LOW_OFFSET_OFFSET (0x2184)
#define ACAMERA_ISP_PF_CORRECTION_HUE_LOW_OFFSET_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_hue_low_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b00cL);
    system_sw_write_32(base + 0x1b00cL, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_pf_correction_hue_low_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b00cL) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: hue_low_thresh
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_HUE_LOW_THRESH_DEFAULT (0x733)
#define ACAMERA_ISP_PF_CORRECTION_HUE_LOW_THRESH_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_HUE_LOW_THRESH_OFFSET (0x2188)
#define ACAMERA_ISP_PF_CORRECTION_HUE_LOW_THRESH_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_hue_low_thresh_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b010L);
    system_sw_write_32(base + 0x1b010L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_pf_correction_hue_low_thresh_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b010L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: hue_high_slope
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_HUE_HIGH_SLOPE_DEFAULT (0x855)
#define ACAMERA_ISP_PF_CORRECTION_HUE_HIGH_SLOPE_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_HUE_HIGH_SLOPE_OFFSET (0x218c)
#define ACAMERA_ISP_PF_CORRECTION_HUE_HIGH_SLOPE_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_hue_high_slope_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b014L);
    system_sw_write_32(base + 0x1b014L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_pf_correction_hue_high_slope_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b014L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: hue_high_offset
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_HUE_HIGH_OFFSET_DEFAULT (0x000)
#define ACAMERA_ISP_PF_CORRECTION_HUE_HIGH_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_HUE_HIGH_OFFSET_OFFSET (0x218c)
#define ACAMERA_ISP_PF_CORRECTION_HUE_HIGH_OFFSET_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_hue_high_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b014L);
    system_sw_write_32(base + 0x1b014L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_pf_correction_hue_high_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b014L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: hue_high_thresh
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_HUE_HIGH_THRESH_DEFAULT (0x8E1)
#define ACAMERA_ISP_PF_CORRECTION_HUE_HIGH_THRESH_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_HUE_HIGH_THRESH_OFFSET (0x2190)
#define ACAMERA_ISP_PF_CORRECTION_HUE_HIGH_THRESH_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_hue_high_thresh_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b018L);
    system_sw_write_32(base + 0x1b018L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_pf_correction_hue_high_thresh_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b018L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: sat_low_slope
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_SAT_LOW_SLOPE_DEFAULT (0x021)
#define ACAMERA_ISP_PF_CORRECTION_SAT_LOW_SLOPE_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_SAT_LOW_SLOPE_OFFSET (0x2194)
#define ACAMERA_ISP_PF_CORRECTION_SAT_LOW_SLOPE_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_sat_low_slope_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b01cL);
    system_sw_write_32(base + 0x1b01cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_pf_correction_sat_low_slope_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b01cL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: sat_low_offset
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_SAT_LOW_OFFSET_DEFAULT (0x000)
#define ACAMERA_ISP_PF_CORRECTION_SAT_LOW_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_SAT_LOW_OFFSET_OFFSET (0x2194)
#define ACAMERA_ISP_PF_CORRECTION_SAT_LOW_OFFSET_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_sat_low_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b01cL);
    system_sw_write_32(base + 0x1b01cL, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_pf_correction_sat_low_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b01cL) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: sat_low_thresh
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_SAT_LOW_THRESH_DEFAULT (0x0A4)
#define ACAMERA_ISP_PF_CORRECTION_SAT_LOW_THRESH_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_SAT_LOW_THRESH_OFFSET (0x2198)
#define ACAMERA_ISP_PF_CORRECTION_SAT_LOW_THRESH_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_sat_low_thresh_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b020L);
    system_sw_write_32(base + 0x1b020L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_pf_correction_sat_low_thresh_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b020L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: sat_high_slope
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_SAT_HIGH_SLOPE_DEFAULT (0x000)
#define ACAMERA_ISP_PF_CORRECTION_SAT_HIGH_SLOPE_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_SAT_HIGH_SLOPE_OFFSET (0x219c)
#define ACAMERA_ISP_PF_CORRECTION_SAT_HIGH_SLOPE_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_sat_high_slope_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b024L);
    system_sw_write_32(base + 0x1b024L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_pf_correction_sat_high_slope_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b024L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: sat_high_offset
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_SAT_HIGH_OFFSET_DEFAULT (0xFFF)
#define ACAMERA_ISP_PF_CORRECTION_SAT_HIGH_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_SAT_HIGH_OFFSET_OFFSET (0x219c)
#define ACAMERA_ISP_PF_CORRECTION_SAT_HIGH_OFFSET_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_sat_high_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b024L);
    system_sw_write_32(base + 0x1b024L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_pf_correction_sat_high_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b024L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: sat_high_thresh
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_SAT_HIGH_THRESH_DEFAULT (0x000)
#define ACAMERA_ISP_PF_CORRECTION_SAT_HIGH_THRESH_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_SAT_HIGH_THRESH_OFFSET (0x21a0)
#define ACAMERA_ISP_PF_CORRECTION_SAT_HIGH_THRESH_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_sat_high_thresh_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b028L);
    system_sw_write_32(base + 0x1b028L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_pf_correction_sat_high_thresh_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b028L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: luma1_low_slope
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_LUMA1_LOW_SLOPE_DEFAULT (0x000)
#define ACAMERA_ISP_PF_CORRECTION_LUMA1_LOW_SLOPE_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_LUMA1_LOW_SLOPE_OFFSET (0x21a4)
#define ACAMERA_ISP_PF_CORRECTION_LUMA1_LOW_SLOPE_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_luma1_low_slope_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b02cL);
    system_sw_write_32(base + 0x1b02cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_pf_correction_luma1_low_slope_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b02cL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: luma1_low_offset
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_LUMA1_LOW_OFFSET_DEFAULT (0x000)
#define ACAMERA_ISP_PF_CORRECTION_LUMA1_LOW_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_LUMA1_LOW_OFFSET_OFFSET (0x21a4)
#define ACAMERA_ISP_PF_CORRECTION_LUMA1_LOW_OFFSET_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_luma1_low_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b02cL);
    system_sw_write_32(base + 0x1b02cL, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_pf_correction_luma1_low_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b02cL) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: luma1_low_thresh
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_LUMA1_LOW_THRESH_DEFAULT (0x000)
#define ACAMERA_ISP_PF_CORRECTION_LUMA1_LOW_THRESH_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_LUMA1_LOW_THRESH_OFFSET (0x21a8)
#define ACAMERA_ISP_PF_CORRECTION_LUMA1_LOW_THRESH_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_luma1_low_thresh_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b030L);
    system_sw_write_32(base + 0x1b030L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_pf_correction_luma1_low_thresh_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b030L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: luma1_high_slope
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_LUMA1_HIGH_SLOPE_DEFAULT (0x000)
#define ACAMERA_ISP_PF_CORRECTION_LUMA1_HIGH_SLOPE_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_LUMA1_HIGH_SLOPE_OFFSET (0x21ac)
#define ACAMERA_ISP_PF_CORRECTION_LUMA1_HIGH_SLOPE_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_luma1_high_slope_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b034L);
    system_sw_write_32(base + 0x1b034L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_pf_correction_luma1_high_slope_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b034L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: luma1_high_offset
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_LUMA1_HIGH_OFFSET_DEFAULT (0x000)
#define ACAMERA_ISP_PF_CORRECTION_LUMA1_HIGH_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_LUMA1_HIGH_OFFSET_OFFSET (0x21ac)
#define ACAMERA_ISP_PF_CORRECTION_LUMA1_HIGH_OFFSET_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_luma1_high_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b034L);
    system_sw_write_32(base + 0x1b034L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_pf_correction_luma1_high_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b034L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: luma1_high_thresh
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_LUMA1_HIGH_THRESH_DEFAULT (0x000)
#define ACAMERA_ISP_PF_CORRECTION_LUMA1_HIGH_THRESH_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_LUMA1_HIGH_THRESH_OFFSET (0x21b0)
#define ACAMERA_ISP_PF_CORRECTION_LUMA1_HIGH_THRESH_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_luma1_high_thresh_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b038L);
    system_sw_write_32(base + 0x1b038L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_pf_correction_luma1_high_thresh_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b038L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: luma2_low_slope
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_LUMA2_LOW_SLOPE_DEFAULT (0x140)
#define ACAMERA_ISP_PF_CORRECTION_LUMA2_LOW_SLOPE_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_LUMA2_LOW_SLOPE_OFFSET (0x21b4)
#define ACAMERA_ISP_PF_CORRECTION_LUMA2_LOW_SLOPE_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_luma2_low_slope_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b03cL);
    system_sw_write_32(base + 0x1b03cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_pf_correction_luma2_low_slope_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b03cL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: luma2_low_offset
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_LUMA2_LOW_OFFSET_DEFAULT (0x000)
#define ACAMERA_ISP_PF_CORRECTION_LUMA2_LOW_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_LUMA2_LOW_OFFSET_OFFSET (0x21b4)
#define ACAMERA_ISP_PF_CORRECTION_LUMA2_LOW_OFFSET_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_luma2_low_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b03cL);
    system_sw_write_32(base + 0x1b03cL, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_pf_correction_luma2_low_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b03cL) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: luma2_low_thresh
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_LUMA2_LOW_THRESH_DEFAULT (0x0CD)
#define ACAMERA_ISP_PF_CORRECTION_LUMA2_LOW_THRESH_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_LUMA2_LOW_THRESH_OFFSET (0x21b8)
#define ACAMERA_ISP_PF_CORRECTION_LUMA2_LOW_THRESH_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_luma2_low_thresh_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b040L);
    system_sw_write_32(base + 0x1b040L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_pf_correction_luma2_low_thresh_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b040L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: luma2_high_slope
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_LUMA2_HIGH_SLOPE_DEFAULT (0x026)
#define ACAMERA_ISP_PF_CORRECTION_LUMA2_HIGH_SLOPE_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_LUMA2_HIGH_SLOPE_OFFSET (0x21bc)
#define ACAMERA_ISP_PF_CORRECTION_LUMA2_HIGH_SLOPE_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_luma2_high_slope_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b044L);
    system_sw_write_32(base + 0x1b044L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_pf_correction_luma2_high_slope_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b044L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: luma2_high_offset
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_LUMA2_HIGH_OFFSET_DEFAULT (0x000)
#define ACAMERA_ISP_PF_CORRECTION_LUMA2_HIGH_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_LUMA2_HIGH_OFFSET_OFFSET (0x21bc)
#define ACAMERA_ISP_PF_CORRECTION_LUMA2_HIGH_OFFSET_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_luma2_high_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b044L);
    system_sw_write_32(base + 0x1b044L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_pf_correction_luma2_high_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b044L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: luma2_high_thresh
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_LUMA2_HIGH_THRESH_DEFAULT (0x1A0)
#define ACAMERA_ISP_PF_CORRECTION_LUMA2_HIGH_THRESH_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_LUMA2_HIGH_THRESH_OFFSET (0x21c0)
#define ACAMERA_ISP_PF_CORRECTION_LUMA2_HIGH_THRESH_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_luma2_high_thresh_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b048L);
    system_sw_write_32(base + 0x1b048L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_pf_correction_luma2_high_thresh_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b048L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: hsl_slope
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_HSL_SLOPE_DEFAULT (0x024)
#define ACAMERA_ISP_PF_CORRECTION_HSL_SLOPE_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_HSL_SLOPE_OFFSET (0x21c4)
#define ACAMERA_ISP_PF_CORRECTION_HSL_SLOPE_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_hsl_slope_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b04cL);
    system_sw_write_32(base + 0x1b04cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_pf_correction_hsl_slope_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b04cL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: hsl_offset
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_HSL_OFFSET_DEFAULT (0x000)
#define ACAMERA_ISP_PF_CORRECTION_HSL_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_HSL_OFFSET_OFFSET (0x21c4)
#define ACAMERA_ISP_PF_CORRECTION_HSL_OFFSET_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_hsl_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b04cL);
    system_sw_write_32(base + 0x1b04cL, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_pf_correction_hsl_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b04cL) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: hsl_thresh
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_HSL_THRESH_DEFAULT (0x000)
#define ACAMERA_ISP_PF_CORRECTION_HSL_THRESH_DATASIZE (12)
#define ACAMERA_ISP_PF_CORRECTION_HSL_THRESH_OFFSET (0x21c8)
#define ACAMERA_ISP_PF_CORRECTION_HSL_THRESH_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_pf_correction_hsl_thresh_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b050L);
    system_sw_write_32(base + 0x1b050L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_pf_correction_hsl_thresh_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b050L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: debug_sel
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        0: normal operation
//        1: radial weight in 0.8 format
//        2: sad_mask in 0.12 format
//        3: hue mask in 0.12 format
//        4: saturation mask in 0.12 format
//        5: luma mask in 12.0 format
//        6: pf mask in 12.0 format
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_DEBUG_SEL_DEFAULT (0x000)
#define ACAMERA_ISP_PF_CORRECTION_DEBUG_SEL_DATASIZE (8)
#define ACAMERA_ISP_PF_CORRECTION_DEBUG_SEL_OFFSET (0x21cc)
#define ACAMERA_ISP_PF_CORRECTION_DEBUG_SEL_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_pf_correction_debug_sel_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b054L);
    system_sw_write_32(base + 0x1b054L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_pf_correction_debug_sel_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1b054L) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Group: pf correction Shading
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// LUT: shading_lut
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Radial Purple Fringe Correction LUT.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_PF_CORRECTION_SHADING_SHADING_LUT_NODES (33)
#define ACAMERA_ISP_PF_CORRECTION_SHADING_SHADING_LUT_ADDRBITS (6)
#define ACAMERA_ISP_PF_CORRECTION_SHADING_SHADING_LUT_DATASIZE (8)
#define ACAMERA_ISP_PF_CORRECTION_SHADING_SHADING_LUT_OFFSET (0x1b058L)

// args: index (0-32), data (8-bit)
static __inline void acamera_isp_pf_correction_shading_shading_lut_write( uintptr_t base, uint8_t index,uint8_t data) {
    uintptr_t addr = base + 0x1b058L + (index & 0xFFFFFFFC);
    uint8_t offset = (index & 3) << 3;
    uint32_t curr = system_sw_read_32(addr);
    system_sw_write_32(addr, ((uint32_t)data << offset) | (curr & ~(0xFF << offset)));
}
static __inline uint8_t acamera_isp_pf_correction_shading_shading_lut_read( uintptr_t base, uint8_t index) {
    uintptr_t addr = base + 0x1b058L + (index & 0xFFFFFFFC);
    uint8_t offset = (index & 3) << 3;
    return (uint8_t)(system_sw_read_32(addr) >> offset);
}
// ------------------------------------------------------------------------------ //
// Group: ccm
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Color correction on RGB data using a 3x3 color matrix
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Enable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Color matrix enable: 0=off 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CCM_ENABLE_DEFAULT (1)
#define ACAMERA_ISP_CCM_ENABLE_DATASIZE (1)
#define ACAMERA_ISP_CCM_ENABLE_OFFSET (0x21f4)
#define ACAMERA_ISP_CCM_ENABLE_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_ccm_enable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b07cL);
    system_sw_write_32(base + 0x1b07cL, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_ccm_enable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1b07cL) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft R-R
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for red-red multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CCM_COEFFT_R_R_DEFAULT (0x0100)
#define ACAMERA_ISP_CCM_COEFFT_R_R_DATASIZE (13)
#define ACAMERA_ISP_CCM_COEFFT_R_R_OFFSET (0x21f8)
#define ACAMERA_ISP_CCM_COEFFT_R_R_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_ccm_coefft_r_r_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b080L);
    system_sw_write_32(base + 0x1b080L, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_ccm_coefft_r_r_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b080L) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft R-G
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for red-green multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CCM_COEFFT_R_G_DEFAULT (0x0000)
#define ACAMERA_ISP_CCM_COEFFT_R_G_DATASIZE (13)
#define ACAMERA_ISP_CCM_COEFFT_R_G_OFFSET (0x21fc)
#define ACAMERA_ISP_CCM_COEFFT_R_G_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_ccm_coefft_r_g_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b084L);
    system_sw_write_32(base + 0x1b084L, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_ccm_coefft_r_g_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b084L) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft R-B
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for red-blue multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CCM_COEFFT_R_B_DEFAULT (0x0000)
#define ACAMERA_ISP_CCM_COEFFT_R_B_DATASIZE (13)
#define ACAMERA_ISP_CCM_COEFFT_R_B_OFFSET (0x2200)
#define ACAMERA_ISP_CCM_COEFFT_R_B_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_ccm_coefft_r_b_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b088L);
    system_sw_write_32(base + 0x1b088L, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_ccm_coefft_r_b_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b088L) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft R-IR
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for red-ir multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CCM_COEFFT_R_IR_DEFAULT (0x0000)
#define ACAMERA_ISP_CCM_COEFFT_R_IR_DATASIZE (13)
#define ACAMERA_ISP_CCM_COEFFT_R_IR_OFFSET (0x2204)
#define ACAMERA_ISP_CCM_COEFFT_R_IR_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_ccm_coefft_r_ir_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b08cL);
    system_sw_write_32(base + 0x1b08cL, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_ccm_coefft_r_ir_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b08cL) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft G-R
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for green-red multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CCM_COEFFT_G_R_DEFAULT (0x0000)
#define ACAMERA_ISP_CCM_COEFFT_G_R_DATASIZE (13)
#define ACAMERA_ISP_CCM_COEFFT_G_R_OFFSET (0x2208)
#define ACAMERA_ISP_CCM_COEFFT_G_R_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_ccm_coefft_g_r_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b090L);
    system_sw_write_32(base + 0x1b090L, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_ccm_coefft_g_r_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b090L) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft G-G
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for green-green multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CCM_COEFFT_G_G_DEFAULT (0x0100)
#define ACAMERA_ISP_CCM_COEFFT_G_G_DATASIZE (13)
#define ACAMERA_ISP_CCM_COEFFT_G_G_OFFSET (0x220c)
#define ACAMERA_ISP_CCM_COEFFT_G_G_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_ccm_coefft_g_g_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b094L);
    system_sw_write_32(base + 0x1b094L, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_ccm_coefft_g_g_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b094L) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft G-B
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for green-blue multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CCM_COEFFT_G_B_DEFAULT (0x0000)
#define ACAMERA_ISP_CCM_COEFFT_G_B_DATASIZE (13)
#define ACAMERA_ISP_CCM_COEFFT_G_B_OFFSET (0x2210)
#define ACAMERA_ISP_CCM_COEFFT_G_B_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_ccm_coefft_g_b_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b098L);
    system_sw_write_32(base + 0x1b098L, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_ccm_coefft_g_b_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b098L) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft G-IR
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for green-ir multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CCM_COEFFT_G_IR_DEFAULT (0x0000)
#define ACAMERA_ISP_CCM_COEFFT_G_IR_DATASIZE (13)
#define ACAMERA_ISP_CCM_COEFFT_G_IR_OFFSET (0x2214)
#define ACAMERA_ISP_CCM_COEFFT_G_IR_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_ccm_coefft_g_ir_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b09cL);
    system_sw_write_32(base + 0x1b09cL, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_ccm_coefft_g_ir_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b09cL) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft B-R
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for blue-red multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CCM_COEFFT_B_R_DEFAULT (0x0000)
#define ACAMERA_ISP_CCM_COEFFT_B_R_DATASIZE (13)
#define ACAMERA_ISP_CCM_COEFFT_B_R_OFFSET (0x2218)
#define ACAMERA_ISP_CCM_COEFFT_B_R_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_ccm_coefft_b_r_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b0a0L);
    system_sw_write_32(base + 0x1b0a0L, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_ccm_coefft_b_r_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b0a0L) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft B-G
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for blue-green multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CCM_COEFFT_B_G_DEFAULT (0x0000)
#define ACAMERA_ISP_CCM_COEFFT_B_G_DATASIZE (13)
#define ACAMERA_ISP_CCM_COEFFT_B_G_OFFSET (0x221c)
#define ACAMERA_ISP_CCM_COEFFT_B_G_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_ccm_coefft_b_g_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b0a4L);
    system_sw_write_32(base + 0x1b0a4L, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_ccm_coefft_b_g_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b0a4L) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft B-B
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for blue-blue multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CCM_COEFFT_B_B_DEFAULT (0x0100)
#define ACAMERA_ISP_CCM_COEFFT_B_B_DATASIZE (13)
#define ACAMERA_ISP_CCM_COEFFT_B_B_OFFSET (0x2220)
#define ACAMERA_ISP_CCM_COEFFT_B_B_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_ccm_coefft_b_b_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b0a8L);
    system_sw_write_32(base + 0x1b0a8L, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_ccm_coefft_b_b_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b0a8L) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft B-IR
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for blue-ir multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CCM_COEFFT_B_IR_DEFAULT (0x0100)
#define ACAMERA_ISP_CCM_COEFFT_B_IR_DATASIZE (13)
#define ACAMERA_ISP_CCM_COEFFT_B_IR_OFFSET (0x2224)
#define ACAMERA_ISP_CCM_COEFFT_B_IR_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_ccm_coefft_b_ir_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b0acL);
    system_sw_write_32(base + 0x1b0acL, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_ccm_coefft_b_ir_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b0acL) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft WB R
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// gain for Red channel for antifog function
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CCM_COEFFT_WB_R_DEFAULT (0x0100)
#define ACAMERA_ISP_CCM_COEFFT_WB_R_DATASIZE (12)
#define ACAMERA_ISP_CCM_COEFFT_WB_R_OFFSET (0x2228)
#define ACAMERA_ISP_CCM_COEFFT_WB_R_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_ccm_coefft_wb_r_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b0b0L);
    system_sw_write_32(base + 0x1b0b0L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_ccm_coefft_wb_r_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b0b0L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft WB G
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// gain for Green channel for antifog function
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CCM_COEFFT_WB_G_DEFAULT (0x0100)
#define ACAMERA_ISP_CCM_COEFFT_WB_G_DATASIZE (12)
#define ACAMERA_ISP_CCM_COEFFT_WB_G_OFFSET (0x222c)
#define ACAMERA_ISP_CCM_COEFFT_WB_G_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_ccm_coefft_wb_g_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b0b4L);
    system_sw_write_32(base + 0x1b0b4L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_ccm_coefft_wb_g_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b0b4L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft WB B
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// gain for Blue channel for antifog function
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CCM_COEFFT_WB_B_DEFAULT (0x0100)
#define ACAMERA_ISP_CCM_COEFFT_WB_B_DATASIZE (12)
#define ACAMERA_ISP_CCM_COEFFT_WB_B_OFFSET (0x2230)
#define ACAMERA_ISP_CCM_COEFFT_WB_B_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_ccm_coefft_wb_b_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b0b8L);
    system_sw_write_32(base + 0x1b0b8L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_ccm_coefft_wb_b_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b0b8L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft WB IR
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// gain for IR channel for antifog function
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CCM_COEFFT_WB_IR_DEFAULT (0x0100)
#define ACAMERA_ISP_CCM_COEFFT_WB_IR_DATASIZE (12)
#define ACAMERA_ISP_CCM_COEFFT_WB_IR_OFFSET (0x2234)
#define ACAMERA_ISP_CCM_COEFFT_WB_IR_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_ccm_coefft_wb_ir_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b0bcL);
    system_sw_write_32(base + 0x1b0bcL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_ccm_coefft_wb_ir_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b0bcL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft fog offset R
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Offset R for antifog function
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CCM_COEFFT_FOG_OFFSET_R_DEFAULT (0x000)
#define ACAMERA_ISP_CCM_COEFFT_FOG_OFFSET_R_DATASIZE (12)
#define ACAMERA_ISP_CCM_COEFFT_FOG_OFFSET_R_OFFSET (0x2238)
#define ACAMERA_ISP_CCM_COEFFT_FOG_OFFSET_R_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_ccm_coefft_fog_offset_r_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b0c0L);
    system_sw_write_32(base + 0x1b0c0L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_ccm_coefft_fog_offset_r_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b0c0L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft fog offset G
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Offset G for antifog function
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CCM_COEFFT_FOG_OFFSET_G_DEFAULT (0x000)
#define ACAMERA_ISP_CCM_COEFFT_FOG_OFFSET_G_DATASIZE (12)
#define ACAMERA_ISP_CCM_COEFFT_FOG_OFFSET_G_OFFSET (0x223c)
#define ACAMERA_ISP_CCM_COEFFT_FOG_OFFSET_G_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_ccm_coefft_fog_offset_g_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b0c4L);
    system_sw_write_32(base + 0x1b0c4L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_ccm_coefft_fog_offset_g_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b0c4L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft fog offset B
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Offset B for antifog function
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CCM_COEFFT_FOG_OFFSET_B_DEFAULT (0x000)
#define ACAMERA_ISP_CCM_COEFFT_FOG_OFFSET_B_DATASIZE (12)
#define ACAMERA_ISP_CCM_COEFFT_FOG_OFFSET_B_OFFSET (0x2240)
#define ACAMERA_ISP_CCM_COEFFT_FOG_OFFSET_B_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_ccm_coefft_fog_offset_b_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b0c8L);
    system_sw_write_32(base + 0x1b0c8L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_ccm_coefft_fog_offset_b_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b0c8L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft fog offset IR
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Offset Ir for antifog function
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CCM_COEFFT_FOG_OFFSET_IR_DEFAULT (0x000)
#define ACAMERA_ISP_CCM_COEFFT_FOG_OFFSET_IR_DATASIZE (12)
#define ACAMERA_ISP_CCM_COEFFT_FOG_OFFSET_IR_OFFSET (0x2244)
#define ACAMERA_ISP_CCM_COEFFT_FOG_OFFSET_IR_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_ccm_coefft_fog_offset_ir_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b0ccL);
    system_sw_write_32(base + 0x1b0ccL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_ccm_coefft_fog_offset_ir_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b0ccL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Group: cnr
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Colour Noise Reduction
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: square_root_enable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// pre-CNR square root and the post-CNR square modules enable condition 
//            enable: 0=off 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_SQUARE_ROOT_ENABLE_DEFAULT (1)
#define ACAMERA_ISP_CNR_SQUARE_ROOT_ENABLE_DATASIZE (1)
#define ACAMERA_ISP_CNR_SQUARE_ROOT_ENABLE_OFFSET (0x2248)
#define ACAMERA_ISP_CNR_SQUARE_ROOT_ENABLE_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_cnr_square_root_enable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b0d0L);
    system_sw_write_32(base + 0x1b0d0L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_cnr_square_root_enable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1b0d0L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: enable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// CNR enable: 0=off 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_ENABLE_DEFAULT (1)
#define ACAMERA_ISP_CNR_ENABLE_DATASIZE (1)
#define ACAMERA_ISP_CNR_ENABLE_OFFSET (0x224c)
#define ACAMERA_ISP_CNR_ENABLE_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_cnr_enable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b0d4L);
    system_sw_write_32(base + 0x1b0d4L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_cnr_enable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1b0d4L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: debug_reg
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// CNR Debug: 0=off 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_DEBUG_REG_DEFAULT (0x0000)
#define ACAMERA_ISP_CNR_DEBUG_REG_DATASIZE (16)
#define ACAMERA_ISP_CNR_DEBUG_REG_OFFSET (0x2250)
#define ACAMERA_ISP_CNR_DEBUG_REG_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_cnr_debug_reg_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b0d8L);
    system_sw_write_32(base + 0x1b0d8L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_cnr_debug_reg_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b0d8L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: mode
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// CNR enable: 0=off 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_MODE_DEFAULT (0x0)
#define ACAMERA_ISP_CNR_MODE_DATASIZE (8)
#define ACAMERA_ISP_CNR_MODE_OFFSET (0x2254)
#define ACAMERA_ISP_CNR_MODE_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_cnr_mode_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b0dcL);
    system_sw_write_32(base + 0x1b0dcL, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_cnr_mode_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1b0dcL) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: delta_factor
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// CNR enable: 0=off 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_DELTA_FACTOR_DEFAULT (0x277)
#define ACAMERA_ISP_CNR_DELTA_FACTOR_DATASIZE (12)
#define ACAMERA_ISP_CNR_DELTA_FACTOR_OFFSET (0x2258)
#define ACAMERA_ISP_CNR_DELTA_FACTOR_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_cnr_delta_factor_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b0e0L);
    system_sw_write_32(base + 0x1b0e0L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_cnr_delta_factor_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b0e0L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: effective_kernel
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Effective kernel
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_EFFECTIVE_KERNEL_DEFAULT (0x3F)
#define ACAMERA_ISP_CNR_EFFECTIVE_KERNEL_DATASIZE (7)
#define ACAMERA_ISP_CNR_EFFECTIVE_KERNEL_OFFSET (0x225c)
#define ACAMERA_ISP_CNR_EFFECTIVE_KERNEL_MASK (0x7f)

// args: data (7-bit)
static __inline void acamera_isp_cnr_effective_kernel_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b0e4L);
    system_sw_write_32(base + 0x1b0e4L, (((uint32_t) (data & 0x7f)) << 0) | (curr & 0xffffff80));
}
static __inline uint8_t acamera_isp_cnr_effective_kernel_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1b0e4L) & 0x7f) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: u_center
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Coordinates of u center
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_U_CENTER_DEFAULT (0x200)
#define ACAMERA_ISP_CNR_U_CENTER_DATASIZE (12)
#define ACAMERA_ISP_CNR_U_CENTER_OFFSET (0x2260)
#define ACAMERA_ISP_CNR_U_CENTER_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_cnr_u_center_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b0e8L);
    system_sw_write_32(base + 0x1b0e8L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_cnr_u_center_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b0e8L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: v_center
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Coordinates of v center
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_V_CENTER_DEFAULT (0x200)
#define ACAMERA_ISP_CNR_V_CENTER_DATASIZE (12)
#define ACAMERA_ISP_CNR_V_CENTER_OFFSET (0x2264)
#define ACAMERA_ISP_CNR_V_CENTER_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_cnr_v_center_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b0ecL);
    system_sw_write_32(base + 0x1b0ecL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_cnr_v_center_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b0ecL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: global_offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// umean1 offset
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_GLOBAL_OFFSET_DEFAULT (0x332)
#define ACAMERA_ISP_CNR_GLOBAL_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_CNR_GLOBAL_OFFSET_OFFSET (0x2268)
#define ACAMERA_ISP_CNR_GLOBAL_OFFSET_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_cnr_global_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b0f0L);
    system_sw_write_32(base + 0x1b0f0L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_cnr_global_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b0f0L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: global_slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// umean1 slope
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_GLOBAL_SLOPE_DEFAULT (0x0CD)
#define ACAMERA_ISP_CNR_GLOBAL_SLOPE_DATASIZE (16)
#define ACAMERA_ISP_CNR_GLOBAL_SLOPE_OFFSET (0x226c)
#define ACAMERA_ISP_CNR_GLOBAL_SLOPE_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_cnr_global_slope_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b0f4L);
    system_sw_write_32(base + 0x1b0f4L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_cnr_global_slope_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b0f4L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: uv_seg1_threshold
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// uv_seg1 threshold
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_UV_SEG1_THRESHOLD_DEFAULT (0x000)
#define ACAMERA_ISP_CNR_UV_SEG1_THRESHOLD_DATASIZE (12)
#define ACAMERA_ISP_CNR_UV_SEG1_THRESHOLD_OFFSET (0x2270)
#define ACAMERA_ISP_CNR_UV_SEG1_THRESHOLD_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_cnr_uv_seg1_threshold_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b0f8L);
    system_sw_write_32(base + 0x1b0f8L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_cnr_uv_seg1_threshold_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b0f8L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: uv_seg1_offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// uv_seg1 offset
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_UV_SEG1_OFFSET_DEFAULT (0x0AE)
#define ACAMERA_ISP_CNR_UV_SEG1_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_CNR_UV_SEG1_OFFSET_OFFSET (0x2274)
#define ACAMERA_ISP_CNR_UV_SEG1_OFFSET_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_cnr_uv_seg1_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b0fcL);
    system_sw_write_32(base + 0x1b0fcL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_cnr_uv_seg1_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b0fcL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: uv_seg1_slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// uv_seg1 slope
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_UV_SEG1_SLOPE_DEFAULT (0xFBD8)
#define ACAMERA_ISP_CNR_UV_SEG1_SLOPE_DATASIZE (16)
#define ACAMERA_ISP_CNR_UV_SEG1_SLOPE_OFFSET (0x2278)
#define ACAMERA_ISP_CNR_UV_SEG1_SLOPE_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_cnr_uv_seg1_slope_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b100L);
    system_sw_write_32(base + 0x1b100L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_cnr_uv_seg1_slope_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b100L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: umean1_threshold
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// umean1 threshold
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_UMEAN1_THRESHOLD_DEFAULT (0x000)
#define ACAMERA_ISP_CNR_UMEAN1_THRESHOLD_DATASIZE (12)
#define ACAMERA_ISP_CNR_UMEAN1_THRESHOLD_OFFSET (0x227c)
#define ACAMERA_ISP_CNR_UMEAN1_THRESHOLD_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_cnr_umean1_threshold_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b104L);
    system_sw_write_32(base + 0x1b104L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_cnr_umean1_threshold_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b104L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: umean1_offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// umean1 offset
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_UMEAN1_OFFSET_DEFAULT (0x03E)
#define ACAMERA_ISP_CNR_UMEAN1_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_CNR_UMEAN1_OFFSET_OFFSET (0x2280)
#define ACAMERA_ISP_CNR_UMEAN1_OFFSET_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_cnr_umean1_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b108L);
    system_sw_write_32(base + 0x1b108L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_cnr_umean1_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b108L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: umean1_slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// umean1 slope
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_UMEAN1_SLOPE_DEFAULT (0xE7B4)
#define ACAMERA_ISP_CNR_UMEAN1_SLOPE_DATASIZE (16)
#define ACAMERA_ISP_CNR_UMEAN1_SLOPE_OFFSET (0x2284)
#define ACAMERA_ISP_CNR_UMEAN1_SLOPE_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_cnr_umean1_slope_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b10cL);
    system_sw_write_32(base + 0x1b10cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_cnr_umean1_slope_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b10cL) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: umean2_threshold
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// umean2 threshold
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_UMEAN2_THRESHOLD_DEFAULT (0x000)
#define ACAMERA_ISP_CNR_UMEAN2_THRESHOLD_DATASIZE (12)
#define ACAMERA_ISP_CNR_UMEAN2_THRESHOLD_OFFSET (0x2288)
#define ACAMERA_ISP_CNR_UMEAN2_THRESHOLD_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_cnr_umean2_threshold_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b110L);
    system_sw_write_32(base + 0x1b110L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_cnr_umean2_threshold_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b110L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: umean2_offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// umean2 offset
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_UMEAN2_OFFSET_DEFAULT (0x03E)
#define ACAMERA_ISP_CNR_UMEAN2_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_CNR_UMEAN2_OFFSET_OFFSET (0x228c)
#define ACAMERA_ISP_CNR_UMEAN2_OFFSET_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_cnr_umean2_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b114L);
    system_sw_write_32(base + 0x1b114L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_cnr_umean2_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b114L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: umean2_slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// umean2 slope
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_UMEAN2_SLOPE_DEFAULT (0xE7B4)
#define ACAMERA_ISP_CNR_UMEAN2_SLOPE_DATASIZE (16)
#define ACAMERA_ISP_CNR_UMEAN2_SLOPE_OFFSET (0x2290)
#define ACAMERA_ISP_CNR_UMEAN2_SLOPE_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_cnr_umean2_slope_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b118L);
    system_sw_write_32(base + 0x1b118L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_cnr_umean2_slope_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b118L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: vmean1_threshold
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// vmean1 threshold
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_VMEAN1_THRESHOLD_DEFAULT (0x000)
#define ACAMERA_ISP_CNR_VMEAN1_THRESHOLD_DATASIZE (12)
#define ACAMERA_ISP_CNR_VMEAN1_THRESHOLD_OFFSET (0x2294)
#define ACAMERA_ISP_CNR_VMEAN1_THRESHOLD_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_cnr_vmean1_threshold_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b11cL);
    system_sw_write_32(base + 0x1b11cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_cnr_vmean1_threshold_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b11cL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: vmean1_offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// vmean1 offset
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_VMEAN1_OFFSET_DEFAULT (0x03E)
#define ACAMERA_ISP_CNR_VMEAN1_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_CNR_VMEAN1_OFFSET_OFFSET (0x2298)
#define ACAMERA_ISP_CNR_VMEAN1_OFFSET_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_cnr_vmean1_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b120L);
    system_sw_write_32(base + 0x1b120L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_cnr_vmean1_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b120L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: vmean1_slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// vmean1 slope
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_VMEAN1_SLOPE_DEFAULT (0xE7B4)
#define ACAMERA_ISP_CNR_VMEAN1_SLOPE_DATASIZE (16)
#define ACAMERA_ISP_CNR_VMEAN1_SLOPE_OFFSET (0x229c)
#define ACAMERA_ISP_CNR_VMEAN1_SLOPE_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_cnr_vmean1_slope_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b124L);
    system_sw_write_32(base + 0x1b124L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_cnr_vmean1_slope_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b124L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: vmean2_threshold
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// vmean2 threshold
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_VMEAN2_THRESHOLD_DEFAULT (0x000)
#define ACAMERA_ISP_CNR_VMEAN2_THRESHOLD_DATASIZE (12)
#define ACAMERA_ISP_CNR_VMEAN2_THRESHOLD_OFFSET (0x22a0)
#define ACAMERA_ISP_CNR_VMEAN2_THRESHOLD_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_cnr_vmean2_threshold_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b128L);
    system_sw_write_32(base + 0x1b128L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_cnr_vmean2_threshold_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b128L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: vmean2_offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// vmean2 offset
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_VMEAN2_OFFSET_DEFAULT (0x03E)
#define ACAMERA_ISP_CNR_VMEAN2_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_CNR_VMEAN2_OFFSET_OFFSET (0x22a4)
#define ACAMERA_ISP_CNR_VMEAN2_OFFSET_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_cnr_vmean2_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b12cL);
    system_sw_write_32(base + 0x1b12cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_cnr_vmean2_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b12cL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: vmean2_slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// vmean2 slope
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_VMEAN2_SLOPE_DEFAULT (0xE7B4)
#define ACAMERA_ISP_CNR_VMEAN2_SLOPE_DATASIZE (16)
#define ACAMERA_ISP_CNR_VMEAN2_SLOPE_OFFSET (0x22a8)
#define ACAMERA_ISP_CNR_VMEAN2_SLOPE_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_cnr_vmean2_slope_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b130L);
    system_sw_write_32(base + 0x1b130L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_cnr_vmean2_slope_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b130L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: uv_var1_threshold
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// uv_var1 threshold
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_UV_VAR1_THRESHOLD_DEFAULT (0x000)
#define ACAMERA_ISP_CNR_UV_VAR1_THRESHOLD_DATASIZE (12)
#define ACAMERA_ISP_CNR_UV_VAR1_THRESHOLD_OFFSET (0x22ac)
#define ACAMERA_ISP_CNR_UV_VAR1_THRESHOLD_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_cnr_uv_var1_threshold_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b134L);
    system_sw_write_32(base + 0x1b134L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_cnr_uv_var1_threshold_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b134L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: uv_var1_offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// uv_var1 offset
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_UV_VAR1_OFFSET_DEFAULT (0x3FF)
#define ACAMERA_ISP_CNR_UV_VAR1_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_CNR_UV_VAR1_OFFSET_OFFSET (0x22b0)
#define ACAMERA_ISP_CNR_UV_VAR1_OFFSET_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_cnr_uv_var1_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b138L);
    system_sw_write_32(base + 0x1b138L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_cnr_uv_var1_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b138L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: uv_var1_slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// uv_var2 slope
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_UV_VAR1_SLOPE_DEFAULT (0xFFFF)
#define ACAMERA_ISP_CNR_UV_VAR1_SLOPE_DATASIZE (16)
#define ACAMERA_ISP_CNR_UV_VAR1_SLOPE_OFFSET (0x22b4)
#define ACAMERA_ISP_CNR_UV_VAR1_SLOPE_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_cnr_uv_var1_slope_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b13cL);
    system_sw_write_32(base + 0x1b13cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_cnr_uv_var1_slope_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b13cL) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: uv_var2_threshold
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// uv_var2 threshold
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_UV_VAR2_THRESHOLD_DEFAULT (0x000)
#define ACAMERA_ISP_CNR_UV_VAR2_THRESHOLD_DATASIZE (12)
#define ACAMERA_ISP_CNR_UV_VAR2_THRESHOLD_OFFSET (0x22b8)
#define ACAMERA_ISP_CNR_UV_VAR2_THRESHOLD_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_cnr_uv_var2_threshold_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b140L);
    system_sw_write_32(base + 0x1b140L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_cnr_uv_var2_threshold_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b140L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: uv_var2_offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// uv_var2 offset
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_UV_VAR2_OFFSET_DEFAULT (0x3FF)
#define ACAMERA_ISP_CNR_UV_VAR2_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_CNR_UV_VAR2_OFFSET_OFFSET (0x22bc)
#define ACAMERA_ISP_CNR_UV_VAR2_OFFSET_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_cnr_uv_var2_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b144L);
    system_sw_write_32(base + 0x1b144L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_cnr_uv_var2_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b144L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: uv_var2_slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// uv_var2 slope
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_UV_VAR2_SLOPE_DEFAULT (0xFFFF)
#define ACAMERA_ISP_CNR_UV_VAR2_SLOPE_DATASIZE (16)
#define ACAMERA_ISP_CNR_UV_VAR2_SLOPE_OFFSET (0x22c0)
#define ACAMERA_ISP_CNR_UV_VAR2_SLOPE_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_cnr_uv_var2_slope_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b148L);
    system_sw_write_32(base + 0x1b148L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_cnr_uv_var2_slope_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b148L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: uv_var1_scale
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// uv_var1 scale
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_UV_VAR1_SCALE_DEFAULT (0x10)
#define ACAMERA_ISP_CNR_UV_VAR1_SCALE_DATASIZE (6)
#define ACAMERA_ISP_CNR_UV_VAR1_SCALE_OFFSET (0x22c4)
#define ACAMERA_ISP_CNR_UV_VAR1_SCALE_MASK (0x3f)

// args: data (6-bit)
static __inline void acamera_isp_cnr_uv_var1_scale_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b14cL);
    system_sw_write_32(base + 0x1b14cL, (((uint32_t) (data & 0x3f)) << 0) | (curr & 0xffffffc0));
}
static __inline uint8_t acamera_isp_cnr_uv_var1_scale_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1b14cL) & 0x3f) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: uv_var2_scale
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// uv_var2 scale
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_UV_VAR2_SCALE_DEFAULT (0x10)
#define ACAMERA_ISP_CNR_UV_VAR2_SCALE_DATASIZE (6)
#define ACAMERA_ISP_CNR_UV_VAR2_SCALE_OFFSET (0x22c4)
#define ACAMERA_ISP_CNR_UV_VAR2_SCALE_MASK (0x3f00)

// args: data (6-bit)
static __inline void acamera_isp_cnr_uv_var2_scale_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b14cL);
    system_sw_write_32(base + 0x1b14cL, (((uint32_t) (data & 0x3f)) << 8) | (curr & 0xffffc0ff));
}
static __inline uint8_t acamera_isp_cnr_uv_var2_scale_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1b14cL) & 0x3f00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: uv_delta1_threshold
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// uv_delta1 threshold
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_UV_DELTA1_THRESHOLD_DEFAULT (0x000)
#define ACAMERA_ISP_CNR_UV_DELTA1_THRESHOLD_DATASIZE (12)
#define ACAMERA_ISP_CNR_UV_DELTA1_THRESHOLD_OFFSET (0x22c8)
#define ACAMERA_ISP_CNR_UV_DELTA1_THRESHOLD_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_cnr_uv_delta1_threshold_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b150L);
    system_sw_write_32(base + 0x1b150L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_cnr_uv_delta1_threshold_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b150L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: uv_delta1_offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// uv_delta1 offset
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_UV_DELTA1_OFFSET_DEFAULT (0x0B9)
#define ACAMERA_ISP_CNR_UV_DELTA1_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_CNR_UV_DELTA1_OFFSET_OFFSET (0x22cc)
#define ACAMERA_ISP_CNR_UV_DELTA1_OFFSET_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_cnr_uv_delta1_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b154L);
    system_sw_write_32(base + 0x1b154L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_cnr_uv_delta1_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b154L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: uv_delta1_slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// uv_delta1 slope
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_UV_DELTA1_SLOPE_DEFAULT (0x0600)
#define ACAMERA_ISP_CNR_UV_DELTA1_SLOPE_DATASIZE (16)
#define ACAMERA_ISP_CNR_UV_DELTA1_SLOPE_OFFSET (0x22d0)
#define ACAMERA_ISP_CNR_UV_DELTA1_SLOPE_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_cnr_uv_delta1_slope_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b158L);
    system_sw_write_32(base + 0x1b158L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_cnr_uv_delta1_slope_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b158L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: uv_delta2_threshold
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// uv_delta2 threshold
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_UV_DELTA2_THRESHOLD_DEFAULT (0x000)
#define ACAMERA_ISP_CNR_UV_DELTA2_THRESHOLD_DATASIZE (12)
#define ACAMERA_ISP_CNR_UV_DELTA2_THRESHOLD_OFFSET (0x22d4)
#define ACAMERA_ISP_CNR_UV_DELTA2_THRESHOLD_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_cnr_uv_delta2_threshold_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b15cL);
    system_sw_write_32(base + 0x1b15cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_cnr_uv_delta2_threshold_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b15cL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: uv_delta2_offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// uv_delta2 offset
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_UV_DELTA2_OFFSET_DEFAULT (0x0B9)
#define ACAMERA_ISP_CNR_UV_DELTA2_OFFSET_DATASIZE (12)
#define ACAMERA_ISP_CNR_UV_DELTA2_OFFSET_OFFSET (0x22d8)
#define ACAMERA_ISP_CNR_UV_DELTA2_OFFSET_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_cnr_uv_delta2_offset_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b160L);
    system_sw_write_32(base + 0x1b160L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_cnr_uv_delta2_offset_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b160L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: uv_delta2_slope
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// uv_delta2 slope
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_UV_DELTA2_SLOPE_DEFAULT (0x0600)
#define ACAMERA_ISP_CNR_UV_DELTA2_SLOPE_DATASIZE (16)
#define ACAMERA_ISP_CNR_UV_DELTA2_SLOPE_OFFSET (0x22dc)
#define ACAMERA_ISP_CNR_UV_DELTA2_SLOPE_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_cnr_uv_delta2_slope_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b164L);
    system_sw_write_32(base + 0x1b164L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_cnr_uv_delta2_slope_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b164L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Statusa
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// CNR Debug Port
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_STATUSA_DEFAULT (0x0000)
#define ACAMERA_ISP_CNR_STATUSA_DATASIZE (16)
#define ACAMERA_ISP_CNR_STATUSA_OFFSET (0x22e0)
#define ACAMERA_ISP_CNR_STATUSA_MASK (0xffff)

// args: data (16-bit)
static __inline uint16_t acamera_isp_cnr_statusa_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b168L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Statusb
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// CNR Debug Port
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_CNR_STATUSB_DEFAULT (0x0000)
#define ACAMERA_ISP_CNR_STATUSB_DATASIZE (16)
#define ACAMERA_ISP_CNR_STATUSB_OFFSET (0x22e0)
#define ACAMERA_ISP_CNR_STATUSB_MASK (0xffff0000)

// args: data (16-bit)
static __inline uint16_t acamera_isp_cnr_statusb_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b168L) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Group: nonequ gamma
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// nonequ_gamma module
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: srgb_lut_enable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  enables gamma sRGB
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_NONEQU_GAMMA_SRGB_LUT_ENABLE_DEFAULT (0x0)
#define ACAMERA_ISP_NONEQU_GAMMA_SRGB_LUT_ENABLE_DATASIZE (1)
#define ACAMERA_ISP_NONEQU_GAMMA_SRGB_LUT_ENABLE_OFFSET (0x22e4)
#define ACAMERA_ISP_NONEQU_GAMMA_SRGB_LUT_ENABLE_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_nonequ_gamma_srgb_lut_enable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b16cL);
    system_sw_write_32(base + 0x1b16cL, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_nonequ_gamma_srgb_lut_enable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1b16cL) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// LUT: srgb_lut_coeff LUT
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Color space (HDR Linear to sRGB) LUT
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_NONEQU_GAMMA_SRGB_LUT_COEFF_LUT_NODES (65)
#define ACAMERA_ISP_NONEQU_GAMMA_SRGB_LUT_COEFF_LUT_ADDRBITS (7)
#define ACAMERA_ISP_NONEQU_GAMMA_SRGB_LUT_COEFF_LUT_DATASIZE (14)
#define ACAMERA_ISP_NONEQU_GAMMA_SRGB_LUT_COEFF_LUT_OFFSET (0x1b170L)

// args: index (0-64), data (14-bit)
static __inline void acamera_isp_nonequ_gamma_srgb_lut_coeff_lut_write( uintptr_t base, uint8_t index,uint16_t data) {
    uintptr_t addr = base + 0x1b170L + (index << 2);
    system_sw_write_32(addr, data);
}
static __inline uint16_t acamera_isp_nonequ_gamma_srgb_lut_coeff_lut_read( uintptr_t base, uint8_t index) {
    uintptr_t addr = base + 0x1b170L + (index << 2);
    return system_sw_read_32(addr);
}
// ------------------------------------------------------------------------------ //
// Group: lumvar
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: active_width
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            Active width. This depends on the position of the luma variance module. if this module is connected to the 
//            full resolution pipeline, then the active_width should be the full resolution frame width.
//            if its in the downscaled pipeline, then the active_width should be the post-scaler width
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_LUMVAR_ACTIVE_WIDTH_DEFAULT (1920)
#define ACAMERA_ISP_LUMVAR_ACTIVE_WIDTH_DATASIZE (16)
#define ACAMERA_ISP_LUMVAR_ACTIVE_WIDTH_OFFSET (0x23ec)
#define ACAMERA_ISP_LUMVAR_ACTIVE_WIDTH_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_lumvar_active_width_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b274L);
    system_sw_write_32(base + 0x1b274L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_lumvar_active_width_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b274L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: active_height
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            Active height. This depends on the position of the luma variance module. if this module is connected to the 
//            full resolution pipeline, then the active_height should be the full resolution frame height.
//            if its in the downscaled pipeline, then the active_height should be the post-scaler height
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_LUMVAR_ACTIVE_HEIGHT_DEFAULT (1080)
#define ACAMERA_ISP_LUMVAR_ACTIVE_HEIGHT_DATASIZE (16)
#define ACAMERA_ISP_LUMVAR_ACTIVE_HEIGHT_OFFSET (0x23ec)
#define ACAMERA_ISP_LUMVAR_ACTIVE_HEIGHT_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_lumvar_active_height_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b274L);
    system_sw_write_32(base + 0x1b274L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_lumvar_active_height_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b274L) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Group: metering aexp
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Derives information for use by the AE and AWB modules
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Hist Thresh 0 1
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Histogram threshold for bin 0/1 boundary
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AEXP_HIST_THRESH_0_1_DEFAULT (0x10)
#define ACAMERA_ISP_METERING_AEXP_HIST_THRESH_0_1_DATASIZE (12)
#define ACAMERA_ISP_METERING_AEXP_HIST_THRESH_0_1_OFFSET (0x23f0)
#define ACAMERA_ISP_METERING_AEXP_HIST_THRESH_0_1_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_metering_aexp_hist_thresh_0_1_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b278L);
    system_sw_write_32(base + 0x1b278L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_metering_aexp_hist_thresh_0_1_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b278L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Hist Thresh 1 2
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Histogram threshold for bin 1/2 boundary
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AEXP_HIST_THRESH_1_2_DEFAULT (0x20)
#define ACAMERA_ISP_METERING_AEXP_HIST_THRESH_1_2_DATASIZE (12)
#define ACAMERA_ISP_METERING_AEXP_HIST_THRESH_1_2_OFFSET (0x23f4)
#define ACAMERA_ISP_METERING_AEXP_HIST_THRESH_1_2_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_metering_aexp_hist_thresh_1_2_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b27cL);
    system_sw_write_32(base + 0x1b27cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_metering_aexp_hist_thresh_1_2_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b27cL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Hist Thresh 3 4
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Histogram threshold for bin 2/3 boundary
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AEXP_HIST_THRESH_3_4_DEFAULT (0xD0)
#define ACAMERA_ISP_METERING_AEXP_HIST_THRESH_3_4_DATASIZE (12)
#define ACAMERA_ISP_METERING_AEXP_HIST_THRESH_3_4_OFFSET (0x23f8)
#define ACAMERA_ISP_METERING_AEXP_HIST_THRESH_3_4_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_metering_aexp_hist_thresh_3_4_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b280L);
    system_sw_write_32(base + 0x1b280L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_metering_aexp_hist_thresh_3_4_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b280L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Hist Thresh 4 5
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Histogram threshold for bin 3/4 boundary
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AEXP_HIST_THRESH_4_5_DEFAULT (0xE0)
#define ACAMERA_ISP_METERING_AEXP_HIST_THRESH_4_5_DATASIZE (12)
#define ACAMERA_ISP_METERING_AEXP_HIST_THRESH_4_5_OFFSET (0x23fc)
#define ACAMERA_ISP_METERING_AEXP_HIST_THRESH_4_5_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_metering_aexp_hist_thresh_4_5_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b284L);
    system_sw_write_32(base + 0x1b284L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_metering_aexp_hist_thresh_4_5_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b284L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Hist 0
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Normalized histogram results for bin 0
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AEXP_HIST_0_DEFAULT (0x0)
#define ACAMERA_ISP_METERING_AEXP_HIST_0_DATASIZE (16)
#define ACAMERA_ISP_METERING_AEXP_HIST_0_OFFSET (0x2400)
#define ACAMERA_ISP_METERING_AEXP_HIST_0_MASK (0xffff)

// args: data (16-bit)
static __inline uint16_t acamera_isp_metering_aexp_hist_0_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b288L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Hist 1
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Normalized histogram results for bin 1
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AEXP_HIST_1_DEFAULT (0x0)
#define ACAMERA_ISP_METERING_AEXP_HIST_1_DATASIZE (16)
#define ACAMERA_ISP_METERING_AEXP_HIST_1_OFFSET (0x2404)
#define ACAMERA_ISP_METERING_AEXP_HIST_1_MASK (0xffff)

// args: data (16-bit)
static __inline uint16_t acamera_isp_metering_aexp_hist_1_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b28cL) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Hist 3
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Normalized histogram results for bin 3
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AEXP_HIST_3_DEFAULT (0x0)
#define ACAMERA_ISP_METERING_AEXP_HIST_3_DATASIZE (16)
#define ACAMERA_ISP_METERING_AEXP_HIST_3_OFFSET (0x2408)
#define ACAMERA_ISP_METERING_AEXP_HIST_3_MASK (0xffff)

// args: data (16-bit)
static __inline uint16_t acamera_isp_metering_aexp_hist_3_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b290L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Hist 4
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Normalized histogram results for bin 4
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AEXP_HIST_4_DEFAULT (0x0)
#define ACAMERA_ISP_METERING_AEXP_HIST_4_DATASIZE (16)
#define ACAMERA_ISP_METERING_AEXP_HIST_4_OFFSET (0x240c)
#define ACAMERA_ISP_METERING_AEXP_HIST_4_MASK (0xffff)

// args: data (16-bit)
static __inline uint16_t acamera_isp_metering_aexp_hist_4_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b294L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Nodes Used Horiz
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Number of active zones horizontally for AE stats collection
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AEXP_NODES_USED_HORIZ_DEFAULT (23)
#define ACAMERA_ISP_METERING_AEXP_NODES_USED_HORIZ_DATASIZE (8)
#define ACAMERA_ISP_METERING_AEXP_NODES_USED_HORIZ_OFFSET (0x2410)
#define ACAMERA_ISP_METERING_AEXP_NODES_USED_HORIZ_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_metering_aexp_nodes_used_horiz_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b298L);
    system_sw_write_32(base + 0x1b298L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_metering_aexp_nodes_used_horiz_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1b298L) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Nodes Used Vert
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Number of active zones vertically for AE stats collection
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AEXP_NODES_USED_VERT_DEFAULT (21)
#define ACAMERA_ISP_METERING_AEXP_NODES_USED_VERT_DATASIZE (8)
#define ACAMERA_ISP_METERING_AEXP_NODES_USED_VERT_OFFSET (0x2410)
#define ACAMERA_ISP_METERING_AEXP_NODES_USED_VERT_MASK (0xff00)

// args: data (8-bit)
static __inline void acamera_isp_metering_aexp_nodes_used_vert_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b298L);
    system_sw_write_32(base + 0x1b298L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
}
static __inline uint8_t acamera_isp_metering_aexp_nodes_used_vert_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1b298L) & 0xff00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Group: metering awb
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: stats mode
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Statistics mode: 0 - legacy(G/R,B/R), 1 - current (R/G, B/G) 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AWB_STATS_MODE_DEFAULT (0)
#define ACAMERA_ISP_METERING_AWB_STATS_MODE_DATASIZE (1)
#define ACAMERA_ISP_METERING_AWB_STATS_MODE_OFFSET (0x2414)
#define ACAMERA_ISP_METERING_AWB_STATS_MODE_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_metering_awb_stats_mode_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b29cL);
    system_sw_write_32(base + 0x1b29cL, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_metering_awb_stats_mode_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1b29cL) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: White Level AWB
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Upper limit of valid data for AWB
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AWB_WHITE_LEVEL_AWB_DEFAULT (0x3ff)
#define ACAMERA_ISP_METERING_AWB_WHITE_LEVEL_AWB_DATASIZE (10)
#define ACAMERA_ISP_METERING_AWB_WHITE_LEVEL_AWB_OFFSET (0x2418)
#define ACAMERA_ISP_METERING_AWB_WHITE_LEVEL_AWB_MASK (0x3ff)

// args: data (10-bit)
static __inline void acamera_isp_metering_awb_white_level_awb_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b2a0L);
    system_sw_write_32(base + 0x1b2a0L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
}
static __inline uint16_t acamera_isp_metering_awb_white_level_awb_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b2a0L) & 0x3ff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Black Level AWB
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Lower limit of valid data for AWB
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AWB_BLACK_LEVEL_AWB_DEFAULT (0)
#define ACAMERA_ISP_METERING_AWB_BLACK_LEVEL_AWB_DATASIZE (10)
#define ACAMERA_ISP_METERING_AWB_BLACK_LEVEL_AWB_OFFSET (0x241c)
#define ACAMERA_ISP_METERING_AWB_BLACK_LEVEL_AWB_MASK (0x3ff)

// args: data (10-bit)
static __inline void acamera_isp_metering_awb_black_level_awb_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b2a4L);
    system_sw_write_32(base + 0x1b2a4L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
}
static __inline uint16_t acamera_isp_metering_awb_black_level_awb_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b2a4L) & 0x3ff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Cr Ref Max AWB
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Maximum value of R/G for white region
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AWB_CR_REF_MAX_AWB_DEFAULT (0x1FF)
#define ACAMERA_ISP_METERING_AWB_CR_REF_MAX_AWB_DATASIZE (12)
#define ACAMERA_ISP_METERING_AWB_CR_REF_MAX_AWB_OFFSET (0x2420)
#define ACAMERA_ISP_METERING_AWB_CR_REF_MAX_AWB_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_metering_awb_cr_ref_max_awb_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b2a8L);
    system_sw_write_32(base + 0x1b2a8L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_metering_awb_cr_ref_max_awb_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b2a8L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Cr Ref Min AWB
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Minimum value of R/G for white region
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AWB_CR_REF_MIN_AWB_DEFAULT (0x040)
#define ACAMERA_ISP_METERING_AWB_CR_REF_MIN_AWB_DATASIZE (12)
#define ACAMERA_ISP_METERING_AWB_CR_REF_MIN_AWB_OFFSET (0x2424)
#define ACAMERA_ISP_METERING_AWB_CR_REF_MIN_AWB_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_metering_awb_cr_ref_min_awb_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b2acL);
    system_sw_write_32(base + 0x1b2acL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_metering_awb_cr_ref_min_awb_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b2acL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Cb Ref Max AWB
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Maximum value of B/G for white region
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AWB_CB_REF_MAX_AWB_DEFAULT (0x1FF)
#define ACAMERA_ISP_METERING_AWB_CB_REF_MAX_AWB_DATASIZE (12)
#define ACAMERA_ISP_METERING_AWB_CB_REF_MAX_AWB_OFFSET (0x2428)
#define ACAMERA_ISP_METERING_AWB_CB_REF_MAX_AWB_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_metering_awb_cb_ref_max_awb_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b2b0L);
    system_sw_write_32(base + 0x1b2b0L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_metering_awb_cb_ref_max_awb_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b2b0L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Cb Ref Min AWB
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Minimum value of B/G for white region
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AWB_CB_REF_MIN_AWB_DEFAULT (0x040)
#define ACAMERA_ISP_METERING_AWB_CB_REF_MIN_AWB_DATASIZE (12)
#define ACAMERA_ISP_METERING_AWB_CB_REF_MIN_AWB_OFFSET (0x242c)
#define ACAMERA_ISP_METERING_AWB_CB_REF_MIN_AWB_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_metering_awb_cb_ref_min_awb_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b2b4L);
    system_sw_write_32(base + 0x1b2b4L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_metering_awb_cb_ref_min_awb_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b2b4L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: RG
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// AWB statistics R/G color ratio output
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AWB_RG_DEFAULT (0x0)
#define ACAMERA_ISP_METERING_AWB_RG_DATASIZE (12)
#define ACAMERA_ISP_METERING_AWB_RG_OFFSET (0x2430)
#define ACAMERA_ISP_METERING_AWB_RG_MASK (0xfff)

// args: data (12-bit)
static __inline uint16_t acamera_isp_metering_awb_rg_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b2b8L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: BG
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// AWB statistics B/G color ratio output
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AWB_BG_DEFAULT (0x0)
#define ACAMERA_ISP_METERING_AWB_BG_DATASIZE (12)
#define ACAMERA_ISP_METERING_AWB_BG_OFFSET (0x2434)
#define ACAMERA_ISP_METERING_AWB_BG_MASK (0xfff)

// args: data (12-bit)
static __inline uint16_t acamera_isp_metering_awb_bg_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b2bcL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: SUM
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// AWB output population.  Number of pixels used for AWB statistics
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AWB_SUM_DEFAULT (0x0)
#define ACAMERA_ISP_METERING_AWB_SUM_DATASIZE (32)
#define ACAMERA_ISP_METERING_AWB_SUM_OFFSET (0x2438)
#define ACAMERA_ISP_METERING_AWB_SUM_MASK (0xffffffff)

// args: data (32-bit)
static __inline uint32_t acamera_isp_metering_awb_sum_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1b2c0L);
}
// ------------------------------------------------------------------------------ //
// Register: Nodes Used Horiz
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Number of active zones horizontally for AWB stats
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AWB_NODES_USED_HORIZ_DEFAULT (15)
#define ACAMERA_ISP_METERING_AWB_NODES_USED_HORIZ_DATASIZE (8)
#define ACAMERA_ISP_METERING_AWB_NODES_USED_HORIZ_OFFSET (0x243c)
#define ACAMERA_ISP_METERING_AWB_NODES_USED_HORIZ_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_metering_awb_nodes_used_horiz_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b2c4L);
    system_sw_write_32(base + 0x1b2c4L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_metering_awb_nodes_used_horiz_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1b2c4L) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Nodes Used Vert
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Number of active zones vertically for AWB stats
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AWB_NODES_USED_VERT_DEFAULT (15)
#define ACAMERA_ISP_METERING_AWB_NODES_USED_VERT_DATASIZE (8)
#define ACAMERA_ISP_METERING_AWB_NODES_USED_VERT_OFFSET (0x243c)
#define ACAMERA_ISP_METERING_AWB_NODES_USED_VERT_MASK (0xff00)

// args: data (8-bit)
static __inline void acamera_isp_metering_awb_nodes_used_vert_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b2c4L);
    system_sw_write_32(base + 0x1b2c4L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
}
static __inline uint8_t acamera_isp_metering_awb_nodes_used_vert_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1b2c4L) & 0xff00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: Cr Ref High AWB
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Maximum value of R/G for white region
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AWB_CR_REF_HIGH_AWB_DEFAULT (0xFFF)
#define ACAMERA_ISP_METERING_AWB_CR_REF_HIGH_AWB_DATASIZE (12)
#define ACAMERA_ISP_METERING_AWB_CR_REF_HIGH_AWB_OFFSET (0x2440)
#define ACAMERA_ISP_METERING_AWB_CR_REF_HIGH_AWB_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_metering_awb_cr_ref_high_awb_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b2c8L);
    system_sw_write_32(base + 0x1b2c8L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_metering_awb_cr_ref_high_awb_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b2c8L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Cr Ref Low AWB
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Minimum value of R/G for white region
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AWB_CR_REF_LOW_AWB_DEFAULT (0x000)
#define ACAMERA_ISP_METERING_AWB_CR_REF_LOW_AWB_DATASIZE (12)
#define ACAMERA_ISP_METERING_AWB_CR_REF_LOW_AWB_OFFSET (0x2444)
#define ACAMERA_ISP_METERING_AWB_CR_REF_LOW_AWB_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_metering_awb_cr_ref_low_awb_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b2ccL);
    system_sw_write_32(base + 0x1b2ccL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_metering_awb_cr_ref_low_awb_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b2ccL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Cb Ref High AWB
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Maximum value of B/G for white region
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AWB_CB_REF_HIGH_AWB_DEFAULT (0xFFF)
#define ACAMERA_ISP_METERING_AWB_CB_REF_HIGH_AWB_DATASIZE (12)
#define ACAMERA_ISP_METERING_AWB_CB_REF_HIGH_AWB_OFFSET (0x2448)
#define ACAMERA_ISP_METERING_AWB_CB_REF_HIGH_AWB_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_metering_awb_cb_ref_high_awb_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b2d0L);
    system_sw_write_32(base + 0x1b2d0L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_metering_awb_cb_ref_high_awb_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b2d0L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Cb Ref Low AWB
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Minimum value of B/G for white region
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AWB_CB_REF_LOW_AWB_DEFAULT (0x000)
#define ACAMERA_ISP_METERING_AWB_CB_REF_LOW_AWB_DATASIZE (12)
#define ACAMERA_ISP_METERING_AWB_CB_REF_LOW_AWB_OFFSET (0x244c)
#define ACAMERA_ISP_METERING_AWB_CB_REF_LOW_AWB_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_metering_awb_cb_ref_low_awb_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b2d4L);
    system_sw_write_32(base + 0x1b2d4L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_metering_awb_cb_ref_low_awb_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b2d4L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Zones Weight
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Sets zone weighting for auto white balance. Index is (row,col) where (0,0) is top-left zone
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AWB_ZONES_WEIGHT_DEFAULT (0xF)
#define ACAMERA_ISP_METERING_AWB_ZONES_WEIGHT_DATASIZE (4)
#define ACAMERA_ISP_METERING_AWB_ZONES_WEIGHT_OFFSET (0x2454)
#define ACAMERA_ISP_METERING_AWB_ZONES_WEIGHT_MASK (0xf)

// index (0-1088), args: data (4-bit)
static __inline void acamera_isp_metering_awb_zones_weight_write( uintptr_t base, uint32_t index,uint8_t data) {
    uintptr_t addr = base + 0x1b2dcL + (index & 0xFFFFFFFC);
    uint8_t offset = (index & 3) << 3;
    uint32_t curr = system_sw_read_32(addr);
    system_sw_write_32(addr, ((uint32_t)data << offset) | (curr & ~(0xFF << offset)));
}
static __inline uint8_t acamera_isp_metering_awb_zones_weight_read( uintptr_t base, uint32_t index) {
    uintptr_t addr = base + 0x1b2dcL + (index & 0xFFFFFFFC);
    uint8_t offset = (index & 3) << 3;
    return (uint8_t)(system_sw_read_32(addr) >> offset);
}
// ------------------------------------------------------------------------------ //
// Group: metering af
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Nodes Used Horiz
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Number of active zones horizontally for AF stats
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AF_NODES_USED_HORIZ_DEFAULT (15)
#define ACAMERA_ISP_METERING_AF_NODES_USED_HORIZ_DATASIZE (8)
#define ACAMERA_ISP_METERING_AF_NODES_USED_HORIZ_OFFSET (0x2898)
#define ACAMERA_ISP_METERING_AF_NODES_USED_HORIZ_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_metering_af_nodes_used_horiz_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b720L);
    system_sw_write_32(base + 0x1b720L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_metering_af_nodes_used_horiz_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1b720L) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Nodes Used Vert
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Number of active zones vertically for AF stats
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AF_NODES_USED_VERT_DEFAULT (15)
#define ACAMERA_ISP_METERING_AF_NODES_USED_VERT_DATASIZE (8)
#define ACAMERA_ISP_METERING_AF_NODES_USED_VERT_OFFSET (0x2898)
#define ACAMERA_ISP_METERING_AF_NODES_USED_VERT_MASK (0xff00)

// args: data (8-bit)
static __inline void acamera_isp_metering_af_nodes_used_vert_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b720L);
    system_sw_write_32(base + 0x1b720L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
}
static __inline uint8_t acamera_isp_metering_af_nodes_used_vert_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1b720L) & 0xff00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: metrics
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// The integrated and normalized measure of contrast for AF
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AF_METRICS_DEFAULT (0x0)
#define ACAMERA_ISP_METERING_AF_METRICS_DATASIZE (32)
#define ACAMERA_ISP_METERING_AF_METRICS_OFFSET (0x289c)
#define ACAMERA_ISP_METERING_AF_METRICS_MASK (0xffffffff)

// args: data (32-bit)
static __inline uint32_t acamera_isp_metering_af_metrics_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1b724L);
}
// ------------------------------------------------------------------------------ //
// Register: Active Width
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Active video width for AF module
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AF_ACTIVE_WIDTH_DEFAULT (0x780)
#define ACAMERA_ISP_METERING_AF_ACTIVE_WIDTH_DATASIZE (16)
#define ACAMERA_ISP_METERING_AF_ACTIVE_WIDTH_OFFSET (0x28a0)
#define ACAMERA_ISP_METERING_AF_ACTIVE_WIDTH_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_metering_af_active_width_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b728L);
    system_sw_write_32(base + 0x1b728L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_metering_af_active_width_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b728L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Active Height
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Active video height for AF module
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AF_ACTIVE_HEIGHT_DEFAULT (0x438)
#define ACAMERA_ISP_METERING_AF_ACTIVE_HEIGHT_DATASIZE (16)
#define ACAMERA_ISP_METERING_AF_ACTIVE_HEIGHT_OFFSET (0x28a0)
#define ACAMERA_ISP_METERING_AF_ACTIVE_HEIGHT_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_metering_af_active_height_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b728L);
    system_sw_write_32(base + 0x1b728L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_metering_af_active_height_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1b728L) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: kernel select
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//          Size of Narrow AF Kernel
//          0 =   3x3
//          1 =   7x3
//          2 =  11x3
//          3 =  15x3
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_AF_KERNEL_SELECT_DEFAULT (0)
#define ACAMERA_ISP_METERING_AF_KERNEL_SELECT_DATASIZE (2)
#define ACAMERA_ISP_METERING_AF_KERNEL_SELECT_OFFSET (0x28a4)
#define ACAMERA_ISP_METERING_AF_KERNEL_SELECT_MASK (0x3)

// args: data (2-bit)
static __inline void acamera_isp_metering_af_kernel_select_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b72cL);
    system_sw_write_32(base + 0x1b72cL, (((uint32_t) (data & 0x3)) << 0) | (curr & 0xfffffffc));
}
static __inline uint8_t acamera_isp_metering_af_kernel_select_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1b72cL) & 0x3) >> 0);
}
// ------------------------------------------------------------------------------ //
// Group: metering hist aexp
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: skip x
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Histogram decimation in horizontal direction: 0=every 2nd pixel; 1=every 3rd pixel; 2=every 4th pixel; 3=every 5th pixel; 4=every 8th pixel ; 5+=every 9th pixel
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_HIST_AEXP_SKIP_X_DEFAULT (0)
#define ACAMERA_ISP_METERING_HIST_AEXP_SKIP_X_DATASIZE (3)
#define ACAMERA_ISP_METERING_HIST_AEXP_SKIP_X_OFFSET (0x28a8)
#define ACAMERA_ISP_METERING_HIST_AEXP_SKIP_X_MASK (0x7)

// args: data (3-bit)
static __inline void acamera_isp_metering_hist_aexp_skip_x_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b730L);
    system_sw_write_32(base + 0x1b730L, (((uint32_t) (data & 0x7)) << 0) | (curr & 0xfffffff8));
}
static __inline uint8_t acamera_isp_metering_hist_aexp_skip_x_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1b730L) & 0x7) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: skip y
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Histogram decimation in vertical direction: 0=every pixel; 1=every 2nd pixel; 2=every 3rd pixel; 3=every 4th pixel; 4=every 5th pixel; 5=every 8th pixel ; 6+=every 9th pixel
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_HIST_AEXP_SKIP_Y_DEFAULT (0)
#define ACAMERA_ISP_METERING_HIST_AEXP_SKIP_Y_DATASIZE (3)
#define ACAMERA_ISP_METERING_HIST_AEXP_SKIP_Y_OFFSET (0x28a8)
#define ACAMERA_ISP_METERING_HIST_AEXP_SKIP_Y_MASK (0x70)

// args: data (3-bit)
static __inline void acamera_isp_metering_hist_aexp_skip_y_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b730L);
    system_sw_write_32(base + 0x1b730L, (((uint32_t) (data & 0x7)) << 4) | (curr & 0xffffff8f));
}
static __inline uint8_t acamera_isp_metering_hist_aexp_skip_y_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1b730L) & 0x70) >> 4);
}
// ------------------------------------------------------------------------------ //
// Register: offset x
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0= start from the first column;  1=start from second column
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_HIST_AEXP_OFFSET_X_DEFAULT (0)
#define ACAMERA_ISP_METERING_HIST_AEXP_OFFSET_X_DATASIZE (1)
#define ACAMERA_ISP_METERING_HIST_AEXP_OFFSET_X_OFFSET (0x28a8)
#define ACAMERA_ISP_METERING_HIST_AEXP_OFFSET_X_MASK (0x8)

// args: data (1-bit)
static __inline void acamera_isp_metering_hist_aexp_offset_x_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b730L);
    system_sw_write_32(base + 0x1b730L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
}
static __inline uint8_t acamera_isp_metering_hist_aexp_offset_x_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1b730L) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: offset y
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0= start from the first row; 1= start from second row
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_HIST_AEXP_OFFSET_Y_DEFAULT (0)
#define ACAMERA_ISP_METERING_HIST_AEXP_OFFSET_Y_DATASIZE (1)
#define ACAMERA_ISP_METERING_HIST_AEXP_OFFSET_Y_OFFSET (0x28a8)
#define ACAMERA_ISP_METERING_HIST_AEXP_OFFSET_Y_MASK (0x80)

// args: data (1-bit)
static __inline void acamera_isp_metering_hist_aexp_offset_y_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b730L);
    system_sw_write_32(base + 0x1b730L, (((uint32_t) (data & 0x1)) << 7) | (curr & 0xffffff7f));
}
static __inline uint8_t acamera_isp_metering_hist_aexp_offset_y_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1b730L) & 0x80) >> 7);
}
// ------------------------------------------------------------------------------ //
// Register: scale bottom
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// scale of bottom half of the range: 0=1x ,1=2x, 2=4x, 4=8x, 4=16x
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_HIST_AEXP_SCALE_BOTTOM_DEFAULT (0)
#define ACAMERA_ISP_METERING_HIST_AEXP_SCALE_BOTTOM_DATASIZE (4)
#define ACAMERA_ISP_METERING_HIST_AEXP_SCALE_BOTTOM_OFFSET (0x28ac)
#define ACAMERA_ISP_METERING_HIST_AEXP_SCALE_BOTTOM_MASK (0xf)

// args: data (4-bit)
static __inline void acamera_isp_metering_hist_aexp_scale_bottom_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b734L);
    system_sw_write_32(base + 0x1b734L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
}
static __inline uint8_t acamera_isp_metering_hist_aexp_scale_bottom_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1b734L) & 0xf) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: scale top
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// scale of top half of the range: 0=1x ,1=2x, 2=4x, 4=8x, 4=16x
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_HIST_AEXP_SCALE_TOP_DEFAULT (0)
#define ACAMERA_ISP_METERING_HIST_AEXP_SCALE_TOP_DATASIZE (4)
#define ACAMERA_ISP_METERING_HIST_AEXP_SCALE_TOP_OFFSET (0x28ac)
#define ACAMERA_ISP_METERING_HIST_AEXP_SCALE_TOP_MASK (0xf0)

// args: data (4-bit)
static __inline void acamera_isp_metering_hist_aexp_scale_top_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b734L);
    system_sw_write_32(base + 0x1b734L, (((uint32_t) (data & 0xf)) << 4) | (curr & 0xffffff0f));
}
static __inline uint8_t acamera_isp_metering_hist_aexp_scale_top_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1b734L) & 0xf0) >> 4);
}
// ------------------------------------------------------------------------------ //
// Register: Total Pixels
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Total number of pixels processed (skip x and skip y are taken into account)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_HIST_AEXP_TOTAL_PIXELS_DEFAULT (0)
#define ACAMERA_ISP_METERING_HIST_AEXP_TOTAL_PIXELS_DATASIZE (32)
#define ACAMERA_ISP_METERING_HIST_AEXP_TOTAL_PIXELS_OFFSET (0x28b0)
#define ACAMERA_ISP_METERING_HIST_AEXP_TOTAL_PIXELS_MASK (0xffffffff)

// args: data (32-bit)
static __inline uint32_t acamera_isp_metering_hist_aexp_total_pixels_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1b738L);
}
// ------------------------------------------------------------------------------ //
// Register: Counted Pixels
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Number of pixels accumulated (with nonzero weight) 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_HIST_AEXP_COUNTED_PIXELS_DEFAULT (0)
#define ACAMERA_ISP_METERING_HIST_AEXP_COUNTED_PIXELS_DATASIZE (32)
#define ACAMERA_ISP_METERING_HIST_AEXP_COUNTED_PIXELS_OFFSET (0x28b4)
#define ACAMERA_ISP_METERING_HIST_AEXP_COUNTED_PIXELS_MASK (0xffffffff)

// args: data (32-bit)
static __inline uint32_t acamera_isp_metering_hist_aexp_counted_pixels_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1b73cL);
}
// ------------------------------------------------------------------------------ //
// Register: Plane mode
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Plane separation mode
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_MODE_DEFAULT (0)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_MODE_DATASIZE (3)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_MODE_OFFSET (0x28b8)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_MODE_MASK (0x7)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_MODE_COLLECT_ALL_THE_PLANES_IN_ONE_HISTOGRAM (0)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_MODE_COLLECT_4_BAYER_PLANES_INTO_4_SEPARATE_BANKS (1)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_MODE_RESERVED_2 (2)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_MODE_RESERVED_3 (3)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_MODE_COLLECT_ODD__X_ODD__Y_PLANE_TO_BANK_0_REST_TO_BANK_1 (4)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_MODE_COLLECT_EVEN_X_ODD__Y_PLANE_TO_BANK_0_REST_TO_BANK_1 (5)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_MODE_COLLECT_ODD__X_EVEN_Y_PLANE_TO_BANK_0_REST_TO_BANK_1 (6)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_MODE_COLLECT_EVEN_X_EVEN_Y_PLANE_TO_BANK_0_REST_TO_BANK_1 (7)

// args: data (3-bit)
static __inline void acamera_isp_metering_hist_aexp_plane_mode_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b740L);
    system_sw_write_32(base + 0x1b740L, (((uint32_t) (data & 0x7)) << 0) | (curr & 0xfffffff8));
}
static __inline uint8_t acamera_isp_metering_hist_aexp_plane_mode_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1b740L) & 0x7) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Plane Total 0
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Total pixels processed for plane 0
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_TOTAL_0_DEFAULT (0x0)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_TOTAL_0_DATASIZE (32)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_TOTAL_0_OFFSET (0x28bc)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_TOTAL_0_MASK (0xffffffff)

// args: data (32-bit)
static __inline uint32_t acamera_isp_metering_hist_aexp_plane_total_0_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1b744L);
}
// ------------------------------------------------------------------------------ //
// Register: Plane Total 1
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Total pixels processed for plane 1
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_TOTAL_1_DEFAULT (0x0)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_TOTAL_1_DATASIZE (32)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_TOTAL_1_OFFSET (0x28c0)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_TOTAL_1_MASK (0xffffffff)

// args: data (32-bit)
static __inline uint32_t acamera_isp_metering_hist_aexp_plane_total_1_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1b748L);
}
// ------------------------------------------------------------------------------ //
// Register: Plane Total 2
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Total pixels processed for plane 2
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_TOTAL_2_DEFAULT (0x0)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_TOTAL_2_DATASIZE (32)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_TOTAL_2_OFFSET (0x28c4)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_TOTAL_2_MASK (0xffffffff)

// args: data (32-bit)
static __inline uint32_t acamera_isp_metering_hist_aexp_plane_total_2_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1b74cL);
}
// ------------------------------------------------------------------------------ //
// Register: Plane Total 3
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Total pixels processed for plane 3
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_TOTAL_3_DEFAULT (0x0)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_TOTAL_3_DATASIZE (32)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_TOTAL_3_OFFSET (0x28c8)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_TOTAL_3_MASK (0xffffffff)

// args: data (32-bit)
static __inline uint32_t acamera_isp_metering_hist_aexp_plane_total_3_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1b750L);
}
// ------------------------------------------------------------------------------ //
// Register: Plane Counted 0
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Total pixels accumulated for plane 0
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_COUNTED_0_DEFAULT (0x0)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_COUNTED_0_DATASIZE (32)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_COUNTED_0_OFFSET (0x28cc)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_COUNTED_0_MASK (0xffffffff)

// args: data (32-bit)
static __inline uint32_t acamera_isp_metering_hist_aexp_plane_counted_0_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1b754L);
}
// ------------------------------------------------------------------------------ //
// Register: Plane Counted 1
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Total pixels accumulated for plane 1
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_COUNTED_1_DEFAULT (0x0)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_COUNTED_1_DATASIZE (32)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_COUNTED_1_OFFSET (0x28d0)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_COUNTED_1_MASK (0xffffffff)

// args: data (32-bit)
static __inline uint32_t acamera_isp_metering_hist_aexp_plane_counted_1_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1b758L);
}
// ------------------------------------------------------------------------------ //
// Register: Plane Counted 2
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Total pixels accumulated for plane 2
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_COUNTED_2_DEFAULT (0x0)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_COUNTED_2_DATASIZE (32)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_COUNTED_2_OFFSET (0x28d4)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_COUNTED_2_MASK (0xffffffff)

// args: data (32-bit)
static __inline uint32_t acamera_isp_metering_hist_aexp_plane_counted_2_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1b75cL);
}
// ------------------------------------------------------------------------------ //
// Register: Plane Counted 3
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Total pixels accumulated for plane 3
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_COUNTED_3_DEFAULT (0x0)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_COUNTED_3_DATASIZE (32)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_COUNTED_3_OFFSET (0x28d8)
#define ACAMERA_ISP_METERING_HIST_AEXP_PLANE_COUNTED_3_MASK (0xffffffff)

// args: data (32-bit)
static __inline uint32_t acamera_isp_metering_hist_aexp_plane_counted_3_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1b760L);
}
// ------------------------------------------------------------------------------ //
// Register: Nodes Used Horiz
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Number of active zones horizontally for Histogram
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_HIST_AEXP_NODES_USED_HORIZ_DEFAULT (15)
#define ACAMERA_ISP_METERING_HIST_AEXP_NODES_USED_HORIZ_DATASIZE (8)
#define ACAMERA_ISP_METERING_HIST_AEXP_NODES_USED_HORIZ_OFFSET (0x28dc)
#define ACAMERA_ISP_METERING_HIST_AEXP_NODES_USED_HORIZ_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_metering_hist_aexp_nodes_used_horiz_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b764L);
    system_sw_write_32(base + 0x1b764L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_metering_hist_aexp_nodes_used_horiz_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1b764L) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Nodes Used Vert
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Number of active zones vertically for Histogram
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_HIST_AEXP_NODES_USED_VERT_DEFAULT (15)
#define ACAMERA_ISP_METERING_HIST_AEXP_NODES_USED_VERT_DATASIZE (8)
#define ACAMERA_ISP_METERING_HIST_AEXP_NODES_USED_VERT_OFFSET (0x28dc)
#define ACAMERA_ISP_METERING_HIST_AEXP_NODES_USED_VERT_MASK (0xff00)

// args: data (8-bit)
static __inline void acamera_isp_metering_hist_aexp_nodes_used_vert_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1b764L);
    system_sw_write_32(base + 0x1b764L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
}
static __inline uint8_t acamera_isp_metering_hist_aexp_nodes_used_vert_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1b764L) & 0xff00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: Zones Weight
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Sets zone weighting for Histogram. Index is (row,col) where (0,0) is top-left zone
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_HIST_AEXP_ZONES_WEIGHT_DEFAULT (0xF)
#define ACAMERA_ISP_METERING_HIST_AEXP_ZONES_WEIGHT_DATASIZE (4)
#define ACAMERA_ISP_METERING_HIST_AEXP_ZONES_WEIGHT_OFFSET (0x28e0)
#define ACAMERA_ISP_METERING_HIST_AEXP_ZONES_WEIGHT_MASK (0xf)

// index (0-1088), args: data (4-bit)
static __inline void acamera_isp_metering_hist_aexp_zones_weight_write( uintptr_t base, uint32_t index,uint8_t data) {
    uintptr_t addr = base + 0x1b768L + (index & 0xFFFFFFFC);
    uint8_t offset = (index & 3) << 3;
    uint32_t curr = system_sw_read_32(addr);
    system_sw_write_32(addr, ((uint32_t)data << offset) | (curr & ~(0xFF << offset)));
}
static __inline uint8_t acamera_isp_metering_hist_aexp_zones_weight_read( uintptr_t base, uint32_t index) {
    uintptr_t addr = base + 0x1b768L + (index & 0xFFFFFFFC);
    uint8_t offset = (index & 3) << 3;
    return (uint8_t)(system_sw_read_32(addr) >> offset);
}
// ------------------------------------------------------------------------------ //
// Group: metering ihist
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: skip x
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Histogram decimation in horizontal direction: 0=every 2nd pixel; 1=every 3rd pixel; 2=every 4th pixel; 3=every 5th pixel; 4=every 8th pixel ; 5+=every 9th pixel
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_IHIST_SKIP_X_DEFAULT (0)
#define ACAMERA_ISP_METERING_IHIST_SKIP_X_DATASIZE (3)
#define ACAMERA_ISP_METERING_IHIST_SKIP_X_OFFSET (0x2d24)
#define ACAMERA_ISP_METERING_IHIST_SKIP_X_MASK (0x7)

// args: data (3-bit)
static __inline void acamera_isp_metering_ihist_skip_x_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1bbacL);
    system_sw_write_32(base + 0x1bbacL, (((uint32_t) (data & 0x7)) << 0) | (curr & 0xfffffff8));
}
static __inline uint8_t acamera_isp_metering_ihist_skip_x_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1bbacL) & 0x7) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: skip y
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Histogram decimation in vertical direction: 0=every pixel; 1=every 2nd pixel; 2=every 3rd pixel; 3=every 4th pixel; 4=every 5th pixel; 5=every 8th pixel ; 6+=every 9th pixel
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_IHIST_SKIP_Y_DEFAULT (0)
#define ACAMERA_ISP_METERING_IHIST_SKIP_Y_DATASIZE (3)
#define ACAMERA_ISP_METERING_IHIST_SKIP_Y_OFFSET (0x2d24)
#define ACAMERA_ISP_METERING_IHIST_SKIP_Y_MASK (0x70)

// args: data (3-bit)
static __inline void acamera_isp_metering_ihist_skip_y_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1bbacL);
    system_sw_write_32(base + 0x1bbacL, (((uint32_t) (data & 0x7)) << 4) | (curr & 0xffffff8f));
}
static __inline uint8_t acamera_isp_metering_ihist_skip_y_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1bbacL) & 0x70) >> 4);
}
// ------------------------------------------------------------------------------ //
// Register: offset x
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0= start from the first column;  1=start from second column
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_IHIST_OFFSET_X_DEFAULT (0)
#define ACAMERA_ISP_METERING_IHIST_OFFSET_X_DATASIZE (1)
#define ACAMERA_ISP_METERING_IHIST_OFFSET_X_OFFSET (0x2d24)
#define ACAMERA_ISP_METERING_IHIST_OFFSET_X_MASK (0x8)

// args: data (1-bit)
static __inline void acamera_isp_metering_ihist_offset_x_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1bbacL);
    system_sw_write_32(base + 0x1bbacL, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
}
static __inline uint8_t acamera_isp_metering_ihist_offset_x_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1bbacL) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: offset y
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0= start from the first row; 1= start from second row
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_IHIST_OFFSET_Y_DEFAULT (0)
#define ACAMERA_ISP_METERING_IHIST_OFFSET_Y_DATASIZE (1)
#define ACAMERA_ISP_METERING_IHIST_OFFSET_Y_OFFSET (0x2d24)
#define ACAMERA_ISP_METERING_IHIST_OFFSET_Y_MASK (0x80)

// args: data (1-bit)
static __inline void acamera_isp_metering_ihist_offset_y_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1bbacL);
    system_sw_write_32(base + 0x1bbacL, (((uint32_t) (data & 0x1)) << 7) | (curr & 0xffffff7f));
}
static __inline uint8_t acamera_isp_metering_ihist_offset_y_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1bbacL) & 0x80) >> 7);
}
// ------------------------------------------------------------------------------ //
// Register: scale bottom
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// scale of bottom half of the range: 0=1x ,1=2x, 2=4x, 4=8x, 4=16x
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_IHIST_SCALE_BOTTOM_DEFAULT (0)
#define ACAMERA_ISP_METERING_IHIST_SCALE_BOTTOM_DATASIZE (4)
#define ACAMERA_ISP_METERING_IHIST_SCALE_BOTTOM_OFFSET (0x2d28)
#define ACAMERA_ISP_METERING_IHIST_SCALE_BOTTOM_MASK (0xf)

// args: data (4-bit)
static __inline void acamera_isp_metering_ihist_scale_bottom_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1bbb0L);
    system_sw_write_32(base + 0x1bbb0L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
}
static __inline uint8_t acamera_isp_metering_ihist_scale_bottom_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1bbb0L) & 0xf) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: scale top
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// scale of top half of the range: 0=1x ,1=2x, 2=4x, 4=8x, 4=16x
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_IHIST_SCALE_TOP_DEFAULT (0)
#define ACAMERA_ISP_METERING_IHIST_SCALE_TOP_DATASIZE (4)
#define ACAMERA_ISP_METERING_IHIST_SCALE_TOP_OFFSET (0x2d28)
#define ACAMERA_ISP_METERING_IHIST_SCALE_TOP_MASK (0xf0)

// args: data (4-bit)
static __inline void acamera_isp_metering_ihist_scale_top_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1bbb0L);
    system_sw_write_32(base + 0x1bbb0L, (((uint32_t) (data & 0xf)) << 4) | (curr & 0xffffff0f));
}
static __inline uint8_t acamera_isp_metering_ihist_scale_top_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1bbb0L) & 0xf0) >> 4);
}
// ------------------------------------------------------------------------------ //
// Register: Total Pixels
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Total number of pixels processed (skip x and skip y are taken into account)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_IHIST_TOTAL_PIXELS_DEFAULT (0)
#define ACAMERA_ISP_METERING_IHIST_TOTAL_PIXELS_DATASIZE (32)
#define ACAMERA_ISP_METERING_IHIST_TOTAL_PIXELS_OFFSET (0x2d2c)
#define ACAMERA_ISP_METERING_IHIST_TOTAL_PIXELS_MASK (0xffffffff)

// args: data (32-bit)
static __inline uint32_t acamera_isp_metering_ihist_total_pixels_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1bbb4L);
}
// ------------------------------------------------------------------------------ //
// Register: Counted Pixels
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Number of pixels accumulated (with nonzero weight) 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_IHIST_COUNTED_PIXELS_DEFAULT (0)
#define ACAMERA_ISP_METERING_IHIST_COUNTED_PIXELS_DATASIZE (32)
#define ACAMERA_ISP_METERING_IHIST_COUNTED_PIXELS_OFFSET (0x2d30)
#define ACAMERA_ISP_METERING_IHIST_COUNTED_PIXELS_MASK (0xffffffff)

// args: data (32-bit)
static __inline uint32_t acamera_isp_metering_ihist_counted_pixels_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1bbb8L);
}
// ------------------------------------------------------------------------------ //
// Register: Plane mode
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Plane separation mode
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_IHIST_PLANE_MODE_DEFAULT (0)
#define ACAMERA_ISP_METERING_IHIST_PLANE_MODE_DATASIZE (3)
#define ACAMERA_ISP_METERING_IHIST_PLANE_MODE_OFFSET (0x2d34)
#define ACAMERA_ISP_METERING_IHIST_PLANE_MODE_MASK (0x7)
#define ACAMERA_ISP_METERING_IHIST_PLANE_MODE_COLLECT_ALL_THE_PLANES_IN_ONE_HISTOGRAM (0)
#define ACAMERA_ISP_METERING_IHIST_PLANE_MODE_COLLECT_4_BAYER_PLANES_INTO_4_SEPARATE_BANKS (1)
#define ACAMERA_ISP_METERING_IHIST_PLANE_MODE_RESERVED_2 (2)
#define ACAMERA_ISP_METERING_IHIST_PLANE_MODE_RESERVED_3 (3)
#define ACAMERA_ISP_METERING_IHIST_PLANE_MODE_COLLECT_ODD__X_ODD__Y_PLANE_TO_BANK_0_REST_TO_BANK_1 (4)
#define ACAMERA_ISP_METERING_IHIST_PLANE_MODE_COLLECT_EVEN_X_ODD__Y_PLANE_TO_BANK_0_REST_TO_BANK_1 (5)
#define ACAMERA_ISP_METERING_IHIST_PLANE_MODE_COLLECT_ODD__X_EVEN_Y_PLANE_TO_BANK_0_REST_TO_BANK_1 (6)
#define ACAMERA_ISP_METERING_IHIST_PLANE_MODE_COLLECT_EVEN_X_EVEN_Y_PLANE_TO_BANK_0_REST_TO_BANK_1 (7)

// args: data (3-bit)
static __inline void acamera_isp_metering_ihist_plane_mode_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1bbbcL);
    system_sw_write_32(base + 0x1bbbcL, (((uint32_t) (data & 0x7)) << 0) | (curr & 0xfffffff8));
}
static __inline uint8_t acamera_isp_metering_ihist_plane_mode_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1bbbcL) & 0x7) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Plane Total 0
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Total pixels processed for plane 0
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_IHIST_PLANE_TOTAL_0_DEFAULT (0x0)
#define ACAMERA_ISP_METERING_IHIST_PLANE_TOTAL_0_DATASIZE (32)
#define ACAMERA_ISP_METERING_IHIST_PLANE_TOTAL_0_OFFSET (0x2d38)
#define ACAMERA_ISP_METERING_IHIST_PLANE_TOTAL_0_MASK (0xffffffff)

// args: data (32-bit)
static __inline uint32_t acamera_isp_metering_ihist_plane_total_0_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1bbc0L);
}
// ------------------------------------------------------------------------------ //
// Register: Plane Total 1
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Total pixels processed for plane 1
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_IHIST_PLANE_TOTAL_1_DEFAULT (0x0)
#define ACAMERA_ISP_METERING_IHIST_PLANE_TOTAL_1_DATASIZE (32)
#define ACAMERA_ISP_METERING_IHIST_PLANE_TOTAL_1_OFFSET (0x2d3c)
#define ACAMERA_ISP_METERING_IHIST_PLANE_TOTAL_1_MASK (0xffffffff)

// args: data (32-bit)
static __inline uint32_t acamera_isp_metering_ihist_plane_total_1_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1bbc4L);
}
// ------------------------------------------------------------------------------ //
// Register: Plane Total 2
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Total pixels processed for plane 2
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_IHIST_PLANE_TOTAL_2_DEFAULT (0x0)
#define ACAMERA_ISP_METERING_IHIST_PLANE_TOTAL_2_DATASIZE (32)
#define ACAMERA_ISP_METERING_IHIST_PLANE_TOTAL_2_OFFSET (0x2d40)
#define ACAMERA_ISP_METERING_IHIST_PLANE_TOTAL_2_MASK (0xffffffff)

// args: data (32-bit)
static __inline uint32_t acamera_isp_metering_ihist_plane_total_2_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1bbc8L);
}
// ------------------------------------------------------------------------------ //
// Register: Plane Total 3
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Total pixels processed for plane 3
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_IHIST_PLANE_TOTAL_3_DEFAULT (0x0)
#define ACAMERA_ISP_METERING_IHIST_PLANE_TOTAL_3_DATASIZE (32)
#define ACAMERA_ISP_METERING_IHIST_PLANE_TOTAL_3_OFFSET (0x2d44)
#define ACAMERA_ISP_METERING_IHIST_PLANE_TOTAL_3_MASK (0xffffffff)

// args: data (32-bit)
static __inline uint32_t acamera_isp_metering_ihist_plane_total_3_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1bbccL);
}
// ------------------------------------------------------------------------------ //
// Register: Plane Counted 0
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Total pixels accumulated for plane 0
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_IHIST_PLANE_COUNTED_0_DEFAULT (0x0)
#define ACAMERA_ISP_METERING_IHIST_PLANE_COUNTED_0_DATASIZE (32)
#define ACAMERA_ISP_METERING_IHIST_PLANE_COUNTED_0_OFFSET (0x2d48)
#define ACAMERA_ISP_METERING_IHIST_PLANE_COUNTED_0_MASK (0xffffffff)

// args: data (32-bit)
static __inline uint32_t acamera_isp_metering_ihist_plane_counted_0_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1bbd0L);
}
// ------------------------------------------------------------------------------ //
// Register: Plane Counted 1
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Total pixels accumulated for plane 1
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_IHIST_PLANE_COUNTED_1_DEFAULT (0x0)
#define ACAMERA_ISP_METERING_IHIST_PLANE_COUNTED_1_DATASIZE (32)
#define ACAMERA_ISP_METERING_IHIST_PLANE_COUNTED_1_OFFSET (0x2d4c)
#define ACAMERA_ISP_METERING_IHIST_PLANE_COUNTED_1_MASK (0xffffffff)

// args: data (32-bit)
static __inline uint32_t acamera_isp_metering_ihist_plane_counted_1_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1bbd4L);
}
// ------------------------------------------------------------------------------ //
// Register: Plane Counted 2
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Total pixels accumulated for plane 2
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_IHIST_PLANE_COUNTED_2_DEFAULT (0x0)
#define ACAMERA_ISP_METERING_IHIST_PLANE_COUNTED_2_DATASIZE (32)
#define ACAMERA_ISP_METERING_IHIST_PLANE_COUNTED_2_OFFSET (0x2d50)
#define ACAMERA_ISP_METERING_IHIST_PLANE_COUNTED_2_MASK (0xffffffff)

// args: data (32-bit)
static __inline uint32_t acamera_isp_metering_ihist_plane_counted_2_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1bbd8L);
}
// ------------------------------------------------------------------------------ //
// Register: Plane Counted 3
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Total pixels accumulated for plane 3
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_IHIST_PLANE_COUNTED_3_DEFAULT (0x0)
#define ACAMERA_ISP_METERING_IHIST_PLANE_COUNTED_3_DATASIZE (32)
#define ACAMERA_ISP_METERING_IHIST_PLANE_COUNTED_3_OFFSET (0x2d54)
#define ACAMERA_ISP_METERING_IHIST_PLANE_COUNTED_3_MASK (0xffffffff)

// args: data (32-bit)
static __inline uint32_t acamera_isp_metering_ihist_plane_counted_3_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1bbdcL);
}
// ------------------------------------------------------------------------------ //
// Register: Nodes Used Horiz
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Number of active zones horizontally for Histogram
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_IHIST_NODES_USED_HORIZ_DEFAULT (15)
#define ACAMERA_ISP_METERING_IHIST_NODES_USED_HORIZ_DATASIZE (8)
#define ACAMERA_ISP_METERING_IHIST_NODES_USED_HORIZ_OFFSET (0x2d58)
#define ACAMERA_ISP_METERING_IHIST_NODES_USED_HORIZ_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_metering_ihist_nodes_used_horiz_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1bbe0L);
    system_sw_write_32(base + 0x1bbe0L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_metering_ihist_nodes_used_horiz_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1bbe0L) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Nodes Used Vert
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Number of active zones vertically for Histogram
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_IHIST_NODES_USED_VERT_DEFAULT (15)
#define ACAMERA_ISP_METERING_IHIST_NODES_USED_VERT_DATASIZE (8)
#define ACAMERA_ISP_METERING_IHIST_NODES_USED_VERT_OFFSET (0x2d58)
#define ACAMERA_ISP_METERING_IHIST_NODES_USED_VERT_MASK (0xff00)

// args: data (8-bit)
static __inline void acamera_isp_metering_ihist_nodes_used_vert_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1bbe0L);
    system_sw_write_32(base + 0x1bbe0L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
}
static __inline uint8_t acamera_isp_metering_ihist_nodes_used_vert_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1bbe0L) & 0xff00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: Zones Weight
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Sets zone weighting for Histogram. Index is (row,col) where (0,0) is top-left zone
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_METERING_IHIST_ZONES_WEIGHT_DEFAULT (0xF)
#define ACAMERA_ISP_METERING_IHIST_ZONES_WEIGHT_DATASIZE (4)
#define ACAMERA_ISP_METERING_IHIST_ZONES_WEIGHT_OFFSET (0x2d5c)
#define ACAMERA_ISP_METERING_IHIST_ZONES_WEIGHT_MASK (0xf)

// index (0-1088), args: data (4-bit)
static __inline void acamera_isp_metering_ihist_zones_weight_write( uintptr_t base, uint32_t index,uint8_t data) {
    uintptr_t addr = base + 0x1bbe4L + (index & 0xFFFFFFFC);
    uint8_t offset = (index & 3) << 3;
    uint32_t curr = system_sw_read_32(addr);
    system_sw_write_32(addr, ((uint32_t)data << offset) | (curr & ~(0xFF << offset)));
}
static __inline uint8_t acamera_isp_metering_ihist_zones_weight_read( uintptr_t base, uint32_t index) {
    uintptr_t addr = base + 0x1bbe4L + (index & 0xFFFFFFFC);
    uint8_t offset = (index & 3) << 3;
    return (uint8_t)(system_sw_read_32(addr) >> offset);
}
// ------------------------------------------------------------------------------ //
// Group: fr crop
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Crop for full resolution output
//      
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Enable crop
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Crop enable: 0=off 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CROP_ENABLE_CROP_DEFAULT (0)
#define ACAMERA_ISP_FR_CROP_ENABLE_CROP_DATASIZE (1)
#define ACAMERA_ISP_FR_CROP_ENABLE_CROP_OFFSET (0x31a0)
#define ACAMERA_ISP_FR_CROP_ENABLE_CROP_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_fr_crop_enable_crop_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c028L);
    system_sw_write_32(base + 0x1c028L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_fr_crop_enable_crop_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c028L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: start x
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Horizontal offset from left side of image in pixels for output crop window
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CROP_START_X_DEFAULT (0x0000)
#define ACAMERA_ISP_FR_CROP_START_X_DATASIZE (16)
#define ACAMERA_ISP_FR_CROP_START_X_OFFSET (0x31a4)
#define ACAMERA_ISP_FR_CROP_START_X_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_fr_crop_start_x_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c02cL);
    system_sw_write_32(base + 0x1c02cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_fr_crop_start_x_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c02cL) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: start y
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Vertical offset from top of image in lines for output crop window
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CROP_START_Y_DEFAULT (0x0000)
#define ACAMERA_ISP_FR_CROP_START_Y_DATASIZE (16)
#define ACAMERA_ISP_FR_CROP_START_Y_OFFSET (0x31a8)
#define ACAMERA_ISP_FR_CROP_START_Y_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_fr_crop_start_y_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c030L);
    system_sw_write_32(base + 0x1c030L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_fr_crop_start_y_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c030L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: size x
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// width of output crop window
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CROP_SIZE_X_DEFAULT (0xffff)
#define ACAMERA_ISP_FR_CROP_SIZE_X_DATASIZE (16)
#define ACAMERA_ISP_FR_CROP_SIZE_X_OFFSET (0x31ac)
#define ACAMERA_ISP_FR_CROP_SIZE_X_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_fr_crop_size_x_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c034L);
    system_sw_write_32(base + 0x1c034L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_fr_crop_size_x_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c034L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: size y
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// height of output crop window
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CROP_SIZE_Y_DEFAULT (0xffff)
#define ACAMERA_ISP_FR_CROP_SIZE_Y_DATASIZE (16)
#define ACAMERA_ISP_FR_CROP_SIZE_Y_OFFSET (0x31b0)
#define ACAMERA_ISP_FR_CROP_SIZE_Y_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_fr_crop_size_y_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c038L);
    system_sw_write_32(base + 0x1c038L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_fr_crop_size_y_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c038L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Group: fr scaler
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: IRQSTAT
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Downscaler status
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SCALER_IRQSTAT_DEFAULT (0x00)
#define ACAMERA_ISP_FR_SCALER_IRQSTAT_DATASIZE (8)
#define ACAMERA_ISP_FR_SCALER_IRQSTAT_OFFSET (0x31b4)
#define ACAMERA_ISP_FR_SCALER_IRQSTAT_MASK (0xff)

// args: data (8-bit)
static __inline uint8_t acamera_isp_fr_scaler_irqstat_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c03cL) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Timeout IRQ
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//             0 : No timeout 
//             1 : Timeout on frame done 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SCALER_TIMEOUT_IRQ_DEFAULT (0x0)
#define ACAMERA_ISP_FR_SCALER_TIMEOUT_IRQ_DATASIZE (1)
#define ACAMERA_ISP_FR_SCALER_TIMEOUT_IRQ_OFFSET (0x31b4)
#define ACAMERA_ISP_FR_SCALER_TIMEOUT_IRQ_MASK (0x8)

// args: data (1-bit)
static __inline void acamera_isp_fr_scaler_timeout_irq_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c03cL);
    system_sw_write_32(base + 0x1c03cL, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
}
static __inline uint8_t acamera_isp_fr_scaler_timeout_irq_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c03cL) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: Underflow IRQ
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//             0 : No underflow 
//             1 : FIFO underflow has occurred 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SCALER_UNDERFLOW_IRQ_DEFAULT (0x0)
#define ACAMERA_ISP_FR_SCALER_UNDERFLOW_IRQ_DATASIZE (1)
#define ACAMERA_ISP_FR_SCALER_UNDERFLOW_IRQ_OFFSET (0x31b4)
#define ACAMERA_ISP_FR_SCALER_UNDERFLOW_IRQ_MASK (0x4)

// args: data (1-bit)
static __inline void acamera_isp_fr_scaler_underflow_irq_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c03cL);
    system_sw_write_32(base + 0x1c03cL, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
}
static __inline uint8_t acamera_isp_fr_scaler_underflow_irq_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c03cL) & 0x4) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: Overflow IRQ
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//             0 : No overflow 
//             1 : FIFO overflow has occurred
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SCALER_OVERFLOW_IRQ_DEFAULT (0x0)
#define ACAMERA_ISP_FR_SCALER_OVERFLOW_IRQ_DATASIZE (1)
#define ACAMERA_ISP_FR_SCALER_OVERFLOW_IRQ_OFFSET (0x31b4)
#define ACAMERA_ISP_FR_SCALER_OVERFLOW_IRQ_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_fr_scaler_overflow_irq_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c03cL);
    system_sw_write_32(base + 0x1c03cL, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_fr_scaler_overflow_irq_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c03cL) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Clear Alarms
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Scaler control
//        IRQ CLR bit 
//         0 : In-active 
//         1 : Clear-off IRQ status to 0 
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SCALER_CLEAR_ALARMS_DEFAULT (0)
#define ACAMERA_ISP_FR_SCALER_CLEAR_ALARMS_DATASIZE (1)
#define ACAMERA_ISP_FR_SCALER_CLEAR_ALARMS_OFFSET (0x31b8)
#define ACAMERA_ISP_FR_SCALER_CLEAR_ALARMS_MASK (0x8)

// args: data (1-bit)
static __inline void acamera_isp_fr_scaler_clear_alarms_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c040L);
    system_sw_write_32(base + 0x1c040L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
}
static __inline uint8_t acamera_isp_fr_scaler_clear_alarms_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c040L) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: Timeout Enable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        0 : Timeout disabled.  
//        1 : Timeout enabled.  Automatic frame reset if frame has not completed after anticipated time.
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SCALER_TIMEOUT_ENABLE_DEFAULT (1)
#define ACAMERA_ISP_FR_SCALER_TIMEOUT_ENABLE_DATASIZE (1)
#define ACAMERA_ISP_FR_SCALER_TIMEOUT_ENABLE_OFFSET (0x31b8)
#define ACAMERA_ISP_FR_SCALER_TIMEOUT_ENABLE_MASK (0x10)

// args: data (1-bit)
static __inline void acamera_isp_fr_scaler_timeout_enable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c040L);
    system_sw_write_32(base + 0x1c040L, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
}
static __inline uint8_t acamera_isp_fr_scaler_timeout_enable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c040L) & 0x10) >> 4);
}
// ------------------------------------------------------------------------------ //
// Register: Field in toggle sel
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        0 : Input Field Type = pulse.  
//        1 : Input Field Type = toggle.
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SCALER_FIELD_IN_TOGGLE_SEL_DEFAULT (0)
#define ACAMERA_ISP_FR_SCALER_FIELD_IN_TOGGLE_SEL_DATASIZE (1)
#define ACAMERA_ISP_FR_SCALER_FIELD_IN_TOGGLE_SEL_OFFSET (0x31b8)
#define ACAMERA_ISP_FR_SCALER_FIELD_IN_TOGGLE_SEL_MASK (0x20)

// args: data (1-bit)
static __inline void acamera_isp_fr_scaler_field_in_toggle_sel_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c040L);
    system_sw_write_32(base + 0x1c040L, (((uint32_t) (data & 0x1)) << 5) | (curr & 0xffffffdf));
}
static __inline uint8_t acamera_isp_fr_scaler_field_in_toggle_sel_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c040L) & 0x20) >> 5);
}
// ------------------------------------------------------------------------------ //
// Register: WIDTH
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Input frame width in pixels
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SCALER_WIDTH_DEFAULT (0x780)
#define ACAMERA_ISP_FR_SCALER_WIDTH_DATASIZE (16)
#define ACAMERA_ISP_FR_SCALER_WIDTH_OFFSET (0x31bc)
#define ACAMERA_ISP_FR_SCALER_WIDTH_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_fr_scaler_width_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c044L);
    system_sw_write_32(base + 0x1c044L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_fr_scaler_width_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c044L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: HEIGHT
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Input frame height in lines
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SCALER_HEIGHT_DEFAULT (0x438)
#define ACAMERA_ISP_FR_SCALER_HEIGHT_DATASIZE (16)
#define ACAMERA_ISP_FR_SCALER_HEIGHT_OFFSET (0x31c0)
#define ACAMERA_ISP_FR_SCALER_HEIGHT_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_fr_scaler_height_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c048L);
    system_sw_write_32(base + 0x1c048L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_fr_scaler_height_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c048L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: OWIDTH
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Output frame width in pixels
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SCALER_OWIDTH_DEFAULT (0x500)
#define ACAMERA_ISP_FR_SCALER_OWIDTH_DATASIZE (13)
#define ACAMERA_ISP_FR_SCALER_OWIDTH_OFFSET (0x31c4)
#define ACAMERA_ISP_FR_SCALER_OWIDTH_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_fr_scaler_owidth_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c04cL);
    system_sw_write_32(base + 0x1c04cL, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_fr_scaler_owidth_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c04cL) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: OHEIGHT
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Output frame height in lines
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SCALER_OHEIGHT_DEFAULT (0x2D0)
#define ACAMERA_ISP_FR_SCALER_OHEIGHT_DATASIZE (16)
#define ACAMERA_ISP_FR_SCALER_OHEIGHT_OFFSET (0x31c8)
#define ACAMERA_ISP_FR_SCALER_OHEIGHT_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_fr_scaler_oheight_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c050L);
    system_sw_write_32(base + 0x1c050L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_fr_scaler_oheight_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c050L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: HFILT_TINC
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Horizontal scaling factor equal to the 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SCALER_HFILT_TINC_DEFAULT (0x180000)
#define ACAMERA_ISP_FR_SCALER_HFILT_TINC_DATASIZE (24)
#define ACAMERA_ISP_FR_SCALER_HFILT_TINC_OFFSET (0x31cc)
#define ACAMERA_ISP_FR_SCALER_HFILT_TINC_MASK (0xffffff)

// args: data (24-bit)
static __inline void acamera_isp_fr_scaler_hfilt_tinc_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c054L);
    system_sw_write_32(base + 0x1c054L, (((uint32_t) (data & 0xffffff)) << 0) | (curr & 0xff000000));
}
static __inline uint32_t acamera_isp_fr_scaler_hfilt_tinc_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x1c054L) & 0xffffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: HFILT_COEFSET
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        HFILT Coeff. control.  
//        HFILT_COEFSET[3:0] - Selects horizontal Coef set for scaler.
//            0000 : use set 0
//            0001 : use set 1
//            ...... 
//            1111 : use set 15
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SCALER_HFILT_COEFSET_DEFAULT (0x00)
#define ACAMERA_ISP_FR_SCALER_HFILT_COEFSET_DATASIZE (4)
#define ACAMERA_ISP_FR_SCALER_HFILT_COEFSET_OFFSET (0x31d0)
#define ACAMERA_ISP_FR_SCALER_HFILT_COEFSET_MASK (0xf)

// args: data (4-bit)
static __inline void acamera_isp_fr_scaler_hfilt_coefset_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c058L);
    system_sw_write_32(base + 0x1c058L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
}
static __inline uint8_t acamera_isp_fr_scaler_hfilt_coefset_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c058L) & 0xf) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: VFILT_TINC
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// VFILT TINC
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SCALER_VFILT_TINC_DEFAULT (0x180000)
#define ACAMERA_ISP_FR_SCALER_VFILT_TINC_DATASIZE (24)
#define ACAMERA_ISP_FR_SCALER_VFILT_TINC_OFFSET (0x31d4)
#define ACAMERA_ISP_FR_SCALER_VFILT_TINC_MASK (0xffffff)

// args: data (24-bit)
static __inline void acamera_isp_fr_scaler_vfilt_tinc_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c05cL);
    system_sw_write_32(base + 0x1c05cL, (((uint32_t) (data & 0xffffff)) << 0) | (curr & 0xff000000));
}
static __inline uint32_t acamera_isp_fr_scaler_vfilt_tinc_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x1c05cL) & 0xffffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: VFILT_COEFSET
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        VFILT Coeff. control
//        FILT_COEFSET[3:0] - Selects vertical Coef set for scaler
//            0000 : use set 0
//            0001 : use set 1
//            ...... 
//            1111 : use set 15
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SCALER_VFILT_COEFSET_DEFAULT (0x00)
#define ACAMERA_ISP_FR_SCALER_VFILT_COEFSET_DATASIZE (4)
#define ACAMERA_ISP_FR_SCALER_VFILT_COEFSET_OFFSET (0x31d8)
#define ACAMERA_ISP_FR_SCALER_VFILT_COEFSET_MASK (0xf)

// args: data (4-bit)
static __inline void acamera_isp_fr_scaler_vfilt_coefset_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c060L);
    system_sw_write_32(base + 0x1c060L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
}
static __inline uint8_t acamera_isp_fr_scaler_vfilt_coefset_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c060L) & 0xf) >> 0);
}
// ------------------------------------------------------------------------------ //
// Group: fr gamma rgb
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Gamma correction
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Enable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Gamma enable: 0=off 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_GAMMA_RGB_ENABLE_DEFAULT (1)
#define ACAMERA_ISP_FR_GAMMA_RGB_ENABLE_DATASIZE (1)
#define ACAMERA_ISP_FR_GAMMA_RGB_ENABLE_OFFSET (0x31dc)
#define ACAMERA_ISP_FR_GAMMA_RGB_ENABLE_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_fr_gamma_rgb_enable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c064L);
    system_sw_write_32(base + 0x1c064L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_fr_gamma_rgb_enable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c064L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: gain_r
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// gain applied to the R chanel in 4.8 format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_GAMMA_RGB_GAIN_R_DEFAULT (0x100)
#define ACAMERA_ISP_FR_GAMMA_RGB_GAIN_R_DATASIZE (12)
#define ACAMERA_ISP_FR_GAMMA_RGB_GAIN_R_OFFSET (0x31e0)
#define ACAMERA_ISP_FR_GAMMA_RGB_GAIN_R_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_fr_gamma_rgb_gain_r_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c068L);
    system_sw_write_32(base + 0x1c068L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_fr_gamma_rgb_gain_r_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c068L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: gain_g
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// gain applied to the G chanel in 4.8 format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_GAMMA_RGB_GAIN_G_DEFAULT (0x100)
#define ACAMERA_ISP_FR_GAMMA_RGB_GAIN_G_DATASIZE (12)
#define ACAMERA_ISP_FR_GAMMA_RGB_GAIN_G_OFFSET (0x31e0)
#define ACAMERA_ISP_FR_GAMMA_RGB_GAIN_G_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_fr_gamma_rgb_gain_g_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c068L);
    system_sw_write_32(base + 0x1c068L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_fr_gamma_rgb_gain_g_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c068L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: gain_b
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// gain applied to the B chanel in 4.8 format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_GAMMA_RGB_GAIN_B_DEFAULT (0x100)
#define ACAMERA_ISP_FR_GAMMA_RGB_GAIN_B_DATASIZE (12)
#define ACAMERA_ISP_FR_GAMMA_RGB_GAIN_B_OFFSET (0x31e4)
#define ACAMERA_ISP_FR_GAMMA_RGB_GAIN_B_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_fr_gamma_rgb_gain_b_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c06cL);
    system_sw_write_32(base + 0x1c06cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_fr_gamma_rgb_gain_b_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c06cL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: offset_r
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Offset subtracted from the R chanel 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_GAMMA_RGB_OFFSET_R_DEFAULT (0)
#define ACAMERA_ISP_FR_GAMMA_RGB_OFFSET_R_DATASIZE (12)
#define ACAMERA_ISP_FR_GAMMA_RGB_OFFSET_R_OFFSET (0x31e8)
#define ACAMERA_ISP_FR_GAMMA_RGB_OFFSET_R_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_fr_gamma_rgb_offset_r_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c070L);
    system_sw_write_32(base + 0x1c070L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_fr_gamma_rgb_offset_r_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c070L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: offset_g
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Offset subtracted from the G chanel 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_GAMMA_RGB_OFFSET_G_DEFAULT (0)
#define ACAMERA_ISP_FR_GAMMA_RGB_OFFSET_G_DATASIZE (12)
#define ACAMERA_ISP_FR_GAMMA_RGB_OFFSET_G_OFFSET (0x31e8)
#define ACAMERA_ISP_FR_GAMMA_RGB_OFFSET_G_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_fr_gamma_rgb_offset_g_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c070L);
    system_sw_write_32(base + 0x1c070L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_fr_gamma_rgb_offset_g_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c070L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: offset_b
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Offset subtracted from the B chanel 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_GAMMA_RGB_OFFSET_B_DEFAULT (0)
#define ACAMERA_ISP_FR_GAMMA_RGB_OFFSET_B_DATASIZE (12)
#define ACAMERA_ISP_FR_GAMMA_RGB_OFFSET_B_OFFSET (0x31ec)
#define ACAMERA_ISP_FR_GAMMA_RGB_OFFSET_B_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_fr_gamma_rgb_offset_b_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c074L);
    system_sw_write_32(base + 0x1c074L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_fr_gamma_rgb_offset_b_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c074L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Group: fr sharpen
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Sharpen
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Enable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Sharpening enable: 0=off, 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SHARPEN_ENABLE_DEFAULT (0)
#define ACAMERA_ISP_FR_SHARPEN_ENABLE_DATASIZE (1)
#define ACAMERA_ISP_FR_SHARPEN_ENABLE_OFFSET (0x31f0)
#define ACAMERA_ISP_FR_SHARPEN_ENABLE_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_fr_sharpen_enable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c078L);
    system_sw_write_32(base + 0x1c078L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_fr_sharpen_enable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c078L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Strength
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Controls strength of sharpening effect. u5.4
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SHARPEN_STRENGTH_DEFAULT (0x10)
#define ACAMERA_ISP_FR_SHARPEN_STRENGTH_DATASIZE (9)
#define ACAMERA_ISP_FR_SHARPEN_STRENGTH_OFFSET (0x31f4)
#define ACAMERA_ISP_FR_SHARPEN_STRENGTH_MASK (0x1ff)

// args: data (9-bit)
static __inline void acamera_isp_fr_sharpen_strength_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c07cL);
    system_sw_write_32(base + 0x1c07cL, (((uint32_t) (data & 0x1ff)) << 0) | (curr & 0xfffffe00));
}
static __inline uint16_t acamera_isp_fr_sharpen_strength_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c07cL) & 0x1ff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Control R
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SHARPEN_CONTROL_R_DEFAULT (0x4C)
#define ACAMERA_ISP_FR_SHARPEN_CONTROL_R_DATASIZE (8)
#define ACAMERA_ISP_FR_SHARPEN_CONTROL_R_OFFSET (0x31f8)
#define ACAMERA_ISP_FR_SHARPEN_CONTROL_R_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_fr_sharpen_control_r_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c080L);
    system_sw_write_32(base + 0x1c080L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_fr_sharpen_control_r_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c080L) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
//  Luma transform red coefficient. u0.8 
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Control B
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SHARPEN_CONTROL_B_DEFAULT (0x1E)
#define ACAMERA_ISP_FR_SHARPEN_CONTROL_B_DATASIZE (8)
#define ACAMERA_ISP_FR_SHARPEN_CONTROL_B_OFFSET (0x31f8)
#define ACAMERA_ISP_FR_SHARPEN_CONTROL_B_MASK (0xff00)

// args: data (8-bit)
static __inline void acamera_isp_fr_sharpen_control_b_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c080L);
    system_sw_write_32(base + 0x1c080L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
}
static __inline uint8_t acamera_isp_fr_sharpen_control_b_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c080L) & 0xff00) >> 8);
}
// ------------------------------------------------------------------------------ //
//  Luma transform blue coefficient. u0.8 
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Alpha Undershoot
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Alpha blending of undershoot and overshoot u0.7, 0 = only unsershoot, 255 = only overshoot
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SHARPEN_ALPHA_UNDERSHOOT_DEFAULT (0x13)
#define ACAMERA_ISP_FR_SHARPEN_ALPHA_UNDERSHOOT_DATASIZE (8)
#define ACAMERA_ISP_FR_SHARPEN_ALPHA_UNDERSHOOT_OFFSET (0x31f8)
#define ACAMERA_ISP_FR_SHARPEN_ALPHA_UNDERSHOOT_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_fr_sharpen_alpha_undershoot_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c080L);
    system_sw_write_32(base + 0x1c080L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_fr_sharpen_alpha_undershoot_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c080L) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Luma Thresh Low
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Luma threshold below this value, no sharpening will be applied. 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SHARPEN_LUMA_THRESH_LOW_DEFAULT (0x000)
#define ACAMERA_ISP_FR_SHARPEN_LUMA_THRESH_LOW_DATASIZE (10)
#define ACAMERA_ISP_FR_SHARPEN_LUMA_THRESH_LOW_OFFSET (0x31fc)
#define ACAMERA_ISP_FR_SHARPEN_LUMA_THRESH_LOW_MASK (0x3ff)

// args: data (10-bit)
static __inline void acamera_isp_fr_sharpen_luma_thresh_low_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c084L);
    system_sw_write_32(base + 0x1c084L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
}
static __inline uint16_t acamera_isp_fr_sharpen_luma_thresh_low_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c084L) & 0x3ff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Luma Offset Low
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Luma offset (min value) of thre region of less than Luma Thresh Low.  
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SHARPEN_LUMA_OFFSET_LOW_DEFAULT (0x000)
#define ACAMERA_ISP_FR_SHARPEN_LUMA_OFFSET_LOW_DATASIZE (8)
#define ACAMERA_ISP_FR_SHARPEN_LUMA_OFFSET_LOW_OFFSET (0x31fc)
#define ACAMERA_ISP_FR_SHARPEN_LUMA_OFFSET_LOW_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_fr_sharpen_luma_offset_low_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c084L);
    system_sw_write_32(base + 0x1c084L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_fr_sharpen_luma_offset_low_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c084L) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Luma Slope Low
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Luma linear threshold slope at dark luminance region 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SHARPEN_LUMA_SLOPE_LOW_DEFAULT (0x03FC)
#define ACAMERA_ISP_FR_SHARPEN_LUMA_SLOPE_LOW_DATASIZE (16)
#define ACAMERA_ISP_FR_SHARPEN_LUMA_SLOPE_LOW_OFFSET (0x3200)
#define ACAMERA_ISP_FR_SHARPEN_LUMA_SLOPE_LOW_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_fr_sharpen_luma_slope_low_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c088L);
    system_sw_write_32(base + 0x1c088L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_fr_sharpen_luma_slope_low_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c088L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Luma Thresh High
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Luma threshold above this value, sharpening level will be dicreased. 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SHARPEN_LUMA_THRESH_HIGH_DEFAULT (0x332)
#define ACAMERA_ISP_FR_SHARPEN_LUMA_THRESH_HIGH_DATASIZE (10)
#define ACAMERA_ISP_FR_SHARPEN_LUMA_THRESH_HIGH_OFFSET (0x3200)
#define ACAMERA_ISP_FR_SHARPEN_LUMA_THRESH_HIGH_MASK (0x3ff0000)

// args: data (10-bit)
static __inline void acamera_isp_fr_sharpen_luma_thresh_high_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c088L);
    system_sw_write_32(base + 0x1c088L, (((uint32_t) (data & 0x3ff)) << 16) | (curr & 0xfc00ffff));
}
static __inline uint16_t acamera_isp_fr_sharpen_luma_thresh_high_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c088L) & 0x3ff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Luma Offset High
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Luma offset (min value) of thre region of more than Luma Thresh High.  
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SHARPEN_LUMA_OFFSET_HIGH_DEFAULT (0x000)
#define ACAMERA_ISP_FR_SHARPEN_LUMA_OFFSET_HIGH_DATASIZE (8)
#define ACAMERA_ISP_FR_SHARPEN_LUMA_OFFSET_HIGH_OFFSET (0x3204)
#define ACAMERA_ISP_FR_SHARPEN_LUMA_OFFSET_HIGH_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_fr_sharpen_luma_offset_high_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c08cL);
    system_sw_write_32(base + 0x1c08cL, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_fr_sharpen_luma_offset_high_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c08cL) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Luma Slope High
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Luma linear threshold slope at bright luminance region 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SHARPEN_LUMA_SLOPE_HIGH_DEFAULT (0x06A4)
#define ACAMERA_ISP_FR_SHARPEN_LUMA_SLOPE_HIGH_DATASIZE (16)
#define ACAMERA_ISP_FR_SHARPEN_LUMA_SLOPE_HIGH_OFFSET (0x3204)
#define ACAMERA_ISP_FR_SHARPEN_LUMA_SLOPE_HIGH_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_fr_sharpen_luma_slope_high_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c08cL);
    system_sw_write_32(base + 0x1c08cL, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_fr_sharpen_luma_slope_high_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c08cL) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Clip Str Max
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clips sharpening mask of max value. This will control overshoot. U0.14. (0 ~ 16383) 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SHARPEN_CLIP_STR_MAX_DEFAULT (0x3FFF)
#define ACAMERA_ISP_FR_SHARPEN_CLIP_STR_MAX_DATASIZE (14)
#define ACAMERA_ISP_FR_SHARPEN_CLIP_STR_MAX_OFFSET (0x3208)
#define ACAMERA_ISP_FR_SHARPEN_CLIP_STR_MAX_MASK (0x3fff)

// args: data (14-bit)
static __inline void acamera_isp_fr_sharpen_clip_str_max_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c090L);
    system_sw_write_32(base + 0x1c090L, (((uint32_t) (data & 0x3fff)) << 0) | (curr & 0xffffc000));
}
static __inline uint16_t acamera_isp_fr_sharpen_clip_str_max_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c090L) & 0x3fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Clip Str Min
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clips sharpening mask of min value. This will control undershoot. U0.14. It is used as negative value. (0 ~ -16383)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SHARPEN_CLIP_STR_MIN_DEFAULT (0x00CD)
#define ACAMERA_ISP_FR_SHARPEN_CLIP_STR_MIN_DATASIZE (14)
#define ACAMERA_ISP_FR_SHARPEN_CLIP_STR_MIN_OFFSET (0x3208)
#define ACAMERA_ISP_FR_SHARPEN_CLIP_STR_MIN_MASK (0x3fff0000)

// args: data (14-bit)
static __inline void acamera_isp_fr_sharpen_clip_str_min_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c090L);
    system_sw_write_32(base + 0x1c090L, (((uint32_t) (data & 0x3fff)) << 16) | (curr & 0xc000ffff));
}
static __inline uint16_t acamera_isp_fr_sharpen_clip_str_min_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c090L) & 0x3fff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Debug
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  To support different debug output. 0 = normal operation, 1 = luma, 2 = sharpening mask 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_SHARPEN_DEBUG_DEFAULT (0)
#define ACAMERA_ISP_FR_SHARPEN_DEBUG_DATASIZE (4)
#define ACAMERA_ISP_FR_SHARPEN_DEBUG_OFFSET (0x320c)
#define ACAMERA_ISP_FR_SHARPEN_DEBUG_MASK (0xf)

// args: data (4-bit)
static __inline void acamera_isp_fr_sharpen_debug_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c094L);
    system_sw_write_32(base + 0x1c094L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
}
static __inline uint8_t acamera_isp_fr_sharpen_debug_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c094L) & 0xf) >> 0);
}
// ------------------------------------------------------------------------------ //
// Group: fr cs conv
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Conversion of RGB to YUV data using a 3x3 color matrix plus offsets
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Enable matrix
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Color matrix enable: 0=off 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CS_CONV_ENABLE_MATRIX_DEFAULT (0)
#define ACAMERA_ISP_FR_CS_CONV_ENABLE_MATRIX_DATASIZE (1)
#define ACAMERA_ISP_FR_CS_CONV_ENABLE_MATRIX_OFFSET (0x3210)
#define ACAMERA_ISP_FR_CS_CONV_ENABLE_MATRIX_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_fr_cs_conv_enable_matrix_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c098L);
    system_sw_write_32(base + 0x1c098L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_fr_cs_conv_enable_matrix_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c098L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Enable filter
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Filter enable: 0=off 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CS_CONV_ENABLE_FILTER_DEFAULT (0)
#define ACAMERA_ISP_FR_CS_CONV_ENABLE_FILTER_DATASIZE (1)
#define ACAMERA_ISP_FR_CS_CONV_ENABLE_FILTER_OFFSET (0x3210)
#define ACAMERA_ISP_FR_CS_CONV_ENABLE_FILTER_MASK (0x2)

// args: data (1-bit)
static __inline void acamera_isp_fr_cs_conv_enable_filter_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c098L);
    system_sw_write_32(base + 0x1c098L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
}
static __inline uint8_t acamera_isp_fr_cs_conv_enable_filter_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c098L) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: Enable horizontal downsample
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Horizontal Downsampling Enable: 0=off 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CS_CONV_ENABLE_HORIZONTAL_DOWNSAMPLE_DEFAULT (0)
#define ACAMERA_ISP_FR_CS_CONV_ENABLE_HORIZONTAL_DOWNSAMPLE_DATASIZE (1)
#define ACAMERA_ISP_FR_CS_CONV_ENABLE_HORIZONTAL_DOWNSAMPLE_OFFSET (0x3210)
#define ACAMERA_ISP_FR_CS_CONV_ENABLE_HORIZONTAL_DOWNSAMPLE_MASK (0x4)

// args: data (1-bit)
static __inline void acamera_isp_fr_cs_conv_enable_horizontal_downsample_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c098L);
    system_sw_write_32(base + 0x1c098L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
}
static __inline uint8_t acamera_isp_fr_cs_conv_enable_horizontal_downsample_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c098L) & 0x4) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: Enable vertical downsample
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Vertical Downsampling Enable: 0=off 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CS_CONV_ENABLE_VERTICAL_DOWNSAMPLE_DEFAULT (0)
#define ACAMERA_ISP_FR_CS_CONV_ENABLE_VERTICAL_DOWNSAMPLE_DATASIZE (1)
#define ACAMERA_ISP_FR_CS_CONV_ENABLE_VERTICAL_DOWNSAMPLE_OFFSET (0x3210)
#define ACAMERA_ISP_FR_CS_CONV_ENABLE_VERTICAL_DOWNSAMPLE_MASK (0x8)

// args: data (1-bit)
static __inline void acamera_isp_fr_cs_conv_enable_vertical_downsample_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c098L);
    system_sw_write_32(base + 0x1c098L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
}
static __inline uint8_t acamera_isp_fr_cs_conv_enable_vertical_downsample_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c098L) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft 11
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for R-Y multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CS_CONV_COEFFT_11_DEFAULT (0x002f)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_11_DATASIZE (16)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_11_OFFSET (0x3214)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_11_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_fr_cs_conv_coefft_11_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c09cL);
    system_sw_write_32(base + 0x1c09cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_fr_cs_conv_coefft_11_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c09cL) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft 12
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for G-Y multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CS_CONV_COEFFT_12_DEFAULT (0x009d)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_12_DATASIZE (16)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_12_OFFSET (0x3218)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_12_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_fr_cs_conv_coefft_12_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0a0L);
    system_sw_write_32(base + 0x1c0a0L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_fr_cs_conv_coefft_12_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c0a0L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft 13
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for B-Y multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CS_CONV_COEFFT_13_DEFAULT (0x0010)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_13_DATASIZE (16)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_13_OFFSET (0x321c)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_13_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_fr_cs_conv_coefft_13_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0a4L);
    system_sw_write_32(base + 0x1c0a4L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_fr_cs_conv_coefft_13_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c0a4L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft 21
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for R-Cb multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CS_CONV_COEFFT_21_DEFAULT (0x801a)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_21_DATASIZE (16)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_21_OFFSET (0x3220)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_21_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_fr_cs_conv_coefft_21_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0a8L);
    system_sw_write_32(base + 0x1c0a8L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_fr_cs_conv_coefft_21_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c0a8L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft 22
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for G-Cb multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CS_CONV_COEFFT_22_DEFAULT (0x8057)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_22_DATASIZE (16)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_22_OFFSET (0x3224)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_22_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_fr_cs_conv_coefft_22_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0acL);
    system_sw_write_32(base + 0x1c0acL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_fr_cs_conv_coefft_22_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c0acL) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft 23
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for B-Cb multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CS_CONV_COEFFT_23_DEFAULT (0x0070)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_23_DATASIZE (16)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_23_OFFSET (0x3228)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_23_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_fr_cs_conv_coefft_23_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0b0L);
    system_sw_write_32(base + 0x1c0b0L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_fr_cs_conv_coefft_23_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c0b0L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft 31
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for R-Cr multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CS_CONV_COEFFT_31_DEFAULT (0x0070)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_31_DATASIZE (16)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_31_OFFSET (0x322c)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_31_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_fr_cs_conv_coefft_31_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0b4L);
    system_sw_write_32(base + 0x1c0b4L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_fr_cs_conv_coefft_31_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c0b4L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft 32
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for G-Cr multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CS_CONV_COEFFT_32_DEFAULT (0x8066)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_32_DATASIZE (16)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_32_OFFSET (0x3230)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_32_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_fr_cs_conv_coefft_32_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0b8L);
    system_sw_write_32(base + 0x1c0b8L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_fr_cs_conv_coefft_32_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c0b8L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft 33
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for B-Cr multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CS_CONV_COEFFT_33_DEFAULT (0x800a)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_33_DATASIZE (16)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_33_OFFSET (0x3234)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_33_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_fr_cs_conv_coefft_33_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0bcL);
    system_sw_write_32(base + 0x1c0bcL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_fr_cs_conv_coefft_33_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c0bcL) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft o1
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Offset for Y
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CS_CONV_COEFFT_O1_DEFAULT (0x000)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_O1_DATASIZE (11)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_O1_OFFSET (0x3238)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_O1_MASK (0x7ff)

// args: data (11-bit)
static __inline void acamera_isp_fr_cs_conv_coefft_o1_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0c0L);
    system_sw_write_32(base + 0x1c0c0L, (((uint32_t) (data & 0x7ff)) << 0) | (curr & 0xfffff800));
}
static __inline uint16_t acamera_isp_fr_cs_conv_coefft_o1_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c0c0L) & 0x7ff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft o2
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Offset for Cb
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CS_CONV_COEFFT_O2_DEFAULT (0x200)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_O2_DATASIZE (11)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_O2_OFFSET (0x323c)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_O2_MASK (0x7ff)

// args: data (11-bit)
static __inline void acamera_isp_fr_cs_conv_coefft_o2_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0c4L);
    system_sw_write_32(base + 0x1c0c4L, (((uint32_t) (data & 0x7ff)) << 0) | (curr & 0xfffff800));
}
static __inline uint16_t acamera_isp_fr_cs_conv_coefft_o2_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c0c4L) & 0x7ff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft o3
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Offset for Cr
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CS_CONV_COEFFT_O3_DEFAULT (0x200)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_O3_DATASIZE (11)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_O3_OFFSET (0x3240)
#define ACAMERA_ISP_FR_CS_CONV_COEFFT_O3_MASK (0x7ff)

// args: data (11-bit)
static __inline void acamera_isp_fr_cs_conv_coefft_o3_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0c8L);
    system_sw_write_32(base + 0x1c0c8L, (((uint32_t) (data & 0x7ff)) << 0) | (curr & 0xfffff800));
}
static __inline uint16_t acamera_isp_fr_cs_conv_coefft_o3_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c0c8L) & 0x7ff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Clip min Y
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Minimal value for Y.  Values below this are clipped.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CS_CONV_CLIP_MIN_Y_DEFAULT (0x000)
#define ACAMERA_ISP_FR_CS_CONV_CLIP_MIN_Y_DATASIZE (10)
#define ACAMERA_ISP_FR_CS_CONV_CLIP_MIN_Y_OFFSET (0x3244)
#define ACAMERA_ISP_FR_CS_CONV_CLIP_MIN_Y_MASK (0x3ff)

// args: data (10-bit)
static __inline void acamera_isp_fr_cs_conv_clip_min_y_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0ccL);
    system_sw_write_32(base + 0x1c0ccL, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
}
static __inline uint16_t acamera_isp_fr_cs_conv_clip_min_y_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c0ccL) & 0x3ff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Clip max Y
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Maximal value for Y.  Values above this are clipped.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CS_CONV_CLIP_MAX_Y_DEFAULT (0x3FF)
#define ACAMERA_ISP_FR_CS_CONV_CLIP_MAX_Y_DATASIZE (10)
#define ACAMERA_ISP_FR_CS_CONV_CLIP_MAX_Y_OFFSET (0x3248)
#define ACAMERA_ISP_FR_CS_CONV_CLIP_MAX_Y_MASK (0x3ff)

// args: data (10-bit)
static __inline void acamera_isp_fr_cs_conv_clip_max_y_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0d0L);
    system_sw_write_32(base + 0x1c0d0L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
}
static __inline uint16_t acamera_isp_fr_cs_conv_clip_max_y_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c0d0L) & 0x3ff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Clip min UV
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Minimal value for Cb, Cr.  Values below this are clipped.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CS_CONV_CLIP_MIN_UV_DEFAULT (0x000)
#define ACAMERA_ISP_FR_CS_CONV_CLIP_MIN_UV_DATASIZE (10)
#define ACAMERA_ISP_FR_CS_CONV_CLIP_MIN_UV_OFFSET (0x324c)
#define ACAMERA_ISP_FR_CS_CONV_CLIP_MIN_UV_MASK (0x3ff)

// args: data (10-bit)
static __inline void acamera_isp_fr_cs_conv_clip_min_uv_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0d4L);
    system_sw_write_32(base + 0x1c0d4L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
}
static __inline uint16_t acamera_isp_fr_cs_conv_clip_min_uv_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c0d4L) & 0x3ff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Clip max UV
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Maximal value for Cb, Cr.  Values above this are clipped.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CS_CONV_CLIP_MAX_UV_DEFAULT (0x3FF)
#define ACAMERA_ISP_FR_CS_CONV_CLIP_MAX_UV_DATASIZE (10)
#define ACAMERA_ISP_FR_CS_CONV_CLIP_MAX_UV_OFFSET (0x3250)
#define ACAMERA_ISP_FR_CS_CONV_CLIP_MAX_UV_MASK (0x3ff)

// args: data (10-bit)
static __inline void acamera_isp_fr_cs_conv_clip_max_uv_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0d8L);
    system_sw_write_32(base + 0x1c0d8L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
}
static __inline uint16_t acamera_isp_fr_cs_conv_clip_max_uv_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c0d8L) & 0x3ff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Data mask RY
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Data mask for channel 1 (R or Y).  Bit-wise and of this value and video data. 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CS_CONV_DATA_MASK_RY_DEFAULT (0x3FF)
#define ACAMERA_ISP_FR_CS_CONV_DATA_MASK_RY_DATASIZE (10)
#define ACAMERA_ISP_FR_CS_CONV_DATA_MASK_RY_OFFSET (0x3254)
#define ACAMERA_ISP_FR_CS_CONV_DATA_MASK_RY_MASK (0x3ff)

// args: data (10-bit)
static __inline void acamera_isp_fr_cs_conv_data_mask_ry_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0dcL);
    system_sw_write_32(base + 0x1c0dcL, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
}
static __inline uint16_t acamera_isp_fr_cs_conv_data_mask_ry_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c0dcL) & 0x3ff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Data mask GU
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Data mask for channel 2 (G or U).  Bit-wise and of this value and video data.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CS_CONV_DATA_MASK_GU_DEFAULT (0x3FF)
#define ACAMERA_ISP_FR_CS_CONV_DATA_MASK_GU_DATASIZE (10)
#define ACAMERA_ISP_FR_CS_CONV_DATA_MASK_GU_OFFSET (0x3258)
#define ACAMERA_ISP_FR_CS_CONV_DATA_MASK_GU_MASK (0x3ff)

// args: data (10-bit)
static __inline void acamera_isp_fr_cs_conv_data_mask_gu_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0e0L);
    system_sw_write_32(base + 0x1c0e0L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
}
static __inline uint16_t acamera_isp_fr_cs_conv_data_mask_gu_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c0e0L) & 0x3ff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Data mask BV
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Data mask for channel 3 (B or V).  Bit-wise and of this value and video data.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CS_CONV_DATA_MASK_BV_DEFAULT (0x3FF)
#define ACAMERA_ISP_FR_CS_CONV_DATA_MASK_BV_DATASIZE (10)
#define ACAMERA_ISP_FR_CS_CONV_DATA_MASK_BV_OFFSET (0x325c)
#define ACAMERA_ISP_FR_CS_CONV_DATA_MASK_BV_MASK (0x3ff)

// args: data (10-bit)
static __inline void acamera_isp_fr_cs_conv_data_mask_bv_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0e4L);
    system_sw_write_32(base + 0x1c0e4L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
}
static __inline uint16_t acamera_isp_fr_cs_conv_data_mask_bv_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c0e4L) & 0x3ff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Group: fr cs conv dither
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Enable dither
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Enables dithering module
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CS_CONV_DITHER_ENABLE_DITHER_DEFAULT (0x0)
#define ACAMERA_ISP_FR_CS_CONV_DITHER_ENABLE_DITHER_DATASIZE (1)
#define ACAMERA_ISP_FR_CS_CONV_DITHER_ENABLE_DITHER_OFFSET (0x3260)
#define ACAMERA_ISP_FR_CS_CONV_DITHER_ENABLE_DITHER_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_fr_cs_conv_dither_enable_dither_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0e8L);
    system_sw_write_32(base + 0x1c0e8L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_fr_cs_conv_dither_enable_dither_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c0e8L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Dither amount
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0= dither to 9 bits; 1=dither to 8 bits; 2=dither to 7 bits; 3=dither to 6 bits 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CS_CONV_DITHER_DITHER_AMOUNT_DEFAULT (0x0)
#define ACAMERA_ISP_FR_CS_CONV_DITHER_DITHER_AMOUNT_DATASIZE (2)
#define ACAMERA_ISP_FR_CS_CONV_DITHER_DITHER_AMOUNT_OFFSET (0x3260)
#define ACAMERA_ISP_FR_CS_CONV_DITHER_DITHER_AMOUNT_MASK (0x6)

// args: data (2-bit)
static __inline void acamera_isp_fr_cs_conv_dither_dither_amount_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0e8L);
    system_sw_write_32(base + 0x1c0e8L, (((uint32_t) (data & 0x3)) << 1) | (curr & 0xfffffff9));
}
static __inline uint8_t acamera_isp_fr_cs_conv_dither_dither_amount_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c0e8L) & 0x6) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: Shift mode
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0= output is LSB aligned; 1=output is MSB aligned
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_CS_CONV_DITHER_SHIFT_MODE_DEFAULT (0x0)
#define ACAMERA_ISP_FR_CS_CONV_DITHER_SHIFT_MODE_DATASIZE (1)
#define ACAMERA_ISP_FR_CS_CONV_DITHER_SHIFT_MODE_OFFSET (0x3260)
#define ACAMERA_ISP_FR_CS_CONV_DITHER_SHIFT_MODE_MASK (0x10)

// args: data (1-bit)
static __inline void acamera_isp_fr_cs_conv_dither_shift_mode_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0e8L);
    system_sw_write_32(base + 0x1c0e8L, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
}
static __inline uint8_t acamera_isp_fr_cs_conv_dither_shift_mode_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c0e8L) & 0x10) >> 4);
}
// ------------------------------------------------------------------------------ //
// Group: fr dma writer
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// DMA writer controls
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Format
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_FORMAT_DEFAULT (0x0)
#define ACAMERA_ISP_FR_DMA_WRITER_FORMAT_DATASIZE (8)
#define ACAMERA_ISP_FR_DMA_WRITER_FORMAT_OFFSET (0x3264)
#define ACAMERA_ISP_FR_DMA_WRITER_FORMAT_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_fr_dma_writer_format_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0ecL);
    system_sw_write_32(base + 0x1c0ecL, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_fr_dma_writer_format_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c0ecL) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Base mode
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Base DMA packing mode for RGB/RAW/YUV etc (see ISP guide)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_BASE_MODE_DEFAULT (0x0)
#define ACAMERA_ISP_FR_DMA_WRITER_BASE_MODE_DATASIZE (5)
#define ACAMERA_ISP_FR_DMA_WRITER_BASE_MODE_OFFSET (0x3264)
#define ACAMERA_ISP_FR_DMA_WRITER_BASE_MODE_MASK (0x1f)

// args: data (5-bit)
static __inline void acamera_isp_fr_dma_writer_base_mode_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0ecL);
    system_sw_write_32(base + 0x1c0ecL, (((uint32_t) (data & 0x1f)) << 0) | (curr & 0xffffffe0));
}
static __inline uint8_t acamera_isp_fr_dma_writer_base_mode_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c0ecL) & 0x1f) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Plane select
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Plane select for planar base modes.  Only used if planar outputs required.  Not used.  Should be set to 0
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_PLANE_SELECT_DEFAULT (0x0)
#define ACAMERA_ISP_FR_DMA_WRITER_PLANE_SELECT_DATASIZE (2)
#define ACAMERA_ISP_FR_DMA_WRITER_PLANE_SELECT_OFFSET (0x3264)
#define ACAMERA_ISP_FR_DMA_WRITER_PLANE_SELECT_MASK (0xc0)

// args: data (2-bit)
static __inline void acamera_isp_fr_dma_writer_plane_select_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0ecL);
    system_sw_write_32(base + 0x1c0ecL, (((uint32_t) (data & 0x3)) << 6) | (curr & 0xffffff3f));
}
static __inline uint8_t acamera_isp_fr_dma_writer_plane_select_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c0ecL) & 0xc0) >> 6);
}
// ------------------------------------------------------------------------------ //
// Register: single frame
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0 = All frames are written(after frame_write_on= 1), 1= only 1st frame written ( after frame_write_on =1)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_SINGLE_FRAME_DEFAULT (0)
#define ACAMERA_ISP_FR_DMA_WRITER_SINGLE_FRAME_DATASIZE (1)
#define ACAMERA_ISP_FR_DMA_WRITER_SINGLE_FRAME_OFFSET (0x3264)
#define ACAMERA_ISP_FR_DMA_WRITER_SINGLE_FRAME_MASK (0x100)

// args: data (1-bit)
static __inline void acamera_isp_fr_dma_writer_single_frame_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0ecL);
    system_sw_write_32(base + 0x1c0ecL, (((uint32_t) (data & 0x1)) << 8) | (curr & 0xfffffeff));
}
static __inline uint8_t acamera_isp_fr_dma_writer_single_frame_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c0ecL) & 0x100) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: frame write on
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        0 = no frames written(when switched from 1, current frame completes writing before stopping),
//        1= write frame(s) (write single or continous frame(s) )
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_FRAME_WRITE_ON_DEFAULT (0)
#define ACAMERA_ISP_FR_DMA_WRITER_FRAME_WRITE_ON_DATASIZE (1)
#define ACAMERA_ISP_FR_DMA_WRITER_FRAME_WRITE_ON_OFFSET (0x3264)
#define ACAMERA_ISP_FR_DMA_WRITER_FRAME_WRITE_ON_MASK (0x200)

// args: data (1-bit)
static __inline void acamera_isp_fr_dma_writer_frame_write_on_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0ecL);
    system_sw_write_32(base + 0x1c0ecL, (((uint32_t) (data & 0x1)) << 9) | (curr & 0xfffffdff));
}
static __inline uint8_t acamera_isp_fr_dma_writer_frame_write_on_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c0ecL) & 0x200) >> 9);
}
// ------------------------------------------------------------------------------ //
// Register: axi xact comp
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0 = dont wait for axi transaction completion at end of frame(just all transfers accepted). 1 = wait for all transactions completed
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_AXI_XACT_COMP_DEFAULT (0)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_XACT_COMP_DATASIZE (1)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_XACT_COMP_OFFSET (0x3264)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_XACT_COMP_MASK (0x800)

// args: data (1-bit)
static __inline void acamera_isp_fr_dma_writer_axi_xact_comp_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0ecL);
    system_sw_write_32(base + 0x1c0ecL, (((uint32_t) (data & 0x1)) << 11) | (curr & 0xfffff7ff));
}
static __inline uint8_t acamera_isp_fr_dma_writer_axi_xact_comp_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c0ecL) & 0x800) >> 11);
}
// ------------------------------------------------------------------------------ //
// Register: active width
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Active video width in pixels 128-8000
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_ACTIVE_WIDTH_DEFAULT (0x780)
#define ACAMERA_ISP_FR_DMA_WRITER_ACTIVE_WIDTH_DATASIZE (16)
#define ACAMERA_ISP_FR_DMA_WRITER_ACTIVE_WIDTH_OFFSET (0x3268)
#define ACAMERA_ISP_FR_DMA_WRITER_ACTIVE_WIDTH_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_fr_dma_writer_active_width_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0f0L);
    system_sw_write_32(base + 0x1c0f0L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_fr_dma_writer_active_width_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c0f0L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: active height
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Active video height in lines 128-8000
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_ACTIVE_HEIGHT_DEFAULT (0x438)
#define ACAMERA_ISP_FR_DMA_WRITER_ACTIVE_HEIGHT_DATASIZE (16)
#define ACAMERA_ISP_FR_DMA_WRITER_ACTIVE_HEIGHT_OFFSET (0x3268)
#define ACAMERA_ISP_FR_DMA_WRITER_ACTIVE_HEIGHT_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_fr_dma_writer_active_height_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c0f0L);
    system_sw_write_32(base + 0x1c0f0L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_fr_dma_writer_active_height_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c0f0L) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: bank0_base
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// bank 0 base address for frame buffer, should be word-aligned
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_BANK0_BASE_DEFAULT (0x0)
#define ACAMERA_ISP_FR_DMA_WRITER_BANK0_BASE_DATASIZE (32)
#define ACAMERA_ISP_FR_DMA_WRITER_BANK0_BASE_OFFSET (0x326c)
#define ACAMERA_ISP_FR_DMA_WRITER_BANK0_BASE_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_fr_dma_writer_bank0_base_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1c0f4L, data);
}
static __inline uint32_t acamera_isp_fr_dma_writer_bank0_base_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1c0f4L);
}
// ------------------------------------------------------------------------------ //
// Register: bank1_base
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// bank 1 base address for frame buffer, should be word-aligned
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_BANK1_BASE_DEFAULT (0x0)
#define ACAMERA_ISP_FR_DMA_WRITER_BANK1_BASE_DATASIZE (32)
#define ACAMERA_ISP_FR_DMA_WRITER_BANK1_BASE_OFFSET (0x3270)
#define ACAMERA_ISP_FR_DMA_WRITER_BANK1_BASE_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_fr_dma_writer_bank1_base_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1c0f8L, data);
}
static __inline uint32_t acamera_isp_fr_dma_writer_bank1_base_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1c0f8L);
}
// ------------------------------------------------------------------------------ //
// Register: bank2_base
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// bank 2 base address for frame buffer, should be word-aligned
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_BANK2_BASE_DEFAULT (0x0)
#define ACAMERA_ISP_FR_DMA_WRITER_BANK2_BASE_DATASIZE (32)
#define ACAMERA_ISP_FR_DMA_WRITER_BANK2_BASE_OFFSET (0x3274)
#define ACAMERA_ISP_FR_DMA_WRITER_BANK2_BASE_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_fr_dma_writer_bank2_base_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1c0fcL, data);
}
static __inline uint32_t acamera_isp_fr_dma_writer_bank2_base_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1c0fcL);
}
// ------------------------------------------------------------------------------ //
// Register: bank3_base
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// bank 3 base address for frame buffer, should be word-aligned
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_BANK3_BASE_DEFAULT (0x0)
#define ACAMERA_ISP_FR_DMA_WRITER_BANK3_BASE_DATASIZE (32)
#define ACAMERA_ISP_FR_DMA_WRITER_BANK3_BASE_OFFSET (0x3278)
#define ACAMERA_ISP_FR_DMA_WRITER_BANK3_BASE_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_fr_dma_writer_bank3_base_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1c100L, data);
}
static __inline uint32_t acamera_isp_fr_dma_writer_bank3_base_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1c100L);
}
// ------------------------------------------------------------------------------ //
// Register: bank4_base
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// bank 4 base address for frame buffer, should be word-aligned
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_BANK4_BASE_DEFAULT (0x0)
#define ACAMERA_ISP_FR_DMA_WRITER_BANK4_BASE_DATASIZE (32)
#define ACAMERA_ISP_FR_DMA_WRITER_BANK4_BASE_OFFSET (0x327c)
#define ACAMERA_ISP_FR_DMA_WRITER_BANK4_BASE_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_fr_dma_writer_bank4_base_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1c104L, data);
}
static __inline uint32_t acamera_isp_fr_dma_writer_bank4_base_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1c104L);
}
// ------------------------------------------------------------------------------ //
// Register: max bank
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// highest bank*_base to use for frame writes before recycling to bank0_base, only 0 to 4 are valid
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_MAX_BANK_DEFAULT (0x0)
#define ACAMERA_ISP_FR_DMA_WRITER_MAX_BANK_DATASIZE (3)
#define ACAMERA_ISP_FR_DMA_WRITER_MAX_BANK_OFFSET (0x3280)
#define ACAMERA_ISP_FR_DMA_WRITER_MAX_BANK_MASK (0x7)

// args: data (3-bit)
static __inline void acamera_isp_fr_dma_writer_max_bank_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c108L);
    system_sw_write_32(base + 0x1c108L, (((uint32_t) (data & 0x7)) << 0) | (curr & 0xfffffff8));
}
static __inline uint8_t acamera_isp_fr_dma_writer_max_bank_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c108L) & 0x7) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: bank0 restart
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0 = normal operation, 1= restart bank counter to bank0 for next frame write
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_BANK0_RESTART_DEFAULT (0)
#define ACAMERA_ISP_FR_DMA_WRITER_BANK0_RESTART_DATASIZE (1)
#define ACAMERA_ISP_FR_DMA_WRITER_BANK0_RESTART_OFFSET (0x3280)
#define ACAMERA_ISP_FR_DMA_WRITER_BANK0_RESTART_MASK (0x8)

// args: data (1-bit)
static __inline void acamera_isp_fr_dma_writer_bank0_restart_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c108L);
    system_sw_write_32(base + 0x1c108L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
}
static __inline uint8_t acamera_isp_fr_dma_writer_bank0_restart_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c108L) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: Line_offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Indicates the offset in bytes from the start of one line to the next line.  
//        This value should be equal to or larger than one line of image data and should be word-aligned
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_LINE_OFFSET_DEFAULT (0x1000)
#define ACAMERA_ISP_FR_DMA_WRITER_LINE_OFFSET_DATASIZE (32)
#define ACAMERA_ISP_FR_DMA_WRITER_LINE_OFFSET_OFFSET (0x3284)
#define ACAMERA_ISP_FR_DMA_WRITER_LINE_OFFSET_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_fr_dma_writer_line_offset_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1c10cL, data);
}
static __inline uint32_t acamera_isp_fr_dma_writer_line_offset_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1c10cL);
}
// ------------------------------------------------------------------------------ //
// Register: wbank curr
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// write bank currently active. valid values =0-4. updated at start of frame write
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_WBANK_CURR_DEFAULT (0x0)
#define ACAMERA_ISP_FR_DMA_WRITER_WBANK_CURR_DATASIZE (3)
#define ACAMERA_ISP_FR_DMA_WRITER_WBANK_CURR_OFFSET (0x3288)
#define ACAMERA_ISP_FR_DMA_WRITER_WBANK_CURR_MASK (0xe)

// args: data (3-bit)
static __inline uint8_t acamera_isp_fr_dma_writer_wbank_curr_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c110L) & 0xe) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: wbank active
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 1 = wbank_curr is being written to. Goes high at start of writes, low at last write transfer/completion on axi. 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_WBANK_ACTIVE_DEFAULT (0x0)
#define ACAMERA_ISP_FR_DMA_WRITER_WBANK_ACTIVE_DATASIZE (1)
#define ACAMERA_ISP_FR_DMA_WRITER_WBANK_ACTIVE_OFFSET (0x3288)
#define ACAMERA_ISP_FR_DMA_WRITER_WBANK_ACTIVE_MASK (0x1)

// args: data (1-bit)
static __inline uint8_t acamera_isp_fr_dma_writer_wbank_active_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c110L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: frame icount
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// count of incomming frames (starts) to vdma_writer on video input, non resetable, rolls over, updates at pixel 1 of new frame on video in
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_FRAME_ICOUNT_DEFAULT (0x0)
#define ACAMERA_ISP_FR_DMA_WRITER_FRAME_ICOUNT_DATASIZE (16)
#define ACAMERA_ISP_FR_DMA_WRITER_FRAME_ICOUNT_OFFSET (0x3294)
#define ACAMERA_ISP_FR_DMA_WRITER_FRAME_ICOUNT_MASK (0xffff)

// args: data (16-bit)
static __inline uint16_t acamera_isp_fr_dma_writer_frame_icount_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c11cL) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: frame wcount
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// count of outgoing frame writes (starts) from vdma_writer sent to AXI output, non resetable, rolls over, updates at pixel 1 of new frame on video in
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_FRAME_WCOUNT_DEFAULT (0x0)
#define ACAMERA_ISP_FR_DMA_WRITER_FRAME_WCOUNT_DATASIZE (16)
#define ACAMERA_ISP_FR_DMA_WRITER_FRAME_WCOUNT_OFFSET (0x3294)
#define ACAMERA_ISP_FR_DMA_WRITER_FRAME_WCOUNT_MASK (0xffff0000)

// args: data (16-bit)
static __inline uint16_t acamera_isp_fr_dma_writer_frame_wcount_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c11cL) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: axi_fail_bresp
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high to indicate bad  bresp captured 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_AXI_FAIL_BRESP_DEFAULT (0x0)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_FAIL_BRESP_DATASIZE (1)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_FAIL_BRESP_OFFSET (0x329c)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_FAIL_BRESP_MASK (0x1)

// args: data (1-bit)
static __inline uint8_t acamera_isp_fr_dma_writer_axi_fail_bresp_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c124L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: axi_fail_awmaxwait
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high when awmaxwait_limit reached 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_AXI_FAIL_AWMAXWAIT_DEFAULT (0x0)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_FAIL_AWMAXWAIT_DATASIZE (1)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_FAIL_AWMAXWAIT_OFFSET (0x329c)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_FAIL_AWMAXWAIT_MASK (0x2)

// args: data (1-bit)
static __inline uint8_t acamera_isp_fr_dma_writer_axi_fail_awmaxwait_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c124L) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: axi_fail_wmaxwait
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high when wmaxwait_limit reached 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_AXI_FAIL_WMAXWAIT_DEFAULT (0x0)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_FAIL_WMAXWAIT_DATASIZE (1)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_FAIL_WMAXWAIT_OFFSET (0x329c)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_FAIL_WMAXWAIT_MASK (0x4)

// args: data (1-bit)
static __inline uint8_t acamera_isp_fr_dma_writer_axi_fail_wmaxwait_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c124L) & 0x4) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: axi_fail_wxact_ostand
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high when wxact_ostand_limit reached 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_AXI_FAIL_WXACT_OSTAND_DEFAULT (0x0)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_FAIL_WXACT_OSTAND_DATASIZE (1)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_FAIL_WXACT_OSTAND_OFFSET (0x329c)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_FAIL_WXACT_OSTAND_MASK (0x8)

// args: data (1-bit)
static __inline uint8_t acamera_isp_fr_dma_writer_axi_fail_wxact_ostand_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c124L) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: vi_fail_active_width
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high to indicate mismatched active_width detected 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_VI_FAIL_ACTIVE_WIDTH_DEFAULT (0x0)
#define ACAMERA_ISP_FR_DMA_WRITER_VI_FAIL_ACTIVE_WIDTH_DATASIZE (1)
#define ACAMERA_ISP_FR_DMA_WRITER_VI_FAIL_ACTIVE_WIDTH_OFFSET (0x329c)
#define ACAMERA_ISP_FR_DMA_WRITER_VI_FAIL_ACTIVE_WIDTH_MASK (0x10)

// args: data (1-bit)
static __inline uint8_t acamera_isp_fr_dma_writer_vi_fail_active_width_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c124L) & 0x10) >> 4);
}
// ------------------------------------------------------------------------------ //
// Register: vi_fail_active_height
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high to indicate mismatched active_height detected ( also raised on missing field!) 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_VI_FAIL_ACTIVE_HEIGHT_DEFAULT (0x0)
#define ACAMERA_ISP_FR_DMA_WRITER_VI_FAIL_ACTIVE_HEIGHT_DATASIZE (1)
#define ACAMERA_ISP_FR_DMA_WRITER_VI_FAIL_ACTIVE_HEIGHT_OFFSET (0x329c)
#define ACAMERA_ISP_FR_DMA_WRITER_VI_FAIL_ACTIVE_HEIGHT_MASK (0x20)

// args: data (1-bit)
static __inline uint8_t acamera_isp_fr_dma_writer_vi_fail_active_height_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c124L) & 0x20) >> 5);
}
// ------------------------------------------------------------------------------ //
// Register: vi_fail_interline_blanks
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high to indicate interline blanking below min 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_VI_FAIL_INTERLINE_BLANKS_DEFAULT (0x0)
#define ACAMERA_ISP_FR_DMA_WRITER_VI_FAIL_INTERLINE_BLANKS_DATASIZE (1)
#define ACAMERA_ISP_FR_DMA_WRITER_VI_FAIL_INTERLINE_BLANKS_OFFSET (0x329c)
#define ACAMERA_ISP_FR_DMA_WRITER_VI_FAIL_INTERLINE_BLANKS_MASK (0x40)

// args: data (1-bit)
static __inline uint8_t acamera_isp_fr_dma_writer_vi_fail_interline_blanks_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c124L) & 0x40) >> 6);
}
// ------------------------------------------------------------------------------ //
// Register: vi_fail_interframe_blanks
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high to indicate interframe blanking below min 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_VI_FAIL_INTERFRAME_BLANKS_DEFAULT (0x0)
#define ACAMERA_ISP_FR_DMA_WRITER_VI_FAIL_INTERFRAME_BLANKS_DATASIZE (1)
#define ACAMERA_ISP_FR_DMA_WRITER_VI_FAIL_INTERFRAME_BLANKS_OFFSET (0x329c)
#define ACAMERA_ISP_FR_DMA_WRITER_VI_FAIL_INTERFRAME_BLANKS_MASK (0x80)

// args: data (1-bit)
static __inline uint8_t acamera_isp_fr_dma_writer_vi_fail_interframe_blanks_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c124L) & 0x80) >> 7);
}
// ------------------------------------------------------------------------------ //
// Register: video_alarm
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  active high, problem found on video port(s) ( active width/height or interline/frame blanks failure) 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_VIDEO_ALARM_DEFAULT (0x0)
#define ACAMERA_ISP_FR_DMA_WRITER_VIDEO_ALARM_DATASIZE (1)
#define ACAMERA_ISP_FR_DMA_WRITER_VIDEO_ALARM_OFFSET (0x329c)
#define ACAMERA_ISP_FR_DMA_WRITER_VIDEO_ALARM_MASK (0x100)

// args: data (1-bit)
static __inline uint8_t acamera_isp_fr_dma_writer_video_alarm_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c124L) & 0x100) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: blk_status
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        block status output (reserved)
//                          -- blk_status(0) = wfifo_fail_full
//                          -- blk_status(1) = wfifo_fail_empty
//                          -- blk_status(4) = pack_fail_overflow
//                          -- blk_status(24) = intw_fail_user_intfc_sig
//                          -- blk_status(others) =  zero     
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_BLK_STATUS_DEFAULT (0x0)
#define ACAMERA_ISP_FR_DMA_WRITER_BLK_STATUS_DATASIZE (32)
#define ACAMERA_ISP_FR_DMA_WRITER_BLK_STATUS_OFFSET (0x32a0)
#define ACAMERA_ISP_FR_DMA_WRITER_BLK_STATUS_MASK (0xffffffff)

// args: data (32-bit)
static __inline uint32_t acamera_isp_fr_dma_writer_blk_status_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1c128L);
}
// ------------------------------------------------------------------------------ //
// Register: lines_wrapped
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Number of lines to write from base address before wrapping back to base address. 0 = no wrapping, >0 = last line written before wrapping
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_LINES_WRAPPED_DEFAULT (0x0000)
#define ACAMERA_ISP_FR_DMA_WRITER_LINES_WRAPPED_DATASIZE (16)
#define ACAMERA_ISP_FR_DMA_WRITER_LINES_WRAPPED_OFFSET (0x32a4)
#define ACAMERA_ISP_FR_DMA_WRITER_LINES_WRAPPED_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_fr_dma_writer_lines_wrapped_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c12cL);
    system_sw_write_32(base + 0x1c12cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_fr_dma_writer_lines_wrapped_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c12cL) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: linetick_first
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Line number of first linetick. 0  = no linetick, >0 = line number to generate linetick 
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_LINETICK_FIRST_DEFAULT (0x0000)
#define ACAMERA_ISP_FR_DMA_WRITER_LINETICK_FIRST_DATASIZE (16)
#define ACAMERA_ISP_FR_DMA_WRITER_LINETICK_FIRST_OFFSET (0x32a8)
#define ACAMERA_ISP_FR_DMA_WRITER_LINETICK_FIRST_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_fr_dma_writer_linetick_first_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c130L);
    system_sw_write_32(base + 0x1c130L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_fr_dma_writer_linetick_first_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c130L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: linetick_repeat
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Line repeat interval of linetick. 0 = no repeat, >0 = repeat interval in lines 
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_LINETICK_REPEAT_DEFAULT (0x0000)
#define ACAMERA_ISP_FR_DMA_WRITER_LINETICK_REPEAT_DATASIZE (16)
#define ACAMERA_ISP_FR_DMA_WRITER_LINETICK_REPEAT_OFFSET (0x32ac)
#define ACAMERA_ISP_FR_DMA_WRITER_LINETICK_REPEAT_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_fr_dma_writer_linetick_repeat_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c134L);
    system_sw_write_32(base + 0x1c134L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_fr_dma_writer_linetick_repeat_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c134L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: linetick_eol
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Linetick start/end of line control. 0 = use start of line, 1 = use end of line to generate linetick
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_LINETICK_EOL_DEFAULT (0)
#define ACAMERA_ISP_FR_DMA_WRITER_LINETICK_EOL_DATASIZE (1)
#define ACAMERA_ISP_FR_DMA_WRITER_LINETICK_EOL_OFFSET (0x32b0)
#define ACAMERA_ISP_FR_DMA_WRITER_LINETICK_EOL_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_fr_dma_writer_linetick_eol_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c138L);
    system_sw_write_32(base + 0x1c138L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_fr_dma_writer_linetick_eol_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c138L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: linetick_delay
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Linetick delay in vcke cycles to add to min 3 cycle latency from acl_vi. 0-65535.
//        Must be less than next linetick generation time or count will not mature and no linetick is not produced.
//          --NOTE: linetick delay  can run past end of frame/field and also into next frame!
//          --      Take care maturity time is less than next configured linetick generation postion!
//          --      Take care when changing config between frame too! 
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_LINETICK_DELAY_DEFAULT (0x0000)
#define ACAMERA_ISP_FR_DMA_WRITER_LINETICK_DELAY_DATASIZE (16)
#define ACAMERA_ISP_FR_DMA_WRITER_LINETICK_DELAY_OFFSET (0x32b0)
#define ACAMERA_ISP_FR_DMA_WRITER_LINETICK_DELAY_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_fr_dma_writer_linetick_delay_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c138L);
    system_sw_write_32(base + 0x1c138L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_fr_dma_writer_linetick_delay_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c138L) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: pagewarm_on
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        active high, enables posting of pagewarm dummy writes to SMMU for early page translation of upcomming 4K pages. 
//        Recommend SMMU has min 8 page cache to avoid translation miss. Pagewarms are posted as dummy writes with wstrb= 0
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_PAGEWARM_ON_DEFAULT (0)
#define ACAMERA_ISP_FR_DMA_WRITER_PAGEWARM_ON_DATASIZE (1)
#define ACAMERA_ISP_FR_DMA_WRITER_PAGEWARM_ON_OFFSET (0x32b4)
#define ACAMERA_ISP_FR_DMA_WRITER_PAGEWARM_ON_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_fr_dma_writer_pagewarm_on_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c13cL);
    system_sw_write_32(base + 0x1c13cL, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_fr_dma_writer_pagewarm_on_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c13cL) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: axi_id_multi
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        0= static value (axi_id_value) for awid/wid, 1 = incrementing value per transaction for awid/wid wrapping to 0 after axi_id_value
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_AXI_ID_MULTI_DEFAULT (0)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_ID_MULTI_DATASIZE (1)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_ID_MULTI_OFFSET (0x32b4)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_ID_MULTI_MASK (0x2)

// args: data (1-bit)
static __inline void acamera_isp_fr_dma_writer_axi_id_multi_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c13cL);
    system_sw_write_32(base + 0x1c13cL, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
}
static __inline uint8_t acamera_isp_fr_dma_writer_axi_id_multi_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c13cL) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: axi_burstsplit
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        memory boundary that splits bursts: 0=2Transfers,1=4Transfers,2=8Transfers,3=16Transfers. (for axi_data_w=128,  16transfers=256Bytes). Good default = 11
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_AXI_BURSTSPLIT_DEFAULT (0x3)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_BURSTSPLIT_DATASIZE (2)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_BURSTSPLIT_OFFSET (0x32b4)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_BURSTSPLIT_MASK (0xc)

// args: data (2-bit)
static __inline void acamera_isp_fr_dma_writer_axi_burstsplit_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c13cL);
    system_sw_write_32(base + 0x1c13cL, (((uint32_t) (data & 0x3)) << 2) | (curr & 0xfffffff3));
}
static __inline uint8_t acamera_isp_fr_dma_writer_axi_burstsplit_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c13cL) & 0xc) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: axi_cache_value
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        value to send for awcache. Good default = 1111
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_AXI_CACHE_VALUE_DEFAULT (0xf)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_CACHE_VALUE_DATASIZE (4)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_CACHE_VALUE_OFFSET (0x32b4)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_CACHE_VALUE_MASK (0xf00)

// args: data (4-bit)
static __inline void acamera_isp_fr_dma_writer_axi_cache_value_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c13cL);
    system_sw_write_32(base + 0x1c13cL, (((uint32_t) (data & 0xf)) << 8) | (curr & 0xfffff0ff));
}
static __inline uint8_t acamera_isp_fr_dma_writer_axi_cache_value_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c13cL) & 0xf00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: axi_maxostand
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        max outstanding write transactions (bursts) allowed. zero means no maximum(uses internal limit of 2048). 
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_AXI_MAXOSTAND_DEFAULT (0x00)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_MAXOSTAND_DATASIZE (8)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_MAXOSTAND_OFFSET (0x32b4)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_MAXOSTAND_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_fr_dma_writer_axi_maxostand_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c13cL);
    system_sw_write_32(base + 0x1c13cL, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_fr_dma_writer_axi_maxostand_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c13cL) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: axi_max_awlen
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        max value to use for awlen (axi burst length). 0000= max 1 transfer/burst , upto 1111= max 16 transfers/burst
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_AXI_MAX_AWLEN_DEFAULT (0xf)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_MAX_AWLEN_DATASIZE (4)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_MAX_AWLEN_OFFSET (0x32b4)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_MAX_AWLEN_MASK (0xf000000)

// args: data (4-bit)
static __inline void acamera_isp_fr_dma_writer_axi_max_awlen_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c13cL);
    system_sw_write_32(base + 0x1c13cL, (((uint32_t) (data & 0xf)) << 24) | (curr & 0xf0ffffff));
}
static __inline uint8_t acamera_isp_fr_dma_writer_axi_max_awlen_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c13cL) & 0xf000000) >> 24);
}
// ------------------------------------------------------------------------------ //
// Register: axi_id_value
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        value to send for awid, wid and expected on bid. Good default = 0000
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_DMA_WRITER_AXI_ID_VALUE_DEFAULT (0x0)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_ID_VALUE_DATASIZE (4)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_ID_VALUE_OFFSET (0x32b8)
#define ACAMERA_ISP_FR_DMA_WRITER_AXI_ID_VALUE_MASK (0xf)

// args: data (4-bit)
static __inline void acamera_isp_fr_dma_writer_axi_id_value_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c140L);
    system_sw_write_32(base + 0x1c140L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
}
static __inline uint8_t acamera_isp_fr_dma_writer_axi_id_value_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c140L) & 0xf) >> 0);
}
// ------------------------------------------------------------------------------ //
// Group: fr uv dma writer
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// DMA writer controls
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Format
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_FORMAT_DEFAULT (0x0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_FORMAT_DATASIZE (8)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_FORMAT_OFFSET (0x32bc)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_FORMAT_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_fr_uv_dma_writer_format_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c144L);
    system_sw_write_32(base + 0x1c144L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_fr_uv_dma_writer_format_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c144L) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Base mode
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Base DMA packing mode for RGB/RAW/YUV etc (see ISP guide)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_BASE_MODE_DEFAULT (0x0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_BASE_MODE_DATASIZE (5)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_BASE_MODE_OFFSET (0x32bc)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_BASE_MODE_MASK (0x1f)

// args: data (5-bit)
static __inline void acamera_isp_fr_uv_dma_writer_base_mode_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c144L);
    system_sw_write_32(base + 0x1c144L, (((uint32_t) (data & 0x1f)) << 0) | (curr & 0xffffffe0));
}
static __inline uint8_t acamera_isp_fr_uv_dma_writer_base_mode_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c144L) & 0x1f) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Plane select
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Plane select for planar base modes.  Only used if planar outputs required.  Not used.  Should be set to 0
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_PLANE_SELECT_DEFAULT (0x0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_PLANE_SELECT_DATASIZE (2)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_PLANE_SELECT_OFFSET (0x32bc)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_PLANE_SELECT_MASK (0xc0)

// args: data (2-bit)
static __inline void acamera_isp_fr_uv_dma_writer_plane_select_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c144L);
    system_sw_write_32(base + 0x1c144L, (((uint32_t) (data & 0x3)) << 6) | (curr & 0xffffff3f));
}
static __inline uint8_t acamera_isp_fr_uv_dma_writer_plane_select_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c144L) & 0xc0) >> 6);
}
// ------------------------------------------------------------------------------ //
// Register: single frame
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0 = All frames are written(after frame_write_on= 1), 1= only 1st frame written ( after frame_write_on =1)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_SINGLE_FRAME_DEFAULT (0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_SINGLE_FRAME_DATASIZE (1)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_SINGLE_FRAME_OFFSET (0x32bc)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_SINGLE_FRAME_MASK (0x100)

// args: data (1-bit)
static __inline void acamera_isp_fr_uv_dma_writer_single_frame_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c144L);
    system_sw_write_32(base + 0x1c144L, (((uint32_t) (data & 0x1)) << 8) | (curr & 0xfffffeff));
}
static __inline uint8_t acamera_isp_fr_uv_dma_writer_single_frame_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c144L) & 0x100) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: frame write on
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        0 = no frames written(when switched from 1, current frame completes writing before stopping),
//        1= write frame(s) (write single or continous frame(s) )
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_FRAME_WRITE_ON_DEFAULT (0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_FRAME_WRITE_ON_DATASIZE (1)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_FRAME_WRITE_ON_OFFSET (0x32bc)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_FRAME_WRITE_ON_MASK (0x200)

// args: data (1-bit)
static __inline void acamera_isp_fr_uv_dma_writer_frame_write_on_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c144L);
    system_sw_write_32(base + 0x1c144L, (((uint32_t) (data & 0x1)) << 9) | (curr & 0xfffffdff));
}
static __inline uint8_t acamera_isp_fr_uv_dma_writer_frame_write_on_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c144L) & 0x200) >> 9);
}
// ------------------------------------------------------------------------------ //
// Register: axi xact comp
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0 = dont wait for axi transaction completion at end of frame(just all transfers accepted). 1 = wait for all transactions completed
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_XACT_COMP_DEFAULT (0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_XACT_COMP_DATASIZE (1)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_XACT_COMP_OFFSET (0x32bc)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_XACT_COMP_MASK (0x800)

// args: data (1-bit)
static __inline void acamera_isp_fr_uv_dma_writer_axi_xact_comp_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c144L);
    system_sw_write_32(base + 0x1c144L, (((uint32_t) (data & 0x1)) << 11) | (curr & 0xfffff7ff));
}
static __inline uint8_t acamera_isp_fr_uv_dma_writer_axi_xact_comp_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c144L) & 0x800) >> 11);
}
// ------------------------------------------------------------------------------ //
// Register: active width
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Active video width in pixels 128-8000
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_ACTIVE_WIDTH_DEFAULT (0x780)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_ACTIVE_WIDTH_DATASIZE (16)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_ACTIVE_WIDTH_OFFSET (0x32c0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_ACTIVE_WIDTH_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_fr_uv_dma_writer_active_width_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c148L);
    system_sw_write_32(base + 0x1c148L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_fr_uv_dma_writer_active_width_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c148L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: active height
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Active video height in lines 128-8000
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_ACTIVE_HEIGHT_DEFAULT (0x438)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_ACTIVE_HEIGHT_DATASIZE (16)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_ACTIVE_HEIGHT_OFFSET (0x32c0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_ACTIVE_HEIGHT_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_fr_uv_dma_writer_active_height_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c148L);
    system_sw_write_32(base + 0x1c148L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_fr_uv_dma_writer_active_height_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c148L) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: bank0_base
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// bank 0 base address for frame buffer, should be word-aligned
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_BANK0_BASE_DEFAULT (0x0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_BANK0_BASE_DATASIZE (32)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_BANK0_BASE_OFFSET (0x32c4)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_BANK0_BASE_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_fr_uv_dma_writer_bank0_base_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1c14cL, data);
}
static __inline uint32_t acamera_isp_fr_uv_dma_writer_bank0_base_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1c14cL);
}
// ------------------------------------------------------------------------------ //
// Register: bank1_base
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// bank 1 base address for frame buffer, should be word-aligned
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_BANK1_BASE_DEFAULT (0x0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_BANK1_BASE_DATASIZE (32)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_BANK1_BASE_OFFSET (0x32c8)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_BANK1_BASE_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_fr_uv_dma_writer_bank1_base_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1c150L, data);
}
static __inline uint32_t acamera_isp_fr_uv_dma_writer_bank1_base_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1c150L);
}
// ------------------------------------------------------------------------------ //
// Register: bank2_base
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// bank 2 base address for frame buffer, should be word-aligned
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_BANK2_BASE_DEFAULT (0x0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_BANK2_BASE_DATASIZE (32)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_BANK2_BASE_OFFSET (0x32cc)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_BANK2_BASE_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_fr_uv_dma_writer_bank2_base_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1c154L, data);
}
static __inline uint32_t acamera_isp_fr_uv_dma_writer_bank2_base_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1c154L);
}
// ------------------------------------------------------------------------------ //
// Register: bank3_base
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// bank 3 base address for frame buffer, should be word-aligned
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_BANK3_BASE_DEFAULT (0x0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_BANK3_BASE_DATASIZE (32)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_BANK3_BASE_OFFSET (0x32d0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_BANK3_BASE_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_fr_uv_dma_writer_bank3_base_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1c158L, data);
}
static __inline uint32_t acamera_isp_fr_uv_dma_writer_bank3_base_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1c158L);
}
// ------------------------------------------------------------------------------ //
// Register: bank4_base
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// bank 4 base address for frame buffer, should be word-aligned
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_BANK4_BASE_DEFAULT (0x0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_BANK4_BASE_DATASIZE (32)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_BANK4_BASE_OFFSET (0x32d4)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_BANK4_BASE_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_fr_uv_dma_writer_bank4_base_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1c15cL, data);
}
static __inline uint32_t acamera_isp_fr_uv_dma_writer_bank4_base_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1c15cL);
}
// ------------------------------------------------------------------------------ //
// Register: max bank
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// highest bank*_base to use for frame writes before recycling to bank0_base, only 0 to 4 are valid
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_MAX_BANK_DEFAULT (0x0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_MAX_BANK_DATASIZE (3)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_MAX_BANK_OFFSET (0x32d8)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_MAX_BANK_MASK (0x7)

// args: data (3-bit)
static __inline void acamera_isp_fr_uv_dma_writer_max_bank_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c160L);
    system_sw_write_32(base + 0x1c160L, (((uint32_t) (data & 0x7)) << 0) | (curr & 0xfffffff8));
}
static __inline uint8_t acamera_isp_fr_uv_dma_writer_max_bank_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c160L) & 0x7) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: bank0 restart
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0 = normal operation, 1= restart bank counter to bank0 for next frame write
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_BANK0_RESTART_DEFAULT (0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_BANK0_RESTART_DATASIZE (1)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_BANK0_RESTART_OFFSET (0x32d8)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_BANK0_RESTART_MASK (0x8)

// args: data (1-bit)
static __inline void acamera_isp_fr_uv_dma_writer_bank0_restart_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c160L);
    system_sw_write_32(base + 0x1c160L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
}
static __inline uint8_t acamera_isp_fr_uv_dma_writer_bank0_restart_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c160L) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: Line_offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Indicates the offset in bytes from the start of one line to the next line.  
//        This value should be equal to or larger than one line of image data and should be word-aligned
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_LINE_OFFSET_DEFAULT (0x1000)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_LINE_OFFSET_DATASIZE (32)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_LINE_OFFSET_OFFSET (0x32dc)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_LINE_OFFSET_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_fr_uv_dma_writer_line_offset_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1c164L, data);
}
static __inline uint32_t acamera_isp_fr_uv_dma_writer_line_offset_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1c164L);
}
// ------------------------------------------------------------------------------ //
// Register: wbank curr
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// write bank currently active. valid values =0-4. updated at start of frame write
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_WBANK_CURR_DEFAULT (0x0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_WBANK_CURR_DATASIZE (3)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_WBANK_CURR_OFFSET (0x32e0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_WBANK_CURR_MASK (0xe)

// args: data (3-bit)
static __inline uint8_t acamera_isp_fr_uv_dma_writer_wbank_curr_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c168L) & 0xe) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: wbank active
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 1 = wbank_curr is being written to. Goes high at start of writes, low at last write transfer/completion on axi. 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_WBANK_ACTIVE_DEFAULT (0x0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_WBANK_ACTIVE_DATASIZE (1)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_WBANK_ACTIVE_OFFSET (0x32e0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_WBANK_ACTIVE_MASK (0x1)

// args: data (1-bit)
static __inline uint8_t acamera_isp_fr_uv_dma_writer_wbank_active_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c168L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: frame icount
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// count of incomming frames (starts) to vdma_writer on video input, non resetable, rolls over, updates at pixel 1 of new frame on video in
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_FRAME_ICOUNT_DEFAULT (0x0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_FRAME_ICOUNT_DATASIZE (16)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_FRAME_ICOUNT_OFFSET (0x32ec)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_FRAME_ICOUNT_MASK (0xffff)

// args: data (16-bit)
static __inline uint16_t acamera_isp_fr_uv_dma_writer_frame_icount_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c174L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: frame wcount
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// count of outgoing frame writes (starts) from vdma_writer sent to AXI output, non resetable, rolls over, updates at pixel 1 of new frame on video in
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_FRAME_WCOUNT_DEFAULT (0x0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_FRAME_WCOUNT_DATASIZE (16)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_FRAME_WCOUNT_OFFSET (0x32ec)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_FRAME_WCOUNT_MASK (0xffff0000)

// args: data (16-bit)
static __inline uint16_t acamera_isp_fr_uv_dma_writer_frame_wcount_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c174L) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: axi_fail_bresp
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high to indicate bad  bresp captured 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_FAIL_BRESP_DEFAULT (0x0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_FAIL_BRESP_DATASIZE (1)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_FAIL_BRESP_OFFSET (0x32f4)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_FAIL_BRESP_MASK (0x1)

// args: data (1-bit)
static __inline uint8_t acamera_isp_fr_uv_dma_writer_axi_fail_bresp_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c17cL) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: axi_fail_awmaxwait
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high when awmaxwait_limit reached 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_FAIL_AWMAXWAIT_DEFAULT (0x0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_FAIL_AWMAXWAIT_DATASIZE (1)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_FAIL_AWMAXWAIT_OFFSET (0x32f4)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_FAIL_AWMAXWAIT_MASK (0x2)

// args: data (1-bit)
static __inline uint8_t acamera_isp_fr_uv_dma_writer_axi_fail_awmaxwait_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c17cL) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: axi_fail_wmaxwait
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high when wmaxwait_limit reached 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_FAIL_WMAXWAIT_DEFAULT (0x0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_FAIL_WMAXWAIT_DATASIZE (1)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_FAIL_WMAXWAIT_OFFSET (0x32f4)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_FAIL_WMAXWAIT_MASK (0x4)

// args: data (1-bit)
static __inline uint8_t acamera_isp_fr_uv_dma_writer_axi_fail_wmaxwait_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c17cL) & 0x4) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: axi_fail_wxact_ostand
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high when wxact_ostand_limit reached 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_FAIL_WXACT_OSTAND_DEFAULT (0x0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_FAIL_WXACT_OSTAND_DATASIZE (1)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_FAIL_WXACT_OSTAND_OFFSET (0x32f4)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_FAIL_WXACT_OSTAND_MASK (0x8)

// args: data (1-bit)
static __inline uint8_t acamera_isp_fr_uv_dma_writer_axi_fail_wxact_ostand_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c17cL) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: vi_fail_active_width
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high to indicate mismatched active_width detected 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_VI_FAIL_ACTIVE_WIDTH_DEFAULT (0x0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_VI_FAIL_ACTIVE_WIDTH_DATASIZE (1)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_VI_FAIL_ACTIVE_WIDTH_OFFSET (0x32f4)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_VI_FAIL_ACTIVE_WIDTH_MASK (0x10)

// args: data (1-bit)
static __inline uint8_t acamera_isp_fr_uv_dma_writer_vi_fail_active_width_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c17cL) & 0x10) >> 4);
}
// ------------------------------------------------------------------------------ //
// Register: vi_fail_active_height
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high to indicate mismatched active_height detected ( also raised on missing field!) 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_VI_FAIL_ACTIVE_HEIGHT_DEFAULT (0x0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_VI_FAIL_ACTIVE_HEIGHT_DATASIZE (1)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_VI_FAIL_ACTIVE_HEIGHT_OFFSET (0x32f4)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_VI_FAIL_ACTIVE_HEIGHT_MASK (0x20)

// args: data (1-bit)
static __inline uint8_t acamera_isp_fr_uv_dma_writer_vi_fail_active_height_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c17cL) & 0x20) >> 5);
}
// ------------------------------------------------------------------------------ //
// Register: vi_fail_interline_blanks
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high to indicate interline blanking below min 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_VI_FAIL_INTERLINE_BLANKS_DEFAULT (0x0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_VI_FAIL_INTERLINE_BLANKS_DATASIZE (1)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_VI_FAIL_INTERLINE_BLANKS_OFFSET (0x32f4)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_VI_FAIL_INTERLINE_BLANKS_MASK (0x40)

// args: data (1-bit)
static __inline uint8_t acamera_isp_fr_uv_dma_writer_vi_fail_interline_blanks_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c17cL) & 0x40) >> 6);
}
// ------------------------------------------------------------------------------ //
// Register: vi_fail_interframe_blanks
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high to indicate interframe blanking below min 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_VI_FAIL_INTERFRAME_BLANKS_DEFAULT (0x0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_VI_FAIL_INTERFRAME_BLANKS_DATASIZE (1)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_VI_FAIL_INTERFRAME_BLANKS_OFFSET (0x32f4)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_VI_FAIL_INTERFRAME_BLANKS_MASK (0x80)

// args: data (1-bit)
static __inline uint8_t acamera_isp_fr_uv_dma_writer_vi_fail_interframe_blanks_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c17cL) & 0x80) >> 7);
}
// ------------------------------------------------------------------------------ //
// Register: video_alarm
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  active high, problem found on video port(s) ( active width/height or interline/frame blanks failure) 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_VIDEO_ALARM_DEFAULT (0x0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_VIDEO_ALARM_DATASIZE (1)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_VIDEO_ALARM_OFFSET (0x32f4)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_VIDEO_ALARM_MASK (0x100)

// args: data (1-bit)
static __inline uint8_t acamera_isp_fr_uv_dma_writer_video_alarm_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c17cL) & 0x100) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: blk_status
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        block status output (reserved)
//                          -- blk_status(0) = wfifo_fail_full
//                          -- blk_status(1) = wfifo_fail_empty
//                          -- blk_status(4) = pack_fail_overflow
//                          -- blk_status(24) = intw_fail_user_intfc_sig
//                          -- blk_status(others) =  zero     
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_BLK_STATUS_DEFAULT (0x0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_BLK_STATUS_DATASIZE (32)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_BLK_STATUS_OFFSET (0x32f8)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_BLK_STATUS_MASK (0xffffffff)

// args: data (32-bit)
static __inline uint32_t acamera_isp_fr_uv_dma_writer_blk_status_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1c180L);
}
// ------------------------------------------------------------------------------ //
// Register: lines_wrapped
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Number of lines to write from base address before wrapping back to base address. 0 = no wrapping, >0 = last line written before wrapping
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_LINES_WRAPPED_DEFAULT (0x0000)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_LINES_WRAPPED_DATASIZE (16)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_LINES_WRAPPED_OFFSET (0x32fc)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_LINES_WRAPPED_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_fr_uv_dma_writer_lines_wrapped_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c184L);
    system_sw_write_32(base + 0x1c184L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_fr_uv_dma_writer_lines_wrapped_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c184L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: linetick_first
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Line number of first linetick. 0  = no linetick, >0 = line number to generate linetick 
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_LINETICK_FIRST_DEFAULT (0x0000)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_LINETICK_FIRST_DATASIZE (16)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_LINETICK_FIRST_OFFSET (0x3300)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_LINETICK_FIRST_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_fr_uv_dma_writer_linetick_first_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c188L);
    system_sw_write_32(base + 0x1c188L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_fr_uv_dma_writer_linetick_first_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c188L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: linetick_repeat
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Line repeat interval of linetick. 0 = no repeat, >0 = repeat interval in lines 
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_LINETICK_REPEAT_DEFAULT (0x0000)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_LINETICK_REPEAT_DATASIZE (16)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_LINETICK_REPEAT_OFFSET (0x3304)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_LINETICK_REPEAT_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_fr_uv_dma_writer_linetick_repeat_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c18cL);
    system_sw_write_32(base + 0x1c18cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_fr_uv_dma_writer_linetick_repeat_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c18cL) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: linetick_eol
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Linetick start/end of line control. 0 = use start of line, 1 = use end of line to generate linetick
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_LINETICK_EOL_DEFAULT (0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_LINETICK_EOL_DATASIZE (1)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_LINETICK_EOL_OFFSET (0x3308)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_LINETICK_EOL_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_fr_uv_dma_writer_linetick_eol_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c190L);
    system_sw_write_32(base + 0x1c190L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_fr_uv_dma_writer_linetick_eol_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c190L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: linetick_delay
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Linetick delay in vcke cycles to add to min 3 cycle latency from acl_vi. 0-65535.
//        Must be less than next linetick generation time or count will not mature and no linetick is not produced.
//          --NOTE: linetick delay  can run past end of frame/field and also into next frame!
//          --      Take care maturity time is less than next configured linetick generation postion!
//          --      Take care when changing config between frame too! 
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_LINETICK_DELAY_DEFAULT (0x0000)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_LINETICK_DELAY_DATASIZE (16)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_LINETICK_DELAY_OFFSET (0x3308)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_LINETICK_DELAY_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_fr_uv_dma_writer_linetick_delay_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c190L);
    system_sw_write_32(base + 0x1c190L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_fr_uv_dma_writer_linetick_delay_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c190L) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: pagewarm_on
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        active high, enables posting of pagewarm dummy writes to SMMU for early page translation of upcomming 4K pages. 
//        Recommend SMMU has min 8 page cache to avoid translation miss. Pagewarms are posted as dummy writes with wstrb= 0
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_PAGEWARM_ON_DEFAULT (0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_PAGEWARM_ON_DATASIZE (1)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_PAGEWARM_ON_OFFSET (0x330c)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_PAGEWARM_ON_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_fr_uv_dma_writer_pagewarm_on_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c194L);
    system_sw_write_32(base + 0x1c194L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_fr_uv_dma_writer_pagewarm_on_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c194L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: axi_id_multi
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        0= static value (axi_id_value) for awid/wid, 1 = incrementing value per transaction for awid/wid wrapping to 0 after axi_id_value
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_ID_MULTI_DEFAULT (0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_ID_MULTI_DATASIZE (1)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_ID_MULTI_OFFSET (0x330c)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_ID_MULTI_MASK (0x2)

// args: data (1-bit)
static __inline void acamera_isp_fr_uv_dma_writer_axi_id_multi_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c194L);
    system_sw_write_32(base + 0x1c194L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
}
static __inline uint8_t acamera_isp_fr_uv_dma_writer_axi_id_multi_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c194L) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: axi_burstsplit
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        memory boundary that splits bursts: 0=2Transfers,1=4Transfers,2=8Transfers,3=16Transfers. (for axi_data_w=128,  16transfers=256Bytes). Good default = 11
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_BURSTSPLIT_DEFAULT (0x3)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_BURSTSPLIT_DATASIZE (2)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_BURSTSPLIT_OFFSET (0x330c)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_BURSTSPLIT_MASK (0xc)

// args: data (2-bit)
static __inline void acamera_isp_fr_uv_dma_writer_axi_burstsplit_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c194L);
    system_sw_write_32(base + 0x1c194L, (((uint32_t) (data & 0x3)) << 2) | (curr & 0xfffffff3));
}
static __inline uint8_t acamera_isp_fr_uv_dma_writer_axi_burstsplit_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c194L) & 0xc) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: axi_cache_value
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        value to send for awcache. Good default = 1111
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_CACHE_VALUE_DEFAULT (0xf)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_CACHE_VALUE_DATASIZE (4)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_CACHE_VALUE_OFFSET (0x330c)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_CACHE_VALUE_MASK (0xf00)

// args: data (4-bit)
static __inline void acamera_isp_fr_uv_dma_writer_axi_cache_value_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c194L);
    system_sw_write_32(base + 0x1c194L, (((uint32_t) (data & 0xf)) << 8) | (curr & 0xfffff0ff));
}
static __inline uint8_t acamera_isp_fr_uv_dma_writer_axi_cache_value_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c194L) & 0xf00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: axi_maxostand
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        max outstanding write transactions (bursts) allowed. zero means no maximum(uses internal limit of 2048). 
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_MAXOSTAND_DEFAULT (0x00)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_MAXOSTAND_DATASIZE (8)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_MAXOSTAND_OFFSET (0x330c)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_MAXOSTAND_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_fr_uv_dma_writer_axi_maxostand_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c194L);
    system_sw_write_32(base + 0x1c194L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_fr_uv_dma_writer_axi_maxostand_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c194L) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: axi_max_awlen
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        max value to use for awlen (axi burst length). 0000= max 1 transfer/burst , upto 1111= max 16 transfers/burst
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_MAX_AWLEN_DEFAULT (0xf)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_MAX_AWLEN_DATASIZE (4)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_MAX_AWLEN_OFFSET (0x330c)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_MAX_AWLEN_MASK (0xf000000)

// args: data (4-bit)
static __inline void acamera_isp_fr_uv_dma_writer_axi_max_awlen_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c194L);
    system_sw_write_32(base + 0x1c194L, (((uint32_t) (data & 0xf)) << 24) | (curr & 0xf0ffffff));
}
static __inline uint8_t acamera_isp_fr_uv_dma_writer_axi_max_awlen_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c194L) & 0xf000000) >> 24);
}
// ------------------------------------------------------------------------------ //
// Register: axi_id_value
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        value to send for awid, wid and expected on bid. Good default = 0000
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_ID_VALUE_DEFAULT (0x0)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_ID_VALUE_DATASIZE (4)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_ID_VALUE_OFFSET (0x3310)
#define ACAMERA_ISP_FR_UV_DMA_WRITER_AXI_ID_VALUE_MASK (0xf)

// args: data (4-bit)
static __inline void acamera_isp_fr_uv_dma_writer_axi_id_value_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c198L);
    system_sw_write_32(base + 0x1c198L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
}
static __inline uint8_t acamera_isp_fr_uv_dma_writer_axi_id_value_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c198L) & 0xf) >> 0);
}
// ------------------------------------------------------------------------------ //
// Group: ds crop
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Crop for full resolution output
//      
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Enable crop
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Crop enable: 0=off 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CROP_ENABLE_CROP_DEFAULT (0)
#define ACAMERA_ISP_DS1_CROP_ENABLE_CROP_DATASIZE (1)
#define ACAMERA_ISP_DS1_CROP_ENABLE_CROP_OFFSET (0x3314)
#define ACAMERA_ISP_DS1_CROP_ENABLE_CROP_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_ds1_crop_enable_crop_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c19cL);
    system_sw_write_32(base + 0x1c19cL, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_ds1_crop_enable_crop_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c19cL) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: start x
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Horizontal offset from left side of image in pixels for output crop window
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CROP_START_X_DEFAULT (0x0000)
#define ACAMERA_ISP_DS1_CROP_START_X_DATASIZE (16)
#define ACAMERA_ISP_DS1_CROP_START_X_OFFSET (0x3318)
#define ACAMERA_ISP_DS1_CROP_START_X_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_ds1_crop_start_x_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1a0L);
    system_sw_write_32(base + 0x1c1a0L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_ds1_crop_start_x_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c1a0L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: start y
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Vertical offset from top of image in lines for output crop window
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CROP_START_Y_DEFAULT (0x0000)
#define ACAMERA_ISP_DS1_CROP_START_Y_DATASIZE (16)
#define ACAMERA_ISP_DS1_CROP_START_Y_OFFSET (0x331c)
#define ACAMERA_ISP_DS1_CROP_START_Y_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_ds1_crop_start_y_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1a4L);
    system_sw_write_32(base + 0x1c1a4L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_ds1_crop_start_y_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c1a4L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: size x
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// width of output crop window
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CROP_SIZE_X_DEFAULT (0xffff)
#define ACAMERA_ISP_DS1_CROP_SIZE_X_DATASIZE (16)
#define ACAMERA_ISP_DS1_CROP_SIZE_X_OFFSET (0x3320)
#define ACAMERA_ISP_DS1_CROP_SIZE_X_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_ds1_crop_size_x_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1a8L);
    system_sw_write_32(base + 0x1c1a8L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_ds1_crop_size_x_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c1a8L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: size y
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// height of output crop window
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CROP_SIZE_Y_DEFAULT (0xffff)
#define ACAMERA_ISP_DS1_CROP_SIZE_Y_DATASIZE (16)
#define ACAMERA_ISP_DS1_CROP_SIZE_Y_OFFSET (0x3324)
#define ACAMERA_ISP_DS1_CROP_SIZE_Y_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_ds1_crop_size_y_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1acL);
    system_sw_write_32(base + 0x1c1acL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_ds1_crop_size_y_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c1acL) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Group: ds scaler
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: IRQSTAT
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Downscaler status
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SCALER_IRQSTAT_DEFAULT (0x00)
#define ACAMERA_ISP_DS1_SCALER_IRQSTAT_DATASIZE (8)
#define ACAMERA_ISP_DS1_SCALER_IRQSTAT_OFFSET (0x3328)
#define ACAMERA_ISP_DS1_SCALER_IRQSTAT_MASK (0xff)

// args: data (8-bit)
static __inline uint8_t acamera_isp_ds1_scaler_irqstat_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c1b0L) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Timeout IRQ
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//             0 : No timeout 
//             1 : Timeout on frame done 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SCALER_TIMEOUT_IRQ_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_SCALER_TIMEOUT_IRQ_DATASIZE (1)
#define ACAMERA_ISP_DS1_SCALER_TIMEOUT_IRQ_OFFSET (0x3328)
#define ACAMERA_ISP_DS1_SCALER_TIMEOUT_IRQ_MASK (0x8)

// args: data (1-bit)
static __inline void acamera_isp_ds1_scaler_timeout_irq_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1b0L);
    system_sw_write_32(base + 0x1c1b0L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
}
static __inline uint8_t acamera_isp_ds1_scaler_timeout_irq_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c1b0L) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: Underflow IRQ
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//             0 : No underflow 
//             1 : FIFO underflow has occurred 
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SCALER_UNDERFLOW_IRQ_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_SCALER_UNDERFLOW_IRQ_DATASIZE (1)
#define ACAMERA_ISP_DS1_SCALER_UNDERFLOW_IRQ_OFFSET (0x3328)
#define ACAMERA_ISP_DS1_SCALER_UNDERFLOW_IRQ_MASK (0x4)

// args: data (1-bit)
static __inline void acamera_isp_ds1_scaler_underflow_irq_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1b0L);
    system_sw_write_32(base + 0x1c1b0L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
}
static __inline uint8_t acamera_isp_ds1_scaler_underflow_irq_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c1b0L) & 0x4) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: Overflow IRQ
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//             0 : No overflow 
//             1 : FIFO overflow has occurred
//            
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SCALER_OVERFLOW_IRQ_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_SCALER_OVERFLOW_IRQ_DATASIZE (1)
#define ACAMERA_ISP_DS1_SCALER_OVERFLOW_IRQ_OFFSET (0x3328)
#define ACAMERA_ISP_DS1_SCALER_OVERFLOW_IRQ_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_ds1_scaler_overflow_irq_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1b0L);
    system_sw_write_32(base + 0x1c1b0L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_ds1_scaler_overflow_irq_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c1b0L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Clear Alarms
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Scaler control
//        IRQ CLR bit 
//         0 : In-active 
//         1 : Clear-off IRQ status to 0 
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SCALER_CLEAR_ALARMS_DEFAULT (0)
#define ACAMERA_ISP_DS1_SCALER_CLEAR_ALARMS_DATASIZE (1)
#define ACAMERA_ISP_DS1_SCALER_CLEAR_ALARMS_OFFSET (0x332c)
#define ACAMERA_ISP_DS1_SCALER_CLEAR_ALARMS_MASK (0x8)

// args: data (1-bit)
static __inline void acamera_isp_ds1_scaler_clear_alarms_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1b4L);
    system_sw_write_32(base + 0x1c1b4L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
}
static __inline uint8_t acamera_isp_ds1_scaler_clear_alarms_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c1b4L) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: Timeout Enable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        0 : Timeout disabled.  
//        1 : Timeout enabled.  Automatic frame reset if frame has not completed after anticipated time.
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SCALER_TIMEOUT_ENABLE_DEFAULT (1)
#define ACAMERA_ISP_DS1_SCALER_TIMEOUT_ENABLE_DATASIZE (1)
#define ACAMERA_ISP_DS1_SCALER_TIMEOUT_ENABLE_OFFSET (0x332c)
#define ACAMERA_ISP_DS1_SCALER_TIMEOUT_ENABLE_MASK (0x10)

// args: data (1-bit)
static __inline void acamera_isp_ds1_scaler_timeout_enable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1b4L);
    system_sw_write_32(base + 0x1c1b4L, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
}
static __inline uint8_t acamera_isp_ds1_scaler_timeout_enable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c1b4L) & 0x10) >> 4);
}
// ------------------------------------------------------------------------------ //
// Register: Field in toggle sel
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        0 : Input Field Type = pulse.  
//        1 : Input Field Type = toggle.
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SCALER_FIELD_IN_TOGGLE_SEL_DEFAULT (0)
#define ACAMERA_ISP_DS1_SCALER_FIELD_IN_TOGGLE_SEL_DATASIZE (1)
#define ACAMERA_ISP_DS1_SCALER_FIELD_IN_TOGGLE_SEL_OFFSET (0x332c)
#define ACAMERA_ISP_DS1_SCALER_FIELD_IN_TOGGLE_SEL_MASK (0x20)

// args: data (1-bit)
static __inline void acamera_isp_ds1_scaler_field_in_toggle_sel_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1b4L);
    system_sw_write_32(base + 0x1c1b4L, (((uint32_t) (data & 0x1)) << 5) | (curr & 0xffffffdf));
}
static __inline uint8_t acamera_isp_ds1_scaler_field_in_toggle_sel_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c1b4L) & 0x20) >> 5);
}
// ------------------------------------------------------------------------------ //
// Register: WIDTH
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Input frame width in pixels
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SCALER_WIDTH_DEFAULT (0x780)
#define ACAMERA_ISP_DS1_SCALER_WIDTH_DATASIZE (16)
#define ACAMERA_ISP_DS1_SCALER_WIDTH_OFFSET (0x3330)
#define ACAMERA_ISP_DS1_SCALER_WIDTH_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_ds1_scaler_width_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1b8L);
    system_sw_write_32(base + 0x1c1b8L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_ds1_scaler_width_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c1b8L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: HEIGHT
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Input frame height in lines
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SCALER_HEIGHT_DEFAULT (0x438)
#define ACAMERA_ISP_DS1_SCALER_HEIGHT_DATASIZE (16)
#define ACAMERA_ISP_DS1_SCALER_HEIGHT_OFFSET (0x3334)
#define ACAMERA_ISP_DS1_SCALER_HEIGHT_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_ds1_scaler_height_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1bcL);
    system_sw_write_32(base + 0x1c1bcL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_ds1_scaler_height_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c1bcL) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: OWIDTH
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Output frame width in pixels
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SCALER_OWIDTH_DEFAULT (0x500)
#define ACAMERA_ISP_DS1_SCALER_OWIDTH_DATASIZE (13)
#define ACAMERA_ISP_DS1_SCALER_OWIDTH_OFFSET (0x3338)
#define ACAMERA_ISP_DS1_SCALER_OWIDTH_MASK (0x1fff)

// args: data (13-bit)
static __inline void acamera_isp_ds1_scaler_owidth_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1c0L);
    system_sw_write_32(base + 0x1c1c0L, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
}
static __inline uint16_t acamera_isp_ds1_scaler_owidth_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c1c0L) & 0x1fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: OHEIGHT
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Output frame height in lines
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SCALER_OHEIGHT_DEFAULT (0x2D0)
#define ACAMERA_ISP_DS1_SCALER_OHEIGHT_DATASIZE (16)
#define ACAMERA_ISP_DS1_SCALER_OHEIGHT_OFFSET (0x333c)
#define ACAMERA_ISP_DS1_SCALER_OHEIGHT_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_ds1_scaler_oheight_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1c4L);
    system_sw_write_32(base + 0x1c1c4L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_ds1_scaler_oheight_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c1c4L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: HFILT_TINC
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Horizontal scaling factor equal to the 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SCALER_HFILT_TINC_DEFAULT (0x180000)
#define ACAMERA_ISP_DS1_SCALER_HFILT_TINC_DATASIZE (24)
#define ACAMERA_ISP_DS1_SCALER_HFILT_TINC_OFFSET (0x3340)
#define ACAMERA_ISP_DS1_SCALER_HFILT_TINC_MASK (0xffffff)

// args: data (24-bit)
static __inline void acamera_isp_ds1_scaler_hfilt_tinc_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1c8L);
    system_sw_write_32(base + 0x1c1c8L, (((uint32_t) (data & 0xffffff)) << 0) | (curr & 0xff000000));
}
static __inline uint32_t acamera_isp_ds1_scaler_hfilt_tinc_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x1c1c8L) & 0xffffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: HFILT_COEFSET
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        HFILT Coeff. control.  
//        HFILT_COEFSET[3:0] - Selects horizontal Coef set for scaler.
//            0000 : use set 0
//            0001 : use set 1
//            ...... 
//            1111 : use set 15
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SCALER_HFILT_COEFSET_DEFAULT (0x00)
#define ACAMERA_ISP_DS1_SCALER_HFILT_COEFSET_DATASIZE (4)
#define ACAMERA_ISP_DS1_SCALER_HFILT_COEFSET_OFFSET (0x3344)
#define ACAMERA_ISP_DS1_SCALER_HFILT_COEFSET_MASK (0xf)

// args: data (4-bit)
static __inline void acamera_isp_ds1_scaler_hfilt_coefset_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1ccL);
    system_sw_write_32(base + 0x1c1ccL, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
}
static __inline uint8_t acamera_isp_ds1_scaler_hfilt_coefset_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c1ccL) & 0xf) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: VFILT_TINC
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// VFILT TINC
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SCALER_VFILT_TINC_DEFAULT (0x180000)
#define ACAMERA_ISP_DS1_SCALER_VFILT_TINC_DATASIZE (24)
#define ACAMERA_ISP_DS1_SCALER_VFILT_TINC_OFFSET (0x3348)
#define ACAMERA_ISP_DS1_SCALER_VFILT_TINC_MASK (0xffffff)

// args: data (24-bit)
static __inline void acamera_isp_ds1_scaler_vfilt_tinc_write(uintptr_t base, uint32_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1d0L);
    system_sw_write_32(base + 0x1c1d0L, (((uint32_t) (data & 0xffffff)) << 0) | (curr & 0xff000000));
}
static __inline uint32_t acamera_isp_ds1_scaler_vfilt_tinc_read(uintptr_t base) {
    return (uint32_t)((system_sw_read_32(base + 0x1c1d0L) & 0xffffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: VFILT_COEFSET
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        VFILT Coeff. control
//        FILT_COEFSET[3:0] - Selects vertical Coef set for scaler
//            0000 : use set 0
//            0001 : use set 1
//            ...... 
//            1111 : use set 15
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SCALER_VFILT_COEFSET_DEFAULT (0x00)
#define ACAMERA_ISP_DS1_SCALER_VFILT_COEFSET_DATASIZE (4)
#define ACAMERA_ISP_DS1_SCALER_VFILT_COEFSET_OFFSET (0x334c)
#define ACAMERA_ISP_DS1_SCALER_VFILT_COEFSET_MASK (0xf)

// args: data (4-bit)
static __inline void acamera_isp_ds1_scaler_vfilt_coefset_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1d4L);
    system_sw_write_32(base + 0x1c1d4L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
}
static __inline uint8_t acamera_isp_ds1_scaler_vfilt_coefset_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c1d4L) & 0xf) >> 0);
}
// ------------------------------------------------------------------------------ //
// Group: ds gamma rgb
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Gamma correction
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Enable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Gamma enable: 0=off 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_GAMMA_RGB_ENABLE_DEFAULT (1)
#define ACAMERA_ISP_DS1_GAMMA_RGB_ENABLE_DATASIZE (1)
#define ACAMERA_ISP_DS1_GAMMA_RGB_ENABLE_OFFSET (0x3350)
#define ACAMERA_ISP_DS1_GAMMA_RGB_ENABLE_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_ds1_gamma_rgb_enable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1d8L);
    system_sw_write_32(base + 0x1c1d8L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_ds1_gamma_rgb_enable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c1d8L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: gain_r
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// gain applied to the R chanel in 4.8 format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_GAMMA_RGB_GAIN_R_DEFAULT (0x100)
#define ACAMERA_ISP_DS1_GAMMA_RGB_GAIN_R_DATASIZE (12)
#define ACAMERA_ISP_DS1_GAMMA_RGB_GAIN_R_OFFSET (0x3354)
#define ACAMERA_ISP_DS1_GAMMA_RGB_GAIN_R_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_ds1_gamma_rgb_gain_r_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1dcL);
    system_sw_write_32(base + 0x1c1dcL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_ds1_gamma_rgb_gain_r_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c1dcL) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: gain_g
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// gain applied to the G chanel in 4.8 format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_GAMMA_RGB_GAIN_G_DEFAULT (0x100)
#define ACAMERA_ISP_DS1_GAMMA_RGB_GAIN_G_DATASIZE (12)
#define ACAMERA_ISP_DS1_GAMMA_RGB_GAIN_G_OFFSET (0x3354)
#define ACAMERA_ISP_DS1_GAMMA_RGB_GAIN_G_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_ds1_gamma_rgb_gain_g_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1dcL);
    system_sw_write_32(base + 0x1c1dcL, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_ds1_gamma_rgb_gain_g_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c1dcL) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: gain_b
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// gain applied to the B chanel in 4.8 format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_GAMMA_RGB_GAIN_B_DEFAULT (0x100)
#define ACAMERA_ISP_DS1_GAMMA_RGB_GAIN_B_DATASIZE (12)
#define ACAMERA_ISP_DS1_GAMMA_RGB_GAIN_B_OFFSET (0x3358)
#define ACAMERA_ISP_DS1_GAMMA_RGB_GAIN_B_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_ds1_gamma_rgb_gain_b_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1e0L);
    system_sw_write_32(base + 0x1c1e0L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_ds1_gamma_rgb_gain_b_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c1e0L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: offset_r
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Offset subtracted from the R chanel 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_GAMMA_RGB_OFFSET_R_DEFAULT (0)
#define ACAMERA_ISP_DS1_GAMMA_RGB_OFFSET_R_DATASIZE (12)
#define ACAMERA_ISP_DS1_GAMMA_RGB_OFFSET_R_OFFSET (0x335c)
#define ACAMERA_ISP_DS1_GAMMA_RGB_OFFSET_R_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_ds1_gamma_rgb_offset_r_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1e4L);
    system_sw_write_32(base + 0x1c1e4L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_ds1_gamma_rgb_offset_r_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c1e4L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: offset_g
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Offset subtracted from the G chanel 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_GAMMA_RGB_OFFSET_G_DEFAULT (0)
#define ACAMERA_ISP_DS1_GAMMA_RGB_OFFSET_G_DATASIZE (12)
#define ACAMERA_ISP_DS1_GAMMA_RGB_OFFSET_G_OFFSET (0x335c)
#define ACAMERA_ISP_DS1_GAMMA_RGB_OFFSET_G_MASK (0xfff0000)

// args: data (12-bit)
static __inline void acamera_isp_ds1_gamma_rgb_offset_g_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1e4L);
    system_sw_write_32(base + 0x1c1e4L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
}
static __inline uint16_t acamera_isp_ds1_gamma_rgb_offset_g_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c1e4L) & 0xfff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: offset_b
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Offset subtracted from the B chanel 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_GAMMA_RGB_OFFSET_B_DEFAULT (0)
#define ACAMERA_ISP_DS1_GAMMA_RGB_OFFSET_B_DATASIZE (12)
#define ACAMERA_ISP_DS1_GAMMA_RGB_OFFSET_B_OFFSET (0x3360)
#define ACAMERA_ISP_DS1_GAMMA_RGB_OFFSET_B_MASK (0xfff)

// args: data (12-bit)
static __inline void acamera_isp_ds1_gamma_rgb_offset_b_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1e8L);
    system_sw_write_32(base + 0x1c1e8L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
}
static __inline uint16_t acamera_isp_ds1_gamma_rgb_offset_b_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c1e8L) & 0xfff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Group: ds sharpen
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Sharpen
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Enable
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Sharpening enable: 0=off, 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SHARPEN_ENABLE_DEFAULT (0)
#define ACAMERA_ISP_DS1_SHARPEN_ENABLE_DATASIZE (1)
#define ACAMERA_ISP_DS1_SHARPEN_ENABLE_OFFSET (0x3364)
#define ACAMERA_ISP_DS1_SHARPEN_ENABLE_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_ds1_sharpen_enable_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1ecL);
    system_sw_write_32(base + 0x1c1ecL, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_ds1_sharpen_enable_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c1ecL) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Strength
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Controls strength of sharpening effect. u5.4
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SHARPEN_STRENGTH_DEFAULT (0x10)
#define ACAMERA_ISP_DS1_SHARPEN_STRENGTH_DATASIZE (9)
#define ACAMERA_ISP_DS1_SHARPEN_STRENGTH_OFFSET (0x3368)
#define ACAMERA_ISP_DS1_SHARPEN_STRENGTH_MASK (0x1ff)

// args: data (9-bit)
static __inline void acamera_isp_ds1_sharpen_strength_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1f0L);
    system_sw_write_32(base + 0x1c1f0L, (((uint32_t) (data & 0x1ff)) << 0) | (curr & 0xfffffe00));
}
static __inline uint16_t acamera_isp_ds1_sharpen_strength_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c1f0L) & 0x1ff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Control R
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SHARPEN_CONTROL_R_DEFAULT (0x4C)
#define ACAMERA_ISP_DS1_SHARPEN_CONTROL_R_DATASIZE (8)
#define ACAMERA_ISP_DS1_SHARPEN_CONTROL_R_OFFSET (0x336c)
#define ACAMERA_ISP_DS1_SHARPEN_CONTROL_R_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_ds1_sharpen_control_r_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1f4L);
    system_sw_write_32(base + 0x1c1f4L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_ds1_sharpen_control_r_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c1f4L) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
//  Luma transform red coefficient. u0.8 
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Control B
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SHARPEN_CONTROL_B_DEFAULT (0x1E)
#define ACAMERA_ISP_DS1_SHARPEN_CONTROL_B_DATASIZE (8)
#define ACAMERA_ISP_DS1_SHARPEN_CONTROL_B_OFFSET (0x336c)
#define ACAMERA_ISP_DS1_SHARPEN_CONTROL_B_MASK (0xff00)

// args: data (8-bit)
static __inline void acamera_isp_ds1_sharpen_control_b_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1f4L);
    system_sw_write_32(base + 0x1c1f4L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
}
static __inline uint8_t acamera_isp_ds1_sharpen_control_b_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c1f4L) & 0xff00) >> 8);
}
// ------------------------------------------------------------------------------ //
//  Luma transform blue coefficient. u0.8 
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Alpha Undershoot
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Alpha blending of undershoot and overshoot u0.7, 0 = only unsershoot, 255 = only overshoot
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SHARPEN_ALPHA_UNDERSHOOT_DEFAULT (0x13)
#define ACAMERA_ISP_DS1_SHARPEN_ALPHA_UNDERSHOOT_DATASIZE (8)
#define ACAMERA_ISP_DS1_SHARPEN_ALPHA_UNDERSHOOT_OFFSET (0x336c)
#define ACAMERA_ISP_DS1_SHARPEN_ALPHA_UNDERSHOOT_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_ds1_sharpen_alpha_undershoot_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1f4L);
    system_sw_write_32(base + 0x1c1f4L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_ds1_sharpen_alpha_undershoot_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c1f4L) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Luma Thresh Low
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Luma threshold below this value, no sharpening will be applied. 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SHARPEN_LUMA_THRESH_LOW_DEFAULT (0x000)
#define ACAMERA_ISP_DS1_SHARPEN_LUMA_THRESH_LOW_DATASIZE (10)
#define ACAMERA_ISP_DS1_SHARPEN_LUMA_THRESH_LOW_OFFSET (0x3370)
#define ACAMERA_ISP_DS1_SHARPEN_LUMA_THRESH_LOW_MASK (0x3ff)

// args: data (10-bit)
static __inline void acamera_isp_ds1_sharpen_luma_thresh_low_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1f8L);
    system_sw_write_32(base + 0x1c1f8L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
}
static __inline uint16_t acamera_isp_ds1_sharpen_luma_thresh_low_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c1f8L) & 0x3ff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Luma Offset Low
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Luma offset (min value) of thre region of less than Luma Thresh Low.  
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SHARPEN_LUMA_OFFSET_LOW_DEFAULT (0x000)
#define ACAMERA_ISP_DS1_SHARPEN_LUMA_OFFSET_LOW_DATASIZE (8)
#define ACAMERA_ISP_DS1_SHARPEN_LUMA_OFFSET_LOW_OFFSET (0x3370)
#define ACAMERA_ISP_DS1_SHARPEN_LUMA_OFFSET_LOW_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_ds1_sharpen_luma_offset_low_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1f8L);
    system_sw_write_32(base + 0x1c1f8L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_ds1_sharpen_luma_offset_low_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c1f8L) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Luma Slope Low
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Luma linear threshold slope at dark luminance region 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SHARPEN_LUMA_SLOPE_LOW_DEFAULT (0x03FC)
#define ACAMERA_ISP_DS1_SHARPEN_LUMA_SLOPE_LOW_DATASIZE (16)
#define ACAMERA_ISP_DS1_SHARPEN_LUMA_SLOPE_LOW_OFFSET (0x3374)
#define ACAMERA_ISP_DS1_SHARPEN_LUMA_SLOPE_LOW_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_ds1_sharpen_luma_slope_low_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1fcL);
    system_sw_write_32(base + 0x1c1fcL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_ds1_sharpen_luma_slope_low_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c1fcL) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Luma Thresh High
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Luma threshold above this value, sharpening level will be dicreased. 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SHARPEN_LUMA_THRESH_HIGH_DEFAULT (0x332)
#define ACAMERA_ISP_DS1_SHARPEN_LUMA_THRESH_HIGH_DATASIZE (10)
#define ACAMERA_ISP_DS1_SHARPEN_LUMA_THRESH_HIGH_OFFSET (0x3374)
#define ACAMERA_ISP_DS1_SHARPEN_LUMA_THRESH_HIGH_MASK (0x3ff0000)

// args: data (10-bit)
static __inline void acamera_isp_ds1_sharpen_luma_thresh_high_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c1fcL);
    system_sw_write_32(base + 0x1c1fcL, (((uint32_t) (data & 0x3ff)) << 16) | (curr & 0xfc00ffff));
}
static __inline uint16_t acamera_isp_ds1_sharpen_luma_thresh_high_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c1fcL) & 0x3ff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Luma Offset High
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Luma offset (min value) of thre region of more than Luma Thresh High.  
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SHARPEN_LUMA_OFFSET_HIGH_DEFAULT (0x000)
#define ACAMERA_ISP_DS1_SHARPEN_LUMA_OFFSET_HIGH_DATASIZE (8)
#define ACAMERA_ISP_DS1_SHARPEN_LUMA_OFFSET_HIGH_OFFSET (0x3378)
#define ACAMERA_ISP_DS1_SHARPEN_LUMA_OFFSET_HIGH_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_ds1_sharpen_luma_offset_high_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c200L);
    system_sw_write_32(base + 0x1c200L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_ds1_sharpen_luma_offset_high_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c200L) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Luma Slope High
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  Luma linear threshold slope at bright luminance region 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SHARPEN_LUMA_SLOPE_HIGH_DEFAULT (0x06A4)
#define ACAMERA_ISP_DS1_SHARPEN_LUMA_SLOPE_HIGH_DATASIZE (16)
#define ACAMERA_ISP_DS1_SHARPEN_LUMA_SLOPE_HIGH_OFFSET (0x3378)
#define ACAMERA_ISP_DS1_SHARPEN_LUMA_SLOPE_HIGH_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_ds1_sharpen_luma_slope_high_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c200L);
    system_sw_write_32(base + 0x1c200L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_ds1_sharpen_luma_slope_high_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c200L) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Clip Str Max
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clips sharpening mask of max value. This will control overshoot. U0.14. (0 ~ 16383) 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SHARPEN_CLIP_STR_MAX_DEFAULT (0x3FFF)
#define ACAMERA_ISP_DS1_SHARPEN_CLIP_STR_MAX_DATASIZE (14)
#define ACAMERA_ISP_DS1_SHARPEN_CLIP_STR_MAX_OFFSET (0x337c)
#define ACAMERA_ISP_DS1_SHARPEN_CLIP_STR_MAX_MASK (0x3fff)

// args: data (14-bit)
static __inline void acamera_isp_ds1_sharpen_clip_str_max_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c204L);
    system_sw_write_32(base + 0x1c204L, (((uint32_t) (data & 0x3fff)) << 0) | (curr & 0xffffc000));
}
static __inline uint16_t acamera_isp_ds1_sharpen_clip_str_max_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c204L) & 0x3fff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Clip Str Min
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clips sharpening mask of min value. This will control undershoot. U0.14. It is used as negative value. (0 ~ -16383)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SHARPEN_CLIP_STR_MIN_DEFAULT (0x00CD)
#define ACAMERA_ISP_DS1_SHARPEN_CLIP_STR_MIN_DATASIZE (14)
#define ACAMERA_ISP_DS1_SHARPEN_CLIP_STR_MIN_OFFSET (0x337c)
#define ACAMERA_ISP_DS1_SHARPEN_CLIP_STR_MIN_MASK (0x3fff0000)

// args: data (14-bit)
static __inline void acamera_isp_ds1_sharpen_clip_str_min_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c204L);
    system_sw_write_32(base + 0x1c204L, (((uint32_t) (data & 0x3fff)) << 16) | (curr & 0xc000ffff));
}
static __inline uint16_t acamera_isp_ds1_sharpen_clip_str_min_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c204L) & 0x3fff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: Debug
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  To support different debug output. 0 = normal operation, 1 = luma, 2 = sharpening mask 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_SHARPEN_DEBUG_DEFAULT (0)
#define ACAMERA_ISP_DS1_SHARPEN_DEBUG_DATASIZE (4)
#define ACAMERA_ISP_DS1_SHARPEN_DEBUG_OFFSET (0x3380)
#define ACAMERA_ISP_DS1_SHARPEN_DEBUG_MASK (0xf)

// args: data (4-bit)
static __inline void acamera_isp_ds1_sharpen_debug_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c208L);
    system_sw_write_32(base + 0x1c208L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
}
static __inline uint8_t acamera_isp_ds1_sharpen_debug_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c208L) & 0xf) >> 0);
}
// ------------------------------------------------------------------------------ //
// Group: ds cs conv
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Conversion of RGB to YUV data using a 3x3 color matrix plus offsets
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Enable matrix
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Color matrix enable: 0=off 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CS_CONV_ENABLE_MATRIX_DEFAULT (0)
#define ACAMERA_ISP_DS1_CS_CONV_ENABLE_MATRIX_DATASIZE (1)
#define ACAMERA_ISP_DS1_CS_CONV_ENABLE_MATRIX_OFFSET (0x3384)
#define ACAMERA_ISP_DS1_CS_CONV_ENABLE_MATRIX_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_ds1_cs_conv_enable_matrix_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c20cL);
    system_sw_write_32(base + 0x1c20cL, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_ds1_cs_conv_enable_matrix_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c20cL) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Enable filter
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Filter enable: 0=off 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CS_CONV_ENABLE_FILTER_DEFAULT (0)
#define ACAMERA_ISP_DS1_CS_CONV_ENABLE_FILTER_DATASIZE (1)
#define ACAMERA_ISP_DS1_CS_CONV_ENABLE_FILTER_OFFSET (0x3384)
#define ACAMERA_ISP_DS1_CS_CONV_ENABLE_FILTER_MASK (0x2)

// args: data (1-bit)
static __inline void acamera_isp_ds1_cs_conv_enable_filter_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c20cL);
    system_sw_write_32(base + 0x1c20cL, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
}
static __inline uint8_t acamera_isp_ds1_cs_conv_enable_filter_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c20cL) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: Enable horizontal downsample
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Horizontal Downsampling Enable: 0=off 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CS_CONV_ENABLE_HORIZONTAL_DOWNSAMPLE_DEFAULT (0)
#define ACAMERA_ISP_DS1_CS_CONV_ENABLE_HORIZONTAL_DOWNSAMPLE_DATASIZE (1)
#define ACAMERA_ISP_DS1_CS_CONV_ENABLE_HORIZONTAL_DOWNSAMPLE_OFFSET (0x3384)
#define ACAMERA_ISP_DS1_CS_CONV_ENABLE_HORIZONTAL_DOWNSAMPLE_MASK (0x4)

// args: data (1-bit)
static __inline void acamera_isp_ds1_cs_conv_enable_horizontal_downsample_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c20cL);
    system_sw_write_32(base + 0x1c20cL, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
}
static __inline uint8_t acamera_isp_ds1_cs_conv_enable_horizontal_downsample_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c20cL) & 0x4) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: Enable vertical downsample
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Vertical Downsampling Enable: 0=off 1=on
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CS_CONV_ENABLE_VERTICAL_DOWNSAMPLE_DEFAULT (0)
#define ACAMERA_ISP_DS1_CS_CONV_ENABLE_VERTICAL_DOWNSAMPLE_DATASIZE (1)
#define ACAMERA_ISP_DS1_CS_CONV_ENABLE_VERTICAL_DOWNSAMPLE_OFFSET (0x3384)
#define ACAMERA_ISP_DS1_CS_CONV_ENABLE_VERTICAL_DOWNSAMPLE_MASK (0x8)

// args: data (1-bit)
static __inline void acamera_isp_ds1_cs_conv_enable_vertical_downsample_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c20cL);
    system_sw_write_32(base + 0x1c20cL, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
}
static __inline uint8_t acamera_isp_ds1_cs_conv_enable_vertical_downsample_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c20cL) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft 11
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for R-Y multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_11_DEFAULT (0x002f)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_11_DATASIZE (16)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_11_OFFSET (0x3388)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_11_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_ds1_cs_conv_coefft_11_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c210L);
    system_sw_write_32(base + 0x1c210L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_ds1_cs_conv_coefft_11_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c210L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft 12
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for G-Y multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_12_DEFAULT (0x009d)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_12_DATASIZE (16)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_12_OFFSET (0x338c)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_12_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_ds1_cs_conv_coefft_12_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c214L);
    system_sw_write_32(base + 0x1c214L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_ds1_cs_conv_coefft_12_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c214L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft 13
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for B-Y multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_13_DEFAULT (0x0010)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_13_DATASIZE (16)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_13_OFFSET (0x3390)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_13_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_ds1_cs_conv_coefft_13_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c218L);
    system_sw_write_32(base + 0x1c218L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_ds1_cs_conv_coefft_13_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c218L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft 21
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for R-Cb multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_21_DEFAULT (0x801a)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_21_DATASIZE (16)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_21_OFFSET (0x3394)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_21_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_ds1_cs_conv_coefft_21_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c21cL);
    system_sw_write_32(base + 0x1c21cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_ds1_cs_conv_coefft_21_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c21cL) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft 22
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for G-Cb multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_22_DEFAULT (0x8057)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_22_DATASIZE (16)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_22_OFFSET (0x3398)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_22_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_ds1_cs_conv_coefft_22_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c220L);
    system_sw_write_32(base + 0x1c220L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_ds1_cs_conv_coefft_22_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c220L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft 23
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for B-Cb multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_23_DEFAULT (0x0070)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_23_DATASIZE (16)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_23_OFFSET (0x339c)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_23_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_ds1_cs_conv_coefft_23_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c224L);
    system_sw_write_32(base + 0x1c224L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_ds1_cs_conv_coefft_23_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c224L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft 31
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for R-Cr multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_31_DEFAULT (0x0070)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_31_DATASIZE (16)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_31_OFFSET (0x33a0)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_31_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_ds1_cs_conv_coefft_31_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c228L);
    system_sw_write_32(base + 0x1c228L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_ds1_cs_conv_coefft_31_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c228L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft 32
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for G-Cr multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_32_DEFAULT (0x8066)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_32_DATASIZE (16)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_32_OFFSET (0x33a4)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_32_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_ds1_cs_conv_coefft_32_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c22cL);
    system_sw_write_32(base + 0x1c22cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_ds1_cs_conv_coefft_32_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c22cL) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft 33
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Matrix coefficient for B-Cr multiplier
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_33_DEFAULT (0x800a)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_33_DATASIZE (16)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_33_OFFSET (0x33a8)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_33_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_ds1_cs_conv_coefft_33_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c230L);
    system_sw_write_32(base + 0x1c230L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_ds1_cs_conv_coefft_33_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c230L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft o1
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Offset for Y
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_O1_DEFAULT (0x000)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_O1_DATASIZE (11)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_O1_OFFSET (0x33ac)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_O1_MASK (0x7ff)

// args: data (11-bit)
static __inline void acamera_isp_ds1_cs_conv_coefft_o1_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c234L);
    system_sw_write_32(base + 0x1c234L, (((uint32_t) (data & 0x7ff)) << 0) | (curr & 0xfffff800));
}
static __inline uint16_t acamera_isp_ds1_cs_conv_coefft_o1_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c234L) & 0x7ff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft o2
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Offset for Cb
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_O2_DEFAULT (0x200)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_O2_DATASIZE (11)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_O2_OFFSET (0x33b0)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_O2_MASK (0x7ff)

// args: data (11-bit)
static __inline void acamera_isp_ds1_cs_conv_coefft_o2_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c238L);
    system_sw_write_32(base + 0x1c238L, (((uint32_t) (data & 0x7ff)) << 0) | (curr & 0xfffff800));
}
static __inline uint16_t acamera_isp_ds1_cs_conv_coefft_o2_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c238L) & 0x7ff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Coefft o3
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Offset for Cr
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_O3_DEFAULT (0x200)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_O3_DATASIZE (11)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_O3_OFFSET (0x33b4)
#define ACAMERA_ISP_DS1_CS_CONV_COEFFT_O3_MASK (0x7ff)

// args: data (11-bit)
static __inline void acamera_isp_ds1_cs_conv_coefft_o3_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c23cL);
    system_sw_write_32(base + 0x1c23cL, (((uint32_t) (data & 0x7ff)) << 0) | (curr & 0xfffff800));
}
static __inline uint16_t acamera_isp_ds1_cs_conv_coefft_o3_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c23cL) & 0x7ff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Clip min Y
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Minimal value for Y.  Values below this are clipped.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CS_CONV_CLIP_MIN_Y_DEFAULT (0x000)
#define ACAMERA_ISP_DS1_CS_CONV_CLIP_MIN_Y_DATASIZE (10)
#define ACAMERA_ISP_DS1_CS_CONV_CLIP_MIN_Y_OFFSET (0x33b8)
#define ACAMERA_ISP_DS1_CS_CONV_CLIP_MIN_Y_MASK (0x3ff)

// args: data (10-bit)
static __inline void acamera_isp_ds1_cs_conv_clip_min_y_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c240L);
    system_sw_write_32(base + 0x1c240L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
}
static __inline uint16_t acamera_isp_ds1_cs_conv_clip_min_y_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c240L) & 0x3ff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Clip max Y
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Maximal value for Y.  Values above this are clipped.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CS_CONV_CLIP_MAX_Y_DEFAULT (0x3FF)
#define ACAMERA_ISP_DS1_CS_CONV_CLIP_MAX_Y_DATASIZE (10)
#define ACAMERA_ISP_DS1_CS_CONV_CLIP_MAX_Y_OFFSET (0x33bc)
#define ACAMERA_ISP_DS1_CS_CONV_CLIP_MAX_Y_MASK (0x3ff)

// args: data (10-bit)
static __inline void acamera_isp_ds1_cs_conv_clip_max_y_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c244L);
    system_sw_write_32(base + 0x1c244L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
}
static __inline uint16_t acamera_isp_ds1_cs_conv_clip_max_y_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c244L) & 0x3ff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Clip min UV
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Minimal value for Cb, Cr.  Values below this are clipped.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CS_CONV_CLIP_MIN_UV_DEFAULT (0x000)
#define ACAMERA_ISP_DS1_CS_CONV_CLIP_MIN_UV_DATASIZE (10)
#define ACAMERA_ISP_DS1_CS_CONV_CLIP_MIN_UV_OFFSET (0x33c0)
#define ACAMERA_ISP_DS1_CS_CONV_CLIP_MIN_UV_MASK (0x3ff)

// args: data (10-bit)
static __inline void acamera_isp_ds1_cs_conv_clip_min_uv_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c248L);
    system_sw_write_32(base + 0x1c248L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
}
static __inline uint16_t acamera_isp_ds1_cs_conv_clip_min_uv_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c248L) & 0x3ff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Clip max UV
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Maximal value for Cb, Cr.  Values above this are clipped.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CS_CONV_CLIP_MAX_UV_DEFAULT (0x3FF)
#define ACAMERA_ISP_DS1_CS_CONV_CLIP_MAX_UV_DATASIZE (10)
#define ACAMERA_ISP_DS1_CS_CONV_CLIP_MAX_UV_OFFSET (0x33c4)
#define ACAMERA_ISP_DS1_CS_CONV_CLIP_MAX_UV_MASK (0x3ff)

// args: data (10-bit)
static __inline void acamera_isp_ds1_cs_conv_clip_max_uv_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c24cL);
    system_sw_write_32(base + 0x1c24cL, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
}
static __inline uint16_t acamera_isp_ds1_cs_conv_clip_max_uv_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c24cL) & 0x3ff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Data mask RY
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Data mask for channel 1 (R or Y).  Bit-wise and of this value and video data. 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CS_CONV_DATA_MASK_RY_DEFAULT (0x3FF)
#define ACAMERA_ISP_DS1_CS_CONV_DATA_MASK_RY_DATASIZE (10)
#define ACAMERA_ISP_DS1_CS_CONV_DATA_MASK_RY_OFFSET (0x33c8)
#define ACAMERA_ISP_DS1_CS_CONV_DATA_MASK_RY_MASK (0x3ff)

// args: data (10-bit)
static __inline void acamera_isp_ds1_cs_conv_data_mask_ry_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c250L);
    system_sw_write_32(base + 0x1c250L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
}
static __inline uint16_t acamera_isp_ds1_cs_conv_data_mask_ry_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c250L) & 0x3ff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Data mask GU
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Data mask for channel 2 (G or U).  Bit-wise and of this value and video data.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CS_CONV_DATA_MASK_GU_DEFAULT (0x3FF)
#define ACAMERA_ISP_DS1_CS_CONV_DATA_MASK_GU_DATASIZE (10)
#define ACAMERA_ISP_DS1_CS_CONV_DATA_MASK_GU_OFFSET (0x33cc)
#define ACAMERA_ISP_DS1_CS_CONV_DATA_MASK_GU_MASK (0x3ff)

// args: data (10-bit)
static __inline void acamera_isp_ds1_cs_conv_data_mask_gu_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c254L);
    system_sw_write_32(base + 0x1c254L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
}
static __inline uint16_t acamera_isp_ds1_cs_conv_data_mask_gu_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c254L) & 0x3ff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Data mask BV
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Data mask for channel 3 (B or V).  Bit-wise and of this value and video data.
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CS_CONV_DATA_MASK_BV_DEFAULT (0x3FF)
#define ACAMERA_ISP_DS1_CS_CONV_DATA_MASK_BV_DATASIZE (10)
#define ACAMERA_ISP_DS1_CS_CONV_DATA_MASK_BV_OFFSET (0x33d0)
#define ACAMERA_ISP_DS1_CS_CONV_DATA_MASK_BV_MASK (0x3ff)

// args: data (10-bit)
static __inline void acamera_isp_ds1_cs_conv_data_mask_bv_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c258L);
    system_sw_write_32(base + 0x1c258L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
}
static __inline uint16_t acamera_isp_ds1_cs_conv_data_mask_bv_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c258L) & 0x3ff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Group: ds cs conv dither
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Enable dither
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Enables dithering module
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CS_CONV_DITHER_ENABLE_DITHER_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_CS_CONV_DITHER_ENABLE_DITHER_DATASIZE (1)
#define ACAMERA_ISP_DS1_CS_CONV_DITHER_ENABLE_DITHER_OFFSET (0x33d4)
#define ACAMERA_ISP_DS1_CS_CONV_DITHER_ENABLE_DITHER_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_ds1_cs_conv_dither_enable_dither_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c25cL);
    system_sw_write_32(base + 0x1c25cL, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_ds1_cs_conv_dither_enable_dither_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c25cL) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Dither amount
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0= dither to 9 bits; 1=dither to 8 bits; 2=dither to 7 bits; 3=dither to 6 bits 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CS_CONV_DITHER_DITHER_AMOUNT_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_CS_CONV_DITHER_DITHER_AMOUNT_DATASIZE (2)
#define ACAMERA_ISP_DS1_CS_CONV_DITHER_DITHER_AMOUNT_OFFSET (0x33d4)
#define ACAMERA_ISP_DS1_CS_CONV_DITHER_DITHER_AMOUNT_MASK (0x6)

// args: data (2-bit)
static __inline void acamera_isp_ds1_cs_conv_dither_dither_amount_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c25cL);
    system_sw_write_32(base + 0x1c25cL, (((uint32_t) (data & 0x3)) << 1) | (curr & 0xfffffff9));
}
static __inline uint8_t acamera_isp_ds1_cs_conv_dither_dither_amount_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c25cL) & 0x6) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: Shift mode
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0= output is LSB aligned; 1=output is MSB aligned
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_CS_CONV_DITHER_SHIFT_MODE_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_CS_CONV_DITHER_SHIFT_MODE_DATASIZE (1)
#define ACAMERA_ISP_DS1_CS_CONV_DITHER_SHIFT_MODE_OFFSET (0x33d4)
#define ACAMERA_ISP_DS1_CS_CONV_DITHER_SHIFT_MODE_MASK (0x10)

// args: data (1-bit)
static __inline void acamera_isp_ds1_cs_conv_dither_shift_mode_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c25cL);
    system_sw_write_32(base + 0x1c25cL, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
}
static __inline uint8_t acamera_isp_ds1_cs_conv_dither_shift_mode_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c25cL) & 0x10) >> 4);
}
// ------------------------------------------------------------------------------ //
// Group: ds dma writer
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// DMA writer controls
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Format
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_FORMAT_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_DMA_WRITER_FORMAT_DATASIZE (8)
#define ACAMERA_ISP_DS1_DMA_WRITER_FORMAT_OFFSET (0x33d8)
#define ACAMERA_ISP_DS1_DMA_WRITER_FORMAT_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_ds1_dma_writer_format_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c260L);
    system_sw_write_32(base + 0x1c260L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_ds1_dma_writer_format_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c260L) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Base mode
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Base DMA packing mode for RGB/RAW/YUV etc (see ISP guide)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_BASE_MODE_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_DMA_WRITER_BASE_MODE_DATASIZE (5)
#define ACAMERA_ISP_DS1_DMA_WRITER_BASE_MODE_OFFSET (0x33d8)
#define ACAMERA_ISP_DS1_DMA_WRITER_BASE_MODE_MASK (0x1f)

// args: data (5-bit)
static __inline void acamera_isp_ds1_dma_writer_base_mode_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c260L);
    system_sw_write_32(base + 0x1c260L, (((uint32_t) (data & 0x1f)) << 0) | (curr & 0xffffffe0));
}
static __inline uint8_t acamera_isp_ds1_dma_writer_base_mode_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c260L) & 0x1f) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Plane select
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Plane select for planar base modes.  Only used if planar outputs required.  Not used.  Should be set to 0
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_PLANE_SELECT_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_DMA_WRITER_PLANE_SELECT_DATASIZE (2)
#define ACAMERA_ISP_DS1_DMA_WRITER_PLANE_SELECT_OFFSET (0x33d8)
#define ACAMERA_ISP_DS1_DMA_WRITER_PLANE_SELECT_MASK (0xc0)

// args: data (2-bit)
static __inline void acamera_isp_ds1_dma_writer_plane_select_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c260L);
    system_sw_write_32(base + 0x1c260L, (((uint32_t) (data & 0x3)) << 6) | (curr & 0xffffff3f));
}
static __inline uint8_t acamera_isp_ds1_dma_writer_plane_select_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c260L) & 0xc0) >> 6);
}
// ------------------------------------------------------------------------------ //
// Register: single frame
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0 = All frames are written(after frame_write_on= 1), 1= only 1st frame written ( after frame_write_on =1)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_SINGLE_FRAME_DEFAULT (0)
#define ACAMERA_ISP_DS1_DMA_WRITER_SINGLE_FRAME_DATASIZE (1)
#define ACAMERA_ISP_DS1_DMA_WRITER_SINGLE_FRAME_OFFSET (0x33d8)
#define ACAMERA_ISP_DS1_DMA_WRITER_SINGLE_FRAME_MASK (0x100)

// args: data (1-bit)
static __inline void acamera_isp_ds1_dma_writer_single_frame_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c260L);
    system_sw_write_32(base + 0x1c260L, (((uint32_t) (data & 0x1)) << 8) | (curr & 0xfffffeff));
}
static __inline uint8_t acamera_isp_ds1_dma_writer_single_frame_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c260L) & 0x100) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: frame write on
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        0 = no frames written(when switched from 1, current frame completes writing before stopping),
//        1= write frame(s) (write single or continous frame(s) )
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_FRAME_WRITE_ON_DEFAULT (0)
#define ACAMERA_ISP_DS1_DMA_WRITER_FRAME_WRITE_ON_DATASIZE (1)
#define ACAMERA_ISP_DS1_DMA_WRITER_FRAME_WRITE_ON_OFFSET (0x33d8)
#define ACAMERA_ISP_DS1_DMA_WRITER_FRAME_WRITE_ON_MASK (0x200)

// args: data (1-bit)
static __inline void acamera_isp_ds1_dma_writer_frame_write_on_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c260L);
    system_sw_write_32(base + 0x1c260L, (((uint32_t) (data & 0x1)) << 9) | (curr & 0xfffffdff));
}
static __inline uint8_t acamera_isp_ds1_dma_writer_frame_write_on_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c260L) & 0x200) >> 9);
}
// ------------------------------------------------------------------------------ //
// Register: axi xact comp
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0 = dont wait for axi transaction completion at end of frame(just all transfers accepted). 1 = wait for all transactions completed
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_XACT_COMP_DEFAULT (0)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_XACT_COMP_DATASIZE (1)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_XACT_COMP_OFFSET (0x33d8)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_XACT_COMP_MASK (0x800)

// args: data (1-bit)
static __inline void acamera_isp_ds1_dma_writer_axi_xact_comp_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c260L);
    system_sw_write_32(base + 0x1c260L, (((uint32_t) (data & 0x1)) << 11) | (curr & 0xfffff7ff));
}
static __inline uint8_t acamera_isp_ds1_dma_writer_axi_xact_comp_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c260L) & 0x800) >> 11);
}
// ------------------------------------------------------------------------------ //
// Register: active width
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Active video width in pixels 128-8000
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_ACTIVE_WIDTH_DEFAULT (0x780)
#define ACAMERA_ISP_DS1_DMA_WRITER_ACTIVE_WIDTH_DATASIZE (16)
#define ACAMERA_ISP_DS1_DMA_WRITER_ACTIVE_WIDTH_OFFSET (0x33dc)
#define ACAMERA_ISP_DS1_DMA_WRITER_ACTIVE_WIDTH_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_ds1_dma_writer_active_width_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c264L);
    system_sw_write_32(base + 0x1c264L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_ds1_dma_writer_active_width_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c264L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: active height
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Active video height in lines 128-8000
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_ACTIVE_HEIGHT_DEFAULT (0x438)
#define ACAMERA_ISP_DS1_DMA_WRITER_ACTIVE_HEIGHT_DATASIZE (16)
#define ACAMERA_ISP_DS1_DMA_WRITER_ACTIVE_HEIGHT_OFFSET (0x33dc)
#define ACAMERA_ISP_DS1_DMA_WRITER_ACTIVE_HEIGHT_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_ds1_dma_writer_active_height_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c264L);
    system_sw_write_32(base + 0x1c264L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_ds1_dma_writer_active_height_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c264L) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: bank0_base
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// bank 0 base address for frame buffer, should be word-aligned
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_BANK0_BASE_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_DMA_WRITER_BANK0_BASE_DATASIZE (32)
#define ACAMERA_ISP_DS1_DMA_WRITER_BANK0_BASE_OFFSET (0x33e0)
#define ACAMERA_ISP_DS1_DMA_WRITER_BANK0_BASE_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_ds1_dma_writer_bank0_base_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1c268L, data);
}
static __inline uint32_t acamera_isp_ds1_dma_writer_bank0_base_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1c268L);
}
// ------------------------------------------------------------------------------ //
// Register: bank1_base
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// bank 1 base address for frame buffer, should be word-aligned
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_BANK1_BASE_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_DMA_WRITER_BANK1_BASE_DATASIZE (32)
#define ACAMERA_ISP_DS1_DMA_WRITER_BANK1_BASE_OFFSET (0x33e4)
#define ACAMERA_ISP_DS1_DMA_WRITER_BANK1_BASE_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_ds1_dma_writer_bank1_base_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1c26cL, data);
}
static __inline uint32_t acamera_isp_ds1_dma_writer_bank1_base_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1c26cL);
}
// ------------------------------------------------------------------------------ //
// Register: bank2_base
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// bank 2 base address for frame buffer, should be word-aligned
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_BANK2_BASE_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_DMA_WRITER_BANK2_BASE_DATASIZE (32)
#define ACAMERA_ISP_DS1_DMA_WRITER_BANK2_BASE_OFFSET (0x33e8)
#define ACAMERA_ISP_DS1_DMA_WRITER_BANK2_BASE_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_ds1_dma_writer_bank2_base_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1c270L, data);
}
static __inline uint32_t acamera_isp_ds1_dma_writer_bank2_base_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1c270L);
}
// ------------------------------------------------------------------------------ //
// Register: bank3_base
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// bank 3 base address for frame buffer, should be word-aligned
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_BANK3_BASE_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_DMA_WRITER_BANK3_BASE_DATASIZE (32)
#define ACAMERA_ISP_DS1_DMA_WRITER_BANK3_BASE_OFFSET (0x33ec)
#define ACAMERA_ISP_DS1_DMA_WRITER_BANK3_BASE_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_ds1_dma_writer_bank3_base_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1c274L, data);
}
static __inline uint32_t acamera_isp_ds1_dma_writer_bank3_base_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1c274L);
}
// ------------------------------------------------------------------------------ //
// Register: bank4_base
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// bank 4 base address for frame buffer, should be word-aligned
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_BANK4_BASE_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_DMA_WRITER_BANK4_BASE_DATASIZE (32)
#define ACAMERA_ISP_DS1_DMA_WRITER_BANK4_BASE_OFFSET (0x33f0)
#define ACAMERA_ISP_DS1_DMA_WRITER_BANK4_BASE_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_ds1_dma_writer_bank4_base_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1c278L, data);
}
static __inline uint32_t acamera_isp_ds1_dma_writer_bank4_base_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1c278L);
}
// ------------------------------------------------------------------------------ //
// Register: max bank
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// highest bank*_base to use for frame writes before recycling to bank0_base, only 0 to 4 are valid
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_MAX_BANK_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_DMA_WRITER_MAX_BANK_DATASIZE (3)
#define ACAMERA_ISP_DS1_DMA_WRITER_MAX_BANK_OFFSET (0x33f4)
#define ACAMERA_ISP_DS1_DMA_WRITER_MAX_BANK_MASK (0x7)

// args: data (3-bit)
static __inline void acamera_isp_ds1_dma_writer_max_bank_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c27cL);
    system_sw_write_32(base + 0x1c27cL, (((uint32_t) (data & 0x7)) << 0) | (curr & 0xfffffff8));
}
static __inline uint8_t acamera_isp_ds1_dma_writer_max_bank_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c27cL) & 0x7) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: bank0 restart
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0 = normal operation, 1= restart bank counter to bank0 for next frame write
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_BANK0_RESTART_DEFAULT (0)
#define ACAMERA_ISP_DS1_DMA_WRITER_BANK0_RESTART_DATASIZE (1)
#define ACAMERA_ISP_DS1_DMA_WRITER_BANK0_RESTART_OFFSET (0x33f4)
#define ACAMERA_ISP_DS1_DMA_WRITER_BANK0_RESTART_MASK (0x8)

// args: data (1-bit)
static __inline void acamera_isp_ds1_dma_writer_bank0_restart_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c27cL);
    system_sw_write_32(base + 0x1c27cL, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
}
static __inline uint8_t acamera_isp_ds1_dma_writer_bank0_restart_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c27cL) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: Line_offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Indicates the offset in bytes from the start of one line to the next line.  
//        This value should be equal to or larger than one line of image data and should be word-aligned
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_LINE_OFFSET_DEFAULT (0x1000)
#define ACAMERA_ISP_DS1_DMA_WRITER_LINE_OFFSET_DATASIZE (32)
#define ACAMERA_ISP_DS1_DMA_WRITER_LINE_OFFSET_OFFSET (0x33f8)
#define ACAMERA_ISP_DS1_DMA_WRITER_LINE_OFFSET_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_ds1_dma_writer_line_offset_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1c280L, data);
}
static __inline uint32_t acamera_isp_ds1_dma_writer_line_offset_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1c280L);
}
// ------------------------------------------------------------------------------ //
// Register: wbank curr
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// write bank currently active. valid values =0-4. updated at start of frame write
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_WBANK_CURR_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_DMA_WRITER_WBANK_CURR_DATASIZE (3)
#define ACAMERA_ISP_DS1_DMA_WRITER_WBANK_CURR_OFFSET (0x33fc)
#define ACAMERA_ISP_DS1_DMA_WRITER_WBANK_CURR_MASK (0xe)

// args: data (3-bit)
static __inline uint8_t acamera_isp_ds1_dma_writer_wbank_curr_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c284L) & 0xe) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: wbank active
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 1 = wbank_curr is being written to. Goes high at start of writes, low at last write transfer/completion on axi. 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_WBANK_ACTIVE_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_DMA_WRITER_WBANK_ACTIVE_DATASIZE (1)
#define ACAMERA_ISP_DS1_DMA_WRITER_WBANK_ACTIVE_OFFSET (0x33fc)
#define ACAMERA_ISP_DS1_DMA_WRITER_WBANK_ACTIVE_MASK (0x1)

// args: data (1-bit)
static __inline uint8_t acamera_isp_ds1_dma_writer_wbank_active_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c284L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: frame icount
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// count of incomming frames (starts) to vdma_writer on video input, non resetable, rolls over, updates at pixel 1 of new frame on video in
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_FRAME_ICOUNT_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_DMA_WRITER_FRAME_ICOUNT_DATASIZE (16)
#define ACAMERA_ISP_DS1_DMA_WRITER_FRAME_ICOUNT_OFFSET (0x3408)
#define ACAMERA_ISP_DS1_DMA_WRITER_FRAME_ICOUNT_MASK (0xffff)

// args: data (16-bit)
static __inline uint16_t acamera_isp_ds1_dma_writer_frame_icount_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c290L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: frame wcount
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// count of outgoing frame writes (starts) from vdma_writer sent to AXI output, non resetable, rolls over, updates at pixel 1 of new frame on video in
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_FRAME_WCOUNT_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_DMA_WRITER_FRAME_WCOUNT_DATASIZE (16)
#define ACAMERA_ISP_DS1_DMA_WRITER_FRAME_WCOUNT_OFFSET (0x3408)
#define ACAMERA_ISP_DS1_DMA_WRITER_FRAME_WCOUNT_MASK (0xffff0000)

// args: data (16-bit)
static __inline uint16_t acamera_isp_ds1_dma_writer_frame_wcount_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c290L) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: axi_fail_bresp
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high to indicate bad  bresp captured 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_FAIL_BRESP_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_FAIL_BRESP_DATASIZE (1)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_FAIL_BRESP_OFFSET (0x3410)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_FAIL_BRESP_MASK (0x1)

// args: data (1-bit)
static __inline uint8_t acamera_isp_ds1_dma_writer_axi_fail_bresp_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c298L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: axi_fail_awmaxwait
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high when awmaxwait_limit reached 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_FAIL_AWMAXWAIT_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_FAIL_AWMAXWAIT_DATASIZE (1)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_FAIL_AWMAXWAIT_OFFSET (0x3410)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_FAIL_AWMAXWAIT_MASK (0x2)

// args: data (1-bit)
static __inline uint8_t acamera_isp_ds1_dma_writer_axi_fail_awmaxwait_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c298L) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: axi_fail_wmaxwait
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high when wmaxwait_limit reached 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_FAIL_WMAXWAIT_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_FAIL_WMAXWAIT_DATASIZE (1)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_FAIL_WMAXWAIT_OFFSET (0x3410)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_FAIL_WMAXWAIT_MASK (0x4)

// args: data (1-bit)
static __inline uint8_t acamera_isp_ds1_dma_writer_axi_fail_wmaxwait_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c298L) & 0x4) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: axi_fail_wxact_ostand
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high when wxact_ostand_limit reached 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_FAIL_WXACT_OSTAND_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_FAIL_WXACT_OSTAND_DATASIZE (1)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_FAIL_WXACT_OSTAND_OFFSET (0x3410)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_FAIL_WXACT_OSTAND_MASK (0x8)

// args: data (1-bit)
static __inline uint8_t acamera_isp_ds1_dma_writer_axi_fail_wxact_ostand_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c298L) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: vi_fail_active_width
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high to indicate mismatched active_width detected 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_VI_FAIL_ACTIVE_WIDTH_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_DMA_WRITER_VI_FAIL_ACTIVE_WIDTH_DATASIZE (1)
#define ACAMERA_ISP_DS1_DMA_WRITER_VI_FAIL_ACTIVE_WIDTH_OFFSET (0x3410)
#define ACAMERA_ISP_DS1_DMA_WRITER_VI_FAIL_ACTIVE_WIDTH_MASK (0x10)

// args: data (1-bit)
static __inline uint8_t acamera_isp_ds1_dma_writer_vi_fail_active_width_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c298L) & 0x10) >> 4);
}
// ------------------------------------------------------------------------------ //
// Register: vi_fail_active_height
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high to indicate mismatched active_height detected ( also raised on missing field!) 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_VI_FAIL_ACTIVE_HEIGHT_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_DMA_WRITER_VI_FAIL_ACTIVE_HEIGHT_DATASIZE (1)
#define ACAMERA_ISP_DS1_DMA_WRITER_VI_FAIL_ACTIVE_HEIGHT_OFFSET (0x3410)
#define ACAMERA_ISP_DS1_DMA_WRITER_VI_FAIL_ACTIVE_HEIGHT_MASK (0x20)

// args: data (1-bit)
static __inline uint8_t acamera_isp_ds1_dma_writer_vi_fail_active_height_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c298L) & 0x20) >> 5);
}
// ------------------------------------------------------------------------------ //
// Register: vi_fail_interline_blanks
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high to indicate interline blanking below min 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_VI_FAIL_INTERLINE_BLANKS_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_DMA_WRITER_VI_FAIL_INTERLINE_BLANKS_DATASIZE (1)
#define ACAMERA_ISP_DS1_DMA_WRITER_VI_FAIL_INTERLINE_BLANKS_OFFSET (0x3410)
#define ACAMERA_ISP_DS1_DMA_WRITER_VI_FAIL_INTERLINE_BLANKS_MASK (0x40)

// args: data (1-bit)
static __inline uint8_t acamera_isp_ds1_dma_writer_vi_fail_interline_blanks_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c298L) & 0x40) >> 6);
}
// ------------------------------------------------------------------------------ //
// Register: vi_fail_interframe_blanks
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high to indicate interframe blanking below min 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_VI_FAIL_INTERFRAME_BLANKS_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_DMA_WRITER_VI_FAIL_INTERFRAME_BLANKS_DATASIZE (1)
#define ACAMERA_ISP_DS1_DMA_WRITER_VI_FAIL_INTERFRAME_BLANKS_OFFSET (0x3410)
#define ACAMERA_ISP_DS1_DMA_WRITER_VI_FAIL_INTERFRAME_BLANKS_MASK (0x80)

// args: data (1-bit)
static __inline uint8_t acamera_isp_ds1_dma_writer_vi_fail_interframe_blanks_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c298L) & 0x80) >> 7);
}
// ------------------------------------------------------------------------------ //
// Register: video_alarm
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  active high, problem found on video port(s) ( active width/height or interline/frame blanks failure) 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_VIDEO_ALARM_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_DMA_WRITER_VIDEO_ALARM_DATASIZE (1)
#define ACAMERA_ISP_DS1_DMA_WRITER_VIDEO_ALARM_OFFSET (0x3410)
#define ACAMERA_ISP_DS1_DMA_WRITER_VIDEO_ALARM_MASK (0x100)

// args: data (1-bit)
static __inline uint8_t acamera_isp_ds1_dma_writer_video_alarm_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c298L) & 0x100) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: blk_status
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        block status output (reserved)
//                          -- blk_status(0) = wfifo_fail_full
//                          -- blk_status(1) = wfifo_fail_empty
//                          -- blk_status(4) = pack_fail_overflow
//                          -- blk_status(24) = intw_fail_user_intfc_sig
//                          -- blk_status(others) =  zero     
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_BLK_STATUS_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_DMA_WRITER_BLK_STATUS_DATASIZE (32)
#define ACAMERA_ISP_DS1_DMA_WRITER_BLK_STATUS_OFFSET (0x3414)
#define ACAMERA_ISP_DS1_DMA_WRITER_BLK_STATUS_MASK (0xffffffff)

// args: data (32-bit)
static __inline uint32_t acamera_isp_ds1_dma_writer_blk_status_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1c29cL);
}
// ------------------------------------------------------------------------------ //
// Register: lines_wrapped
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Number of lines to write from base address before wrapping back to base address. 0 = no wrapping, >0 = last line written before wrapping
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_LINES_WRAPPED_DEFAULT (0x0000)
#define ACAMERA_ISP_DS1_DMA_WRITER_LINES_WRAPPED_DATASIZE (16)
#define ACAMERA_ISP_DS1_DMA_WRITER_LINES_WRAPPED_OFFSET (0x3418)
#define ACAMERA_ISP_DS1_DMA_WRITER_LINES_WRAPPED_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_ds1_dma_writer_lines_wrapped_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c2a0L);
    system_sw_write_32(base + 0x1c2a0L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_ds1_dma_writer_lines_wrapped_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c2a0L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: linetick_first
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Line number of first linetick. 0  = no linetick, >0 = line number to generate linetick 
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_LINETICK_FIRST_DEFAULT (0x0000)
#define ACAMERA_ISP_DS1_DMA_WRITER_LINETICK_FIRST_DATASIZE (16)
#define ACAMERA_ISP_DS1_DMA_WRITER_LINETICK_FIRST_OFFSET (0x341c)
#define ACAMERA_ISP_DS1_DMA_WRITER_LINETICK_FIRST_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_ds1_dma_writer_linetick_first_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c2a4L);
    system_sw_write_32(base + 0x1c2a4L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_ds1_dma_writer_linetick_first_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c2a4L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: linetick_repeat
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Line repeat interval of linetick. 0 = no repeat, >0 = repeat interval in lines 
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_LINETICK_REPEAT_DEFAULT (0x0000)
#define ACAMERA_ISP_DS1_DMA_WRITER_LINETICK_REPEAT_DATASIZE (16)
#define ACAMERA_ISP_DS1_DMA_WRITER_LINETICK_REPEAT_OFFSET (0x3420)
#define ACAMERA_ISP_DS1_DMA_WRITER_LINETICK_REPEAT_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_ds1_dma_writer_linetick_repeat_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c2a8L);
    system_sw_write_32(base + 0x1c2a8L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_ds1_dma_writer_linetick_repeat_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c2a8L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: linetick_eol
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Linetick start/end of line control. 0 = use start of line, 1 = use end of line to generate linetick
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_LINETICK_EOL_DEFAULT (0)
#define ACAMERA_ISP_DS1_DMA_WRITER_LINETICK_EOL_DATASIZE (1)
#define ACAMERA_ISP_DS1_DMA_WRITER_LINETICK_EOL_OFFSET (0x3424)
#define ACAMERA_ISP_DS1_DMA_WRITER_LINETICK_EOL_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_ds1_dma_writer_linetick_eol_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c2acL);
    system_sw_write_32(base + 0x1c2acL, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_ds1_dma_writer_linetick_eol_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c2acL) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: linetick_delay
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Linetick delay in vcke cycles to add to min 3 cycle latency from acl_vi. 0-65535.
//        Must be less than next linetick generation time or count will not mature and no linetick is not produced.
//          --NOTE: linetick delay  can run past end of frame/field and also into next frame!
//          --      Take care maturity time is less than next configured linetick generation postion!
//          --      Take care when changing config between frame too! 
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_LINETICK_DELAY_DEFAULT (0x0000)
#define ACAMERA_ISP_DS1_DMA_WRITER_LINETICK_DELAY_DATASIZE (16)
#define ACAMERA_ISP_DS1_DMA_WRITER_LINETICK_DELAY_OFFSET (0x3424)
#define ACAMERA_ISP_DS1_DMA_WRITER_LINETICK_DELAY_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_ds1_dma_writer_linetick_delay_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c2acL);
    system_sw_write_32(base + 0x1c2acL, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_ds1_dma_writer_linetick_delay_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c2acL) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: pagewarm_on
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        active high, enables posting of pagewarm dummy writes to SMMU for early page translation of upcomming 4K pages. 
//        Recommend SMMU has min 8 page cache to avoid translation miss. Pagewarms are posted as dummy writes with wstrb= 0
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_PAGEWARM_ON_DEFAULT (0)
#define ACAMERA_ISP_DS1_DMA_WRITER_PAGEWARM_ON_DATASIZE (1)
#define ACAMERA_ISP_DS1_DMA_WRITER_PAGEWARM_ON_OFFSET (0x3428)
#define ACAMERA_ISP_DS1_DMA_WRITER_PAGEWARM_ON_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_ds1_dma_writer_pagewarm_on_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c2b0L);
    system_sw_write_32(base + 0x1c2b0L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_ds1_dma_writer_pagewarm_on_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c2b0L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: axi_id_multi
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        0= static value (axi_id_value) for awid/wid, 1 = incrementing value per transaction for awid/wid wrapping to 0 after axi_id_value
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_ID_MULTI_DEFAULT (0)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_ID_MULTI_DATASIZE (1)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_ID_MULTI_OFFSET (0x3428)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_ID_MULTI_MASK (0x2)

// args: data (1-bit)
static __inline void acamera_isp_ds1_dma_writer_axi_id_multi_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c2b0L);
    system_sw_write_32(base + 0x1c2b0L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
}
static __inline uint8_t acamera_isp_ds1_dma_writer_axi_id_multi_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c2b0L) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: axi_burstsplit
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        memory boundary that splits bursts: 0=2Transfers,1=4Transfers,2=8Transfers,3=16Transfers. (for axi_data_w=128,  16transfers=256Bytes). Good default = 11
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_BURSTSPLIT_DEFAULT (0x3)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_BURSTSPLIT_DATASIZE (2)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_BURSTSPLIT_OFFSET (0x3428)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_BURSTSPLIT_MASK (0xc)

// args: data (2-bit)
static __inline void acamera_isp_ds1_dma_writer_axi_burstsplit_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c2b0L);
    system_sw_write_32(base + 0x1c2b0L, (((uint32_t) (data & 0x3)) << 2) | (curr & 0xfffffff3));
}
static __inline uint8_t acamera_isp_ds1_dma_writer_axi_burstsplit_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c2b0L) & 0xc) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: axi_cache_value
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        value to send for awcache. Good default = 1111
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_CACHE_VALUE_DEFAULT (0xf)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_CACHE_VALUE_DATASIZE (4)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_CACHE_VALUE_OFFSET (0x3428)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_CACHE_VALUE_MASK (0xf00)

// args: data (4-bit)
static __inline void acamera_isp_ds1_dma_writer_axi_cache_value_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c2b0L);
    system_sw_write_32(base + 0x1c2b0L, (((uint32_t) (data & 0xf)) << 8) | (curr & 0xfffff0ff));
}
static __inline uint8_t acamera_isp_ds1_dma_writer_axi_cache_value_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c2b0L) & 0xf00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: axi_maxostand
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        max outstanding write transactions (bursts) allowed. zero means no maximum(uses internal limit of 2048). 
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_MAXOSTAND_DEFAULT (0x00)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_MAXOSTAND_DATASIZE (8)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_MAXOSTAND_OFFSET (0x3428)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_MAXOSTAND_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_ds1_dma_writer_axi_maxostand_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c2b0L);
    system_sw_write_32(base + 0x1c2b0L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_ds1_dma_writer_axi_maxostand_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c2b0L) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: axi_max_awlen
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        max value to use for awlen (axi burst length). 0000= max 1 transfer/burst , upto 1111= max 16 transfers/burst
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_MAX_AWLEN_DEFAULT (0xf)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_MAX_AWLEN_DATASIZE (4)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_MAX_AWLEN_OFFSET (0x3428)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_MAX_AWLEN_MASK (0xf000000)

// args: data (4-bit)
static __inline void acamera_isp_ds1_dma_writer_axi_max_awlen_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c2b0L);
    system_sw_write_32(base + 0x1c2b0L, (((uint32_t) (data & 0xf)) << 24) | (curr & 0xf0ffffff));
}
static __inline uint8_t acamera_isp_ds1_dma_writer_axi_max_awlen_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c2b0L) & 0xf000000) >> 24);
}
// ------------------------------------------------------------------------------ //
// Register: axi_id_value
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        value to send for awid, wid and expected on bid. Good default = 0000
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_ID_VALUE_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_ID_VALUE_DATASIZE (4)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_ID_VALUE_OFFSET (0x342c)
#define ACAMERA_ISP_DS1_DMA_WRITER_AXI_ID_VALUE_MASK (0xf)

// args: data (4-bit)
static __inline void acamera_isp_ds1_dma_writer_axi_id_value_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c2b4L);
    system_sw_write_32(base + 0x1c2b4L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
}
static __inline uint8_t acamera_isp_ds1_dma_writer_axi_id_value_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c2b4L) & 0xf) >> 0);
}
// ------------------------------------------------------------------------------ //
// Group: ds uv dma writer
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// DMA writer controls
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Format
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Format
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_FORMAT_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_FORMAT_DATASIZE (8)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_FORMAT_OFFSET (0x3430)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_FORMAT_MASK (0xff)

// args: data (8-bit)
static __inline void acamera_isp_ds1_uv_dma_writer_format_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c2b8L);
    system_sw_write_32(base + 0x1c2b8L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
}
static __inline uint8_t acamera_isp_ds1_uv_dma_writer_format_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c2b8L) & 0xff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Base mode
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Base DMA packing mode for RGB/RAW/YUV etc (see ISP guide)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BASE_MODE_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BASE_MODE_DATASIZE (5)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BASE_MODE_OFFSET (0x3430)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BASE_MODE_MASK (0x1f)

// args: data (5-bit)
static __inline void acamera_isp_ds1_uv_dma_writer_base_mode_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c2b8L);
    system_sw_write_32(base + 0x1c2b8L, (((uint32_t) (data & 0x1f)) << 0) | (curr & 0xffffffe0));
}
static __inline uint8_t acamera_isp_ds1_uv_dma_writer_base_mode_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c2b8L) & 0x1f) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: Plane select
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Plane select for planar base modes.  Only used if planar outputs required.  Not used.  Should be set to 0
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_PLANE_SELECT_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_PLANE_SELECT_DATASIZE (2)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_PLANE_SELECT_OFFSET (0x3430)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_PLANE_SELECT_MASK (0xc0)

// args: data (2-bit)
static __inline void acamera_isp_ds1_uv_dma_writer_plane_select_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c2b8L);
    system_sw_write_32(base + 0x1c2b8L, (((uint32_t) (data & 0x3)) << 6) | (curr & 0xffffff3f));
}
static __inline uint8_t acamera_isp_ds1_uv_dma_writer_plane_select_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c2b8L) & 0xc0) >> 6);
}
// ------------------------------------------------------------------------------ //
// Register: single frame
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0 = All frames are written(after frame_write_on= 1), 1= only 1st frame written ( after frame_write_on =1)
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_SINGLE_FRAME_DEFAULT (0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_SINGLE_FRAME_DATASIZE (1)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_SINGLE_FRAME_OFFSET (0x3430)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_SINGLE_FRAME_MASK (0x100)

// args: data (1-bit)
static __inline void acamera_isp_ds1_uv_dma_writer_single_frame_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c2b8L);
    system_sw_write_32(base + 0x1c2b8L, (((uint32_t) (data & 0x1)) << 8) | (curr & 0xfffffeff));
}
static __inline uint8_t acamera_isp_ds1_uv_dma_writer_single_frame_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c2b8L) & 0x100) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: frame write on
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        0 = no frames written(when switched from 1, current frame completes writing before stopping),
//        1= write frame(s) (write single or continous frame(s) )
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_FRAME_WRITE_ON_DEFAULT (0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_FRAME_WRITE_ON_DATASIZE (1)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_FRAME_WRITE_ON_OFFSET (0x3430)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_FRAME_WRITE_ON_MASK (0x200)

// args: data (1-bit)
static __inline void acamera_isp_ds1_uv_dma_writer_frame_write_on_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c2b8L);
    system_sw_write_32(base + 0x1c2b8L, (((uint32_t) (data & 0x1)) << 9) | (curr & 0xfffffdff));
}
static __inline uint8_t acamera_isp_ds1_uv_dma_writer_frame_write_on_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c2b8L) & 0x200) >> 9);
}
// ------------------------------------------------------------------------------ //
// Register: axi xact comp
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0 = dont wait for axi transaction completion at end of frame(just all transfers accepted). 1 = wait for all transactions completed
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_XACT_COMP_DEFAULT (0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_XACT_COMP_DATASIZE (1)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_XACT_COMP_OFFSET (0x3430)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_XACT_COMP_MASK (0x800)

// args: data (1-bit)
static __inline void acamera_isp_ds1_uv_dma_writer_axi_xact_comp_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c2b8L);
    system_sw_write_32(base + 0x1c2b8L, (((uint32_t) (data & 0x1)) << 11) | (curr & 0xfffff7ff));
}
static __inline uint8_t acamera_isp_ds1_uv_dma_writer_axi_xact_comp_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c2b8L) & 0x800) >> 11);
}
// ------------------------------------------------------------------------------ //
// Register: active width
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Active video width in pixels 128-8000
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_ACTIVE_WIDTH_DEFAULT (0x780)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_ACTIVE_WIDTH_DATASIZE (16)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_ACTIVE_WIDTH_OFFSET (0x3434)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_ACTIVE_WIDTH_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_ds1_uv_dma_writer_active_width_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c2bcL);
    system_sw_write_32(base + 0x1c2bcL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_ds1_uv_dma_writer_active_width_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c2bcL) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: active height
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Active video height in lines 128-8000
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_ACTIVE_HEIGHT_DEFAULT (0x438)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_ACTIVE_HEIGHT_DATASIZE (16)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_ACTIVE_HEIGHT_OFFSET (0x3434)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_ACTIVE_HEIGHT_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_ds1_uv_dma_writer_active_height_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c2bcL);
    system_sw_write_32(base + 0x1c2bcL, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_ds1_uv_dma_writer_active_height_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c2bcL) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: bank0_base
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// bank 0 base address for frame buffer, should be word-aligned
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BANK0_BASE_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BANK0_BASE_DATASIZE (32)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BANK0_BASE_OFFSET (0x3438)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BANK0_BASE_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_ds1_uv_dma_writer_bank0_base_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1c2c0L, data);
}
static __inline uint32_t acamera_isp_ds1_uv_dma_writer_bank0_base_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1c2c0L);
}
// ------------------------------------------------------------------------------ //
// Register: bank1_base
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// bank 1 base address for frame buffer, should be word-aligned
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BANK1_BASE_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BANK1_BASE_DATASIZE (32)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BANK1_BASE_OFFSET (0x343c)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BANK1_BASE_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_ds1_uv_dma_writer_bank1_base_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1c2c4L, data);
}
static __inline uint32_t acamera_isp_ds1_uv_dma_writer_bank1_base_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1c2c4L);
}
// ------------------------------------------------------------------------------ //
// Register: bank2_base
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// bank 2 base address for frame buffer, should be word-aligned
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BANK2_BASE_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BANK2_BASE_DATASIZE (32)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BANK2_BASE_OFFSET (0x3440)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BANK2_BASE_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_ds1_uv_dma_writer_bank2_base_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1c2c8L, data);
}
static __inline uint32_t acamera_isp_ds1_uv_dma_writer_bank2_base_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1c2c8L);
}
// ------------------------------------------------------------------------------ //
// Register: bank3_base
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// bank 3 base address for frame buffer, should be word-aligned
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BANK3_BASE_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BANK3_BASE_DATASIZE (32)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BANK3_BASE_OFFSET (0x3444)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BANK3_BASE_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_ds1_uv_dma_writer_bank3_base_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1c2ccL, data);
}
static __inline uint32_t acamera_isp_ds1_uv_dma_writer_bank3_base_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1c2ccL);
}
// ------------------------------------------------------------------------------ //
// Register: bank4_base
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// bank 4 base address for frame buffer, should be word-aligned
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BANK4_BASE_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BANK4_BASE_DATASIZE (32)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BANK4_BASE_OFFSET (0x3448)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BANK4_BASE_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_ds1_uv_dma_writer_bank4_base_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1c2d0L, data);
}
static __inline uint32_t acamera_isp_ds1_uv_dma_writer_bank4_base_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1c2d0L);
}
// ------------------------------------------------------------------------------ //
// Register: max bank
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// highest bank*_base to use for frame writes before recycling to bank0_base, only 0 to 4 are valid
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_MAX_BANK_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_MAX_BANK_DATASIZE (3)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_MAX_BANK_OFFSET (0x344c)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_MAX_BANK_MASK (0x7)

// args: data (3-bit)
static __inline void acamera_isp_ds1_uv_dma_writer_max_bank_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c2d4L);
    system_sw_write_32(base + 0x1c2d4L, (((uint32_t) (data & 0x7)) << 0) | (curr & 0xfffffff8));
}
static __inline uint8_t acamera_isp_ds1_uv_dma_writer_max_bank_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c2d4L) & 0x7) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: bank0 restart
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 0 = normal operation, 1= restart bank counter to bank0 for next frame write
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BANK0_RESTART_DEFAULT (0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BANK0_RESTART_DATASIZE (1)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BANK0_RESTART_OFFSET (0x344c)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BANK0_RESTART_MASK (0x8)

// args: data (1-bit)
static __inline void acamera_isp_ds1_uv_dma_writer_bank0_restart_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c2d4L);
    system_sw_write_32(base + 0x1c2d4L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
}
static __inline uint8_t acamera_isp_ds1_uv_dma_writer_bank0_restart_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c2d4L) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: Line_offset
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Indicates the offset in bytes from the start of one line to the next line.  
//        This value should be equal to or larger than one line of image data and should be word-aligned
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_LINE_OFFSET_DEFAULT (0x1000)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_LINE_OFFSET_DATASIZE (32)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_LINE_OFFSET_OFFSET (0x3450)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_LINE_OFFSET_MASK (0xffffffff)

// args: data (32-bit)
static __inline void acamera_isp_ds1_uv_dma_writer_line_offset_write(uintptr_t base, uint32_t data) {
    system_sw_write_32(base + 0x1c2d8L, data);
}
static __inline uint32_t acamera_isp_ds1_uv_dma_writer_line_offset_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1c2d8L);
}
// ------------------------------------------------------------------------------ //
// Register: wbank curr
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// write bank currently active. valid values =0-4. updated at start of frame write
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_WBANK_CURR_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_WBANK_CURR_DATASIZE (3)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_WBANK_CURR_OFFSET (0x3454)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_WBANK_CURR_MASK (0xe)

// args: data (3-bit)
static __inline uint8_t acamera_isp_ds1_uv_dma_writer_wbank_curr_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c2dcL) & 0xe) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: wbank active
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 1 = wbank_curr is being written to. Goes high at start of writes, low at last write transfer/completion on axi. 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_WBANK_ACTIVE_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_WBANK_ACTIVE_DATASIZE (1)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_WBANK_ACTIVE_OFFSET (0x3454)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_WBANK_ACTIVE_MASK (0x1)

// args: data (1-bit)
static __inline uint8_t acamera_isp_ds1_uv_dma_writer_wbank_active_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c2dcL) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: frame icount
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// count of incomming frames (starts) to vdma_writer on video input, non resetable, rolls over, updates at pixel 1 of new frame on video in
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_FRAME_ICOUNT_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_FRAME_ICOUNT_DATASIZE (16)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_FRAME_ICOUNT_OFFSET (0x3460)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_FRAME_ICOUNT_MASK (0xffff)

// args: data (16-bit)
static __inline uint16_t acamera_isp_ds1_uv_dma_writer_frame_icount_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c2e8L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: frame wcount
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// count of outgoing frame writes (starts) from vdma_writer sent to AXI output, non resetable, rolls over, updates at pixel 1 of new frame on video in
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_FRAME_WCOUNT_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_FRAME_WCOUNT_DATASIZE (16)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_FRAME_WCOUNT_OFFSET (0x3460)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_FRAME_WCOUNT_MASK (0xffff0000)

// args: data (16-bit)
static __inline uint16_t acamera_isp_ds1_uv_dma_writer_frame_wcount_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c2e8L) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: axi_fail_bresp
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high to indicate bad  bresp captured 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_FAIL_BRESP_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_FAIL_BRESP_DATASIZE (1)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_FAIL_BRESP_OFFSET (0x3468)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_FAIL_BRESP_MASK (0x1)

// args: data (1-bit)
static __inline uint8_t acamera_isp_ds1_uv_dma_writer_axi_fail_bresp_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c2f0L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: axi_fail_awmaxwait
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high when awmaxwait_limit reached 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_FAIL_AWMAXWAIT_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_FAIL_AWMAXWAIT_DATASIZE (1)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_FAIL_AWMAXWAIT_OFFSET (0x3468)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_FAIL_AWMAXWAIT_MASK (0x2)

// args: data (1-bit)
static __inline uint8_t acamera_isp_ds1_uv_dma_writer_axi_fail_awmaxwait_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c2f0L) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: axi_fail_wmaxwait
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high when wmaxwait_limit reached 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_FAIL_WMAXWAIT_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_FAIL_WMAXWAIT_DATASIZE (1)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_FAIL_WMAXWAIT_OFFSET (0x3468)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_FAIL_WMAXWAIT_MASK (0x4)

// args: data (1-bit)
static __inline uint8_t acamera_isp_ds1_uv_dma_writer_axi_fail_wmaxwait_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c2f0L) & 0x4) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: axi_fail_wxact_ostand
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high when wxact_ostand_limit reached 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_FAIL_WXACT_OSTAND_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_FAIL_WXACT_OSTAND_DATASIZE (1)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_FAIL_WXACT_OSTAND_OFFSET (0x3468)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_FAIL_WXACT_OSTAND_MASK (0x8)

// args: data (1-bit)
static __inline uint8_t acamera_isp_ds1_uv_dma_writer_axi_fail_wxact_ostand_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c2f0L) & 0x8) >> 3);
}
// ------------------------------------------------------------------------------ //
// Register: vi_fail_active_width
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high to indicate mismatched active_width detected 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_VI_FAIL_ACTIVE_WIDTH_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_VI_FAIL_ACTIVE_WIDTH_DATASIZE (1)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_VI_FAIL_ACTIVE_WIDTH_OFFSET (0x3468)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_VI_FAIL_ACTIVE_WIDTH_MASK (0x10)

// args: data (1-bit)
static __inline uint8_t acamera_isp_ds1_uv_dma_writer_vi_fail_active_width_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c2f0L) & 0x10) >> 4);
}
// ------------------------------------------------------------------------------ //
// Register: vi_fail_active_height
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high to indicate mismatched active_height detected ( also raised on missing field!) 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_VI_FAIL_ACTIVE_HEIGHT_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_VI_FAIL_ACTIVE_HEIGHT_DATASIZE (1)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_VI_FAIL_ACTIVE_HEIGHT_OFFSET (0x3468)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_VI_FAIL_ACTIVE_HEIGHT_MASK (0x20)

// args: data (1-bit)
static __inline uint8_t acamera_isp_ds1_uv_dma_writer_vi_fail_active_height_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c2f0L) & 0x20) >> 5);
}
// ------------------------------------------------------------------------------ //
// Register: vi_fail_interline_blanks
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high to indicate interline blanking below min 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_VI_FAIL_INTERLINE_BLANKS_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_VI_FAIL_INTERLINE_BLANKS_DATASIZE (1)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_VI_FAIL_INTERLINE_BLANKS_OFFSET (0x3468)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_VI_FAIL_INTERLINE_BLANKS_MASK (0x40)

// args: data (1-bit)
static __inline uint8_t acamera_isp_ds1_uv_dma_writer_vi_fail_interline_blanks_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c2f0L) & 0x40) >> 6);
}
// ------------------------------------------------------------------------------ //
// Register: vi_fail_interframe_blanks
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  clearable alarm, high to indicate interframe blanking below min 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_VI_FAIL_INTERFRAME_BLANKS_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_VI_FAIL_INTERFRAME_BLANKS_DATASIZE (1)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_VI_FAIL_INTERFRAME_BLANKS_OFFSET (0x3468)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_VI_FAIL_INTERFRAME_BLANKS_MASK (0x80)

// args: data (1-bit)
static __inline uint8_t acamera_isp_ds1_uv_dma_writer_vi_fail_interframe_blanks_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c2f0L) & 0x80) >> 7);
}
// ------------------------------------------------------------------------------ //
// Register: video_alarm
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
//  active high, problem found on video port(s) ( active width/height or interline/frame blanks failure) 
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_VIDEO_ALARM_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_VIDEO_ALARM_DATASIZE (1)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_VIDEO_ALARM_OFFSET (0x3468)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_VIDEO_ALARM_MASK (0x100)

// args: data (1-bit)
static __inline uint8_t acamera_isp_ds1_uv_dma_writer_video_alarm_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c2f0L) & 0x100) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: blk_status
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        block status output (reserved)
//                          -- blk_status(0) = wfifo_fail_full
//                          -- blk_status(1) = wfifo_fail_empty
//                          -- blk_status(4) = pack_fail_overflow
//                          -- blk_status(24) = intw_fail_user_intfc_sig
//                          -- blk_status(others) =  zero     
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BLK_STATUS_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BLK_STATUS_DATASIZE (32)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BLK_STATUS_OFFSET (0x346c)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_BLK_STATUS_MASK (0xffffffff)

// args: data (32-bit)
static __inline uint32_t acamera_isp_ds1_uv_dma_writer_blk_status_read(uintptr_t base) {
    return system_sw_read_32(base + 0x1c2f4L);
}
// ------------------------------------------------------------------------------ //
// Register: lines_wrapped
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Number of lines to write from base address before wrapping back to base address. 0 = no wrapping, >0 = last line written before wrapping
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_LINES_WRAPPED_DEFAULT (0x0000)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_LINES_WRAPPED_DATASIZE (16)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_LINES_WRAPPED_OFFSET (0x3470)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_LINES_WRAPPED_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_ds1_uv_dma_writer_lines_wrapped_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c2f8L);
    system_sw_write_32(base + 0x1c2f8L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_ds1_uv_dma_writer_lines_wrapped_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c2f8L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: linetick_first
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Line number of first linetick. 0  = no linetick, >0 = line number to generate linetick 
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_LINETICK_FIRST_DEFAULT (0x0000)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_LINETICK_FIRST_DATASIZE (16)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_LINETICK_FIRST_OFFSET (0x3474)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_LINETICK_FIRST_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_ds1_uv_dma_writer_linetick_first_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c2fcL);
    system_sw_write_32(base + 0x1c2fcL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_ds1_uv_dma_writer_linetick_first_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c2fcL) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: linetick_repeat
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Line repeat interval of linetick. 0 = no repeat, >0 = repeat interval in lines 
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_LINETICK_REPEAT_DEFAULT (0x0000)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_LINETICK_REPEAT_DATASIZE (16)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_LINETICK_REPEAT_OFFSET (0x3478)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_LINETICK_REPEAT_MASK (0xffff)

// args: data (16-bit)
static __inline void acamera_isp_ds1_uv_dma_writer_linetick_repeat_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c300L);
    system_sw_write_32(base + 0x1c300L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
}
static __inline uint16_t acamera_isp_ds1_uv_dma_writer_linetick_repeat_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c300L) & 0xffff) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: linetick_eol
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Linetick start/end of line control. 0 = use start of line, 1 = use end of line to generate linetick
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_LINETICK_EOL_DEFAULT (0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_LINETICK_EOL_DATASIZE (1)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_LINETICK_EOL_OFFSET (0x347c)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_LINETICK_EOL_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_ds1_uv_dma_writer_linetick_eol_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c304L);
    system_sw_write_32(base + 0x1c304L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_ds1_uv_dma_writer_linetick_eol_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c304L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: linetick_delay
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        Linetick delay in vcke cycles to add to min 3 cycle latency from acl_vi. 0-65535.
//        Must be less than next linetick generation time or count will not mature and no linetick is not produced.
//          --NOTE: linetick delay  can run past end of frame/field and also into next frame!
//          --      Take care maturity time is less than next configured linetick generation postion!
//          --      Take care when changing config between frame too! 
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_LINETICK_DELAY_DEFAULT (0x0000)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_LINETICK_DELAY_DATASIZE (16)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_LINETICK_DELAY_OFFSET (0x347c)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_LINETICK_DELAY_MASK (0xffff0000)

// args: data (16-bit)
static __inline void acamera_isp_ds1_uv_dma_writer_linetick_delay_write(uintptr_t base, uint16_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c304L);
    system_sw_write_32(base + 0x1c304L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
}
static __inline uint16_t acamera_isp_ds1_uv_dma_writer_linetick_delay_read(uintptr_t base) {
    return (uint16_t)((system_sw_read_32(base + 0x1c304L) & 0xffff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: pagewarm_on
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        active high, enables posting of pagewarm dummy writes to SMMU for early page translation of upcomming 4K pages. 
//        Recommend SMMU has min 8 page cache to avoid translation miss. Pagewarms are posted as dummy writes with wstrb= 0
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_PAGEWARM_ON_DEFAULT (0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_PAGEWARM_ON_DATASIZE (1)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_PAGEWARM_ON_OFFSET (0x3480)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_PAGEWARM_ON_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_ds1_uv_dma_writer_pagewarm_on_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c308L);
    system_sw_write_32(base + 0x1c308L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_ds1_uv_dma_writer_pagewarm_on_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c308L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
// Register: axi_id_multi
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        0= static value (axi_id_value) for awid/wid, 1 = incrementing value per transaction for awid/wid wrapping to 0 after axi_id_value
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_ID_MULTI_DEFAULT (0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_ID_MULTI_DATASIZE (1)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_ID_MULTI_OFFSET (0x3480)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_ID_MULTI_MASK (0x2)

// args: data (1-bit)
static __inline void acamera_isp_ds1_uv_dma_writer_axi_id_multi_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c308L);
    system_sw_write_32(base + 0x1c308L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
}
static __inline uint8_t acamera_isp_ds1_uv_dma_writer_axi_id_multi_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c308L) & 0x2) >> 1);
}
// ------------------------------------------------------------------------------ //
// Register: axi_burstsplit
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        memory boundary that splits bursts: 0=2Transfers,1=4Transfers,2=8Transfers,3=16Transfers. (for axi_data_w=128,  16transfers=256Bytes). Good default = 11
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_BURSTSPLIT_DEFAULT (0x3)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_BURSTSPLIT_DATASIZE (2)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_BURSTSPLIT_OFFSET (0x3480)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_BURSTSPLIT_MASK (0xc)

// args: data (2-bit)
static __inline void acamera_isp_ds1_uv_dma_writer_axi_burstsplit_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c308L);
    system_sw_write_32(base + 0x1c308L, (((uint32_t) (data & 0x3)) << 2) | (curr & 0xfffffff3));
}
static __inline uint8_t acamera_isp_ds1_uv_dma_writer_axi_burstsplit_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c308L) & 0xc) >> 2);
}
// ------------------------------------------------------------------------------ //
// Register: axi_cache_value
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        value to send for awcache. Good default = 1111
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_CACHE_VALUE_DEFAULT (0xf)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_CACHE_VALUE_DATASIZE (4)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_CACHE_VALUE_OFFSET (0x3480)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_CACHE_VALUE_MASK (0xf00)

// args: data (4-bit)
static __inline void acamera_isp_ds1_uv_dma_writer_axi_cache_value_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c308L);
    system_sw_write_32(base + 0x1c308L, (((uint32_t) (data & 0xf)) << 8) | (curr & 0xfffff0ff));
}
static __inline uint8_t acamera_isp_ds1_uv_dma_writer_axi_cache_value_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c308L) & 0xf00) >> 8);
}
// ------------------------------------------------------------------------------ //
// Register: axi_maxostand
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        max outstanding write transactions (bursts) allowed. zero means no maximum(uses internal limit of 2048). 
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_MAXOSTAND_DEFAULT (0x00)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_MAXOSTAND_DATASIZE (8)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_MAXOSTAND_OFFSET (0x3480)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_MAXOSTAND_MASK (0xff0000)

// args: data (8-bit)
static __inline void acamera_isp_ds1_uv_dma_writer_axi_maxostand_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c308L);
    system_sw_write_32(base + 0x1c308L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
}
static __inline uint8_t acamera_isp_ds1_uv_dma_writer_axi_maxostand_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c308L) & 0xff0000) >> 16);
}
// ------------------------------------------------------------------------------ //
// Register: axi_max_awlen
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        max value to use for awlen (axi burst length). 0000= max 1 transfer/burst , upto 1111= max 16 transfers/burst
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_MAX_AWLEN_DEFAULT (0xf)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_MAX_AWLEN_DATASIZE (4)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_MAX_AWLEN_OFFSET (0x3480)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_MAX_AWLEN_MASK (0xf000000)

// args: data (4-bit)
static __inline void acamera_isp_ds1_uv_dma_writer_axi_max_awlen_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c308L);
    system_sw_write_32(base + 0x1c308L, (((uint32_t) (data & 0xf)) << 24) | (curr & 0xf0ffffff));
}
static __inline uint8_t acamera_isp_ds1_uv_dma_writer_axi_max_awlen_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c308L) & 0xf000000) >> 24);
}
// ------------------------------------------------------------------------------ //
// Register: axi_id_value
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//        value to send for awid, wid and expected on bid. Good default = 0000
//        
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_ID_VALUE_DEFAULT (0x0)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_ID_VALUE_DATASIZE (4)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_ID_VALUE_OFFSET (0x3484)
#define ACAMERA_ISP_DS1_UV_DMA_WRITER_AXI_ID_VALUE_MASK (0xf)

// args: data (4-bit)
static __inline void acamera_isp_ds1_uv_dma_writer_axi_id_value_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c30cL);
    system_sw_write_32(base + 0x1c30cL, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
}
static __inline uint8_t acamera_isp_ds1_uv_dma_writer_axi_id_value_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c30cL) & 0xf) >> 0);
}
// ------------------------------------------------------------------------------ //
// Group: multi ctx
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// Register: Config done
// ------------------------------------------------------------------------------ //

// ------------------------------------------------------------------------------ //
// 
//            This signal is only required in multi-context mode
//            Once configuration for ping/pong address space is done, MCU must write 1 into this address
//            This register is self-clearing. So the read-back will be 0
//          
// ------------------------------------------------------------------------------ //

#define ACAMERA_ISP_MULTI_CTX_CONFIG_DONE_DEFAULT (0)
#define ACAMERA_ISP_MULTI_CTX_CONFIG_DONE_DATASIZE (1)
#define ACAMERA_ISP_MULTI_CTX_CONFIG_DONE_OFFSET (0x3488)
#define ACAMERA_ISP_MULTI_CTX_CONFIG_DONE_MASK (0x1)

// args: data (1-bit)
static __inline void acamera_isp_multi_ctx_config_done_write(uintptr_t base, uint8_t data) {
    uint32_t curr = system_sw_read_32(base + 0x1c310L);
    system_sw_write_32(base + 0x1c310L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
}
static __inline uint8_t acamera_isp_multi_ctx_config_done_read(uintptr_t base) {
    return (uint8_t)((system_sw_read_32(base + 0x1c310L) & 0x1) >> 0);
}
// ------------------------------------------------------------------------------ //
#endif //__ACAMERA_ISP1_CONFIG_H__
